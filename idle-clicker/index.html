<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Apex Dice RPG ‚Äî Kingdoms</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
:root{
  --bg0:#070b1a;
  --bg1:#0b1026;
  --accent:#7c5cff;
  --card:rgba(255,255,255,.08);
  --border:rgba(255,255,255,.14);
  --text:#e5e7eb;
  --muted:#9ca3af;
  --good:#34d399;
  --bad:#fb7185;
  --warn:#fbbf24;

  --sea:#0b2a6a;
  --sea2:#081a43;

  --land:#1f6b3f;
  --land2:#173b2a;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  background:
    radial-gradient(1200px 600px at 60% -10%, #7c5cff55, transparent 60%),
    linear-gradient(180deg,var(--bg0),var(--bg1));
  color:var(--text);
  min-height:100vh;
}
.wrap{max-width:1550px;margin:auto;padding:26px}
h1{margin:0 0 6px;font-size:34px}
p{margin:0 0 16px;color:var(--muted)}
.card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:20px;
  padding:18px;
  backdrop-filter:blur(14px);
  box-shadow:0 30px 80px rgba(0,0,0,.35);
}
.grid{display:grid;grid-template-columns:1fr 520px;gap:18px;align-items:start}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
button{
  background:linear-gradient(135deg,#7c5cff,#5f4cff);
  border:none;color:#fff;
  padding:12px 16px;border-radius:12px;cursor:pointer;
  font-size:15px;
}
button.secondary{
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
}
button.small{font-size:12px;padding:8px 10px;border-radius:10px}
button:disabled{opacity:.45;cursor:not-allowed}
.badge{
  display:inline-flex;align-items:center;gap:8px;
  padding:6px 10px;border-radius:999px;
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  color:var(--muted);
  font-size:12px;
}
.kv{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}
.tile{
  background:rgba(0,0,0,.30);
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:10px;
  text-align:center;
}
.tile strong{font-size:18px}
.sub{color:var(--muted);font-size:12px;margin-top:6px}
.log{
  background:rgba(0,0,0,.4);
  border-radius:14px;
  padding:12px;
  height:240px;
  overflow:auto;
  font-size:14px;
}
hr{border:none;border-top:1px solid var(--border);margin:14px 0}

.mapTitle{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.mapCanvas{
  width:100%;
  height:560px;
  border-radius:16px;
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  overflow:hidden;
  position:relative;
}
.mapCanvas canvas{width:100%;height:100%;display:block}
.hint{color:var(--muted);font-size:12px}
.tooltip{
  position:absolute;
  pointer-events:none;
  background:rgba(10,10,20,.92);
  border:1px solid rgba(255,255,255,.18);
  padding:8px 10px;
  border-radius:12px;
  font-size:12px;
  color:var(--text);
  display:none;
  max-width:320px;
}

.inventory{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
.slot{
  background:rgba(0,0,0,.35);
  border:1px dashed var(--border);
  border-radius:14px;
  padding:10px;
  min-height:82px;
  text-align:center;
  font-size:14px;
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  gap:8px;
}
.slot strong{display:block;font-size:12px;color:var(--muted)}
.slot .itemName{line-height:1.2}
.bagGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:10px}
.itemCard{
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  border-radius:14px;
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:102px;
}
.itemCard .meta{font-size:12px;color:var(--muted)}

.panel{
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  border-radius:14px;
  padding:12px;
}
.panel h3{margin:0 0 10px;font-size:16px}
.panel .muted{color:var(--muted);font-size:12px}

.overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.55);
  display:none;
  align-items:center;
  justify-content:center;
  padding:18px;
  z-index:50;
}
.modal{
  width:min(940px, 96vw);
  background:rgba(15,18,40,.92);
  border:1px solid var(--border);
  border-radius:18px;
  padding:16px;
  box-shadow:0 40px 120px rgba(0,0,0,.55);
}
.modal .top{display:flex;justify-content:space-between;align-items:center;gap:10px}
.modal h3{margin:0}
.modal p{margin:6px 0 0;color:var(--muted)}
kbd{
  font-family:ui-monospace,SFMono-Regular,Menlo,monospace;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.15);
  padding:2px 6px;
  border-radius:6px;
  color:var(--text);
  font-size:12px;
}
select, input[type="text"]{
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.18);
  color:var(--text);
  padding:10px 12px;
  border-radius:12px;
  outline:none;
}
label{color:var(--muted);font-size:12px}
.formGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
@media (max-width:1100px){
  .grid{grid-template-columns:1fr}
  .formGrid{grid-template-columns:1fr}
}
.statGrid{display:grid;grid-template-columns:repeat(6,1fr);gap:10px;margin-top:10px}
.statCell{
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.14);
  border-radius:14px;
  padding:10px;
  text-align:center;
}
.statCell .k{color:var(--muted);font-size:12px}
.statCell .v{font-size:20px;font-weight:700;margin-top:4px}
.statCell .m{color:var(--muted);font-size:12px;margin-top:4px}
.pill{
  display:inline-flex;gap:8px;align-items:center;
  padding:6px 10px;border-radius:999px;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.14);
  color:var(--muted);font-size:12px
}
</style>
</head>

<body>
<div class="wrap">
  <h1>üó∫Ô∏èüé≤ Apex Dice RPG ‚Äî Kingdoms</h1>
  <p>Massive world map with terrain regions, a capital kingdom, bridges, curved routes, persistent dungeons, and full character creation (race/sex/class + dice-rolled stats that affect outcomes).</p>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="mapTitle">
        <div class="row">
          <span class="badge" id="modeBadge">Mode: Exploring</span>
          <span class="badge" id="locBadge">Location: ‚Äî</span>
          <span class="badge" id="clockBadge">Day 1 ‚Ä¢ 08:00</span>
          <span class="badge" id="timeBadge">Travel uses time</span>
        </div>
        <div class="row">
          <button class="secondary" id="areaLootBtn">Area Loot</button>
          <button class="secondary" id="searchBtn">Search / Explore</button>
          <button class="secondary" id="sleepBtn">Sleep</button>
          <button class="secondary" id="eatBtn">Eat (Ration)</button>
          <button class="secondary" id="questBoardBtn">Quest Board</button>
          <button class="secondary" id="charBtn">Character</button>
        </div>
        <div class="hint">
          World: click connected locations ‚Ä¢ zoom wheel ‚Ä¢ drag to pan ‚Ä¢ hover tooltips ‚Ä¢ Dungeon: move with <kbd>WASD</kbd>/<kbd>‚Üë‚Üì‚Üê‚Üí</kbd>
        </div>
      </div>

      <div class="mapCanvas" id="mapWrap">
        <canvas id="map"></canvas>
        <div class="tooltip" id="tooltip"></div>
      </div>

      <div class="row" id="combatRow" style="display:none;margin-top:10px">
        <button id="attackBtn">Attack (d20)</button>
        <button class="secondary" id="fleeBtn">Flee</button>
      </div>
      <div id="enemyPanel" style="display:none;margin-top:10px">
        <span class="badge">Enemy: <b id="enemyName"></b> ‚Ä¢ HP <b id="enemyHp"></b> ‚Ä¢ AC <b id="enemyAC"></b></span>
      </div>

      <hr>

      <div class="panel" id="interactPanel">
        <h3>Interact</h3>
        <div class="muted" id="interactHint">World: click a connected location to travel. Cities: pick an establishment. Dungeons: stand on something to interact.</div>
        <div class="row" id="interactButtons" style="margin-top:10px"></div>
      </div>

      <hr>

      <h3 style="margin:0 0 8px">Log</h3>
      <div class="log" id="log"></div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <h2 style="margin:0">Player</h2>

      <div class="kv">
        <div class="tile">‚ù§Ô∏è HP<br><strong id="hp">20</strong><div class="sub">Max <span id="hpMax">20</span></div></div>
        <div class="tile">‚öîÔ∏è ATK<br><strong id="atk">2</strong><div class="sub">Base + Mods + Gear</div></div>
        <div class="tile">üõ°Ô∏è DEF<br><strong id="def">1</strong><div class="sub">AC bonus</div></div>
        <div class="tile">‚ö° Energy<br><strong id="energy">10</strong><div class="sub">Max <span id="energyMax">10</span></div></div>
      </div>

      <div class="kv" style="margin-top:10px">
        <div class="tile" style="grid-column:span 2">üçó Hunger<br>
          <strong id="hunger">10</strong>
          <div class="sub">0 = starving (HP drain when time passes)</div>
        </div>
        <div class="tile" style="grid-column:span 2">‚≠ê Level / XP<br>
          <strong><span id="level">1</span> ‚Ä¢ <span id="xp">0</span>xp</strong>
          <div class="sub">Next: <span id="xpNext">60</span>xp</div>
        </div>
      </div>

      <div class="kv" style="margin-top:10px">
        <div class="tile" style="grid-column:span 2">üîë Keys<br><strong id="keys">0</strong><div class="sub">Used on locked doors/chests</div></div>
        <div class="tile" style="grid-column:span 2">ü™ô Gold<br><strong id="gold">0</strong><div class="sub">Spend at towns/ports</div></div>
      </div>

      <div class="kv" style="margin-top:10px">
        <div class="tile" style="grid-column:span 4">
          <div class="row" style="justify-content:space-between">
            <span class="pill">üßë <b id="charName">Adventurer</b></span>
            <span class="pill">üß¨ <span id="charRace">Human</span> ‚Ä¢ <span id="charSex">‚Äî</span></span>
            <span class="pill">üßô <span id="charClass">Fighter</span></span>
          </div>
          <div class="sub" id="charModsLine" style="margin-top:10px">STR/DEX/CON/INT/WIS/CHA mods apply to combat & outcomes.</div>
        </div>
      </div>

      <h3 style="margin:18px 0 10px">Equipment</h3>
      <div class="inventory">
        <div class="slot" id="weaponSlot"></div>
        <div class="slot" id="armorSlot"></div>
        <div class="slot" id="accessorySlot"></div>
        <div class="slot">
          <strong>Consumables</strong>
          <div class="itemName">Rations: <b id="rationCount">0</b></div>
          <div class="row" style="justify-content:center">
            <button class="small secondary" id="buyFoodBtn">Buy Ration (5g)</button>
            <button class="small secondary" id="buyTorchBtn">Buy Torch (4g)</button>
          </div>
          <div class="sub">Torches increase dungeon reveal radius.</div>
        </div>
      </div>

      <h3 style="margin:18px 0 10px">Backpack</h3>
      <div class="bagGrid" id="bag"></div>

      <hr>
      <div class="row">
        <button class="secondary" id="resetBtn">Reset Save</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="overlay" id="overlay">
  <div class="modal">
    <div class="top">
      <h3 id="modalTitle">Notice</h3>
      <button class="secondary small" id="closeModal">Close</button>
    </div>
    <p id="modalBody"></p>
  </div>
</div>

<script>
/* ============================================================
   SAVE + STATE
============================================================ */
const SAVE_KEY = "apexDiceRpg_kingdoms_v1";

function defaultState(){
  return {
    // character
    characterCreated: false,
    name: "Adventurer",
    race: "Human",
    sex: "Unspecified",
    class: "Fighter",
    stats: {STR:10,DEX:10,CON:10,INT:10,WIS:10,CHA:10},
    rerollsLeft: 3,

    level: 1,
    xp: 0,

    hp: 20, hpMax: 20,
    energy: 10, energyMax: 10,
    hunger: 10, hungerMax: 10,

    gold: 18,
    keys: 0,
    torches: 0,

    weapon: null,
    armor: null,
    accessory: null,
    bag: [{type:"consumable", name:"Ration", kind:"food", qty:2}],

    mode: "world",          // world | dungeon | combat
    currentNode: "capital_aurelia",
    lastSafeNode: "capital_aurelia",

    // time
    day: 1,
    minutes: 8*60,
    energyDrainPerDayMin: 1,
    energyDrainPerDayMax: 2,
    energyDrainToday: 1,

    // per-visit loot limiting
    visitCounter: 1,
    nodeVisitStamp: {},
    nodeLootStamp: {},

    // persistent dungeons keyed by nodeId
    dungeons: {},
    dungeonId: null,

    // combat
    enemy: null,
    enemyMeta: null,
    pendingArrival: null,

    // quests
    quests: {},
    activeQuestId: null,

    log: []
  };
}

let state = JSON.parse(localStorage.getItem(SAVE_KEY) || "null") || defaultState();

/* ============================================================
   DOM helpers
============================================================ */
const $ = id => document.getElementById(id);
const mapCanvas = $("map");
const ctx = mapCanvas.getContext("2d");
const tooltip = $("tooltip");
const mapWrap = $("mapWrap");

function save(){ localStorage.setItem(SAVE_KEY, JSON.stringify(state)); }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function roll(s){ return Math.floor(Math.random()*s)+1; }
function fmtTime(mins){
  mins = ((mins%1440)+1440)%1440;
  const h = Math.floor(mins/60);
  const m = mins%60;
  return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}`;
}
function pushLog(msg){
  state.log.push(msg);
  if(state.log.length>500) state.log = state.log.slice(-500);
}
function openModal(title, html){
  $("modalTitle").textContent=title;
  $("modalBody").innerHTML=html;
  $("overlay").style.display="flex";
}
function closeModal(){ $("overlay").style.display="none"; }
$("closeModal").addEventListener("click", closeModal);
$("overlay").addEventListener("click",(e)=>{ if(e.target.id==="overlay") closeModal(); });

/* ============================================================
   CHARACTER: races/classes/stats
============================================================ */
const RACES = {
  "Human":   {mods:{}, desc:"Versatile and adaptable."},
  "Elf":     {mods:{DEX:+2, INT:+1}, desc:"Quick, precise, and clever."},
  "Dwarf":   {mods:{CON:+2, STR:+1}, desc:"Sturdy and resilient."},
  "Orc":     {mods:{STR:+2, CON:+1, CHA:-1}, desc:"Brutal power, rough edges."},
  "Halfling":{mods:{DEX:+2, CHA:+1, STR:-1}, desc:"Lightfoot and charming."}
};

const CLASSES = {
  "Fighter": {hpBase:12, primary:"STR", desc:"Frontline warrior. Strong melee focus."},
  "Rogue":   {hpBase:9,  primary:"DEX", desc:"Fast and evasive. Crits and finesse."},
  "Mage":    {hpBase:7,  primary:"INT", desc:"Spellcraft. Big hits, low durability."},
  "Cleric":  {hpBase:10, primary:"WIS", desc:"Support and survivability. Reliable."}
};

function statMod(v){ return Math.floor((v-10)/2); }
function getEffectiveStats(){
  const base = {...state.stats};
  const mods = (RACES[state.race]?.mods)||{};
  for(const k of Object.keys(mods)){
    base[k] = clamp((base[k]||10) + mods[k], 3, 20);
  }
  return base;
}

function computeDerived(){
  const s = getEffectiveStats();
  const cls = CLASSES[state.class] || CLASSES["Fighter"];
  const conM = statMod(s.CON);
  const hpMax = clamp(cls.hpBase + conM*state.level + 8, 12, 60 + state.level*8);

  // base energy scales slightly with WIS
  const wisM = statMod(s.WIS);
  const energyMax = clamp(10 + Math.max(0,wisM), 8, 16);

  // hunger max scales slightly with CON
  const hungerMax = clamp(10 + Math.max(0,conM), 8, 16);

  state.hpMax = hpMax;
  state.energyMax = energyMax;
  state.hungerMax = hungerMax;
  state.hp = clamp(state.hp, 0, state.hpMax);
  state.energy = clamp(state.energy, 0, state.energyMax);
  state.hunger = clamp(state.hunger, 0, state.hungerMax);
}
function xpToNext(level){ return 60 + (level-1)*35; }
function gainXP(x){
  state.xp += x;
  let leveled=false;
  while(state.xp >= xpToNext(state.level)){
    state.xp -= xpToNext(state.level);
    state.level += 1;
    leveled=true;
    computeDerived();
    state.hp = state.hpMax;
    pushLog(`<span style="color:var(--good)">‚≠ê Level up! You are now level <b>${state.level}</b>. HP restored.</span>`);
  }
  if(leveled) pushLog(`üìà Your stats now influence outcomes even more.`);
}

/* ============================================================
   INVENTORY / GEAR
============================================================ */
function getAtk(){
  const s = getEffectiveStats();
  const cls = CLASSES[state.class] || CLASSES["Fighter"];
  const primary = cls.primary;
  const mod = statMod(s[primary]||10);

  const weaponAtk = (state.weapon?.atk||0);
  const accAtk = (state.accessory?.atk||0);

  // class flavor
  const classBonus = (state.class==="Rogue") ? 1 : 0;

  return 1 + mod + classBonus + weaponAtk + accAtk + Math.floor((state.level-1)/2);
}
function getDef(){
  const s = getEffectiveStats();
  const dexM = statMod(s.DEX);
  const armorDef = (state.armor?.def||0);
  const accDef = (state.accessory?.def||0);
  // DEF shown is "AC bonus" which becomes 10 + DEF
  return dexM + armorDef + accDef + Math.floor((state.level-1)/3);
}
function playerAC(){ return 10 + getDef(); }

function fmtItem(item){
  if(!item) return "None";
  const parts=[];
  if(item.atk) parts.push(`+${item.atk} ATK`);
  if(item.def) parts.push(`+${item.def} DEF`);
  if(item.tag) parts.push(item.tag.toUpperCase());
  return parts.length ? `${item.name} (${parts.join(", ")})` : item.name;
}

function addToBag(item){
  if(item.type==="consumable"){
    const found = state.bag.find(x=>x.type==="consumable" && x.kind===item.kind && x.name===item.name);
    if(found){ found.qty += item.qty||1; return; }
  }
  state.bag.push(item);
}
function countItem(kind){
  return state.bag.filter(x=>x.type==="consumable" && x.kind===kind).reduce((s,x)=>s+(x.qty||1),0);
}
function consumeItem(kind, qty=1){
  for(const item of state.bag){
    if(item.type==="consumable" && item.kind===kind){
      const take = Math.min(qty, item.qty||1);
      item.qty = (item.qty||1) - take;
      qty -= take;
      if(item.qty<=0) item._remove = true;
      if(qty<=0) break;
    }
  }
  state.bag = state.bag.filter(x=>!x._remove);
  return qty===0;
}

function randomGear(rng=Math.random){
  const tier = (rng()<0.10) ? 2 : (rng()<0.40 ? 1 : 0);
  const t = [
    {type:"weapon", name:"Sword", atk:2},
    {type:"weapon", name:"Dagger", atk:1},
    {type:"weapon", name:"Warhammer", atk:3},
    {type:"weapon", name:"Bow", atk:2, tag:"ranged"},
    {type:"armor",  name:"Leather Armor", def:2},
    {type:"armor",  name:"Chain Shirt", def:3},
    {type:"armor",  name:"Scale Mail", def:4},
    {type:"accessory", name:"Ring of Luck", atk:1},
    {type:"accessory", name:"Amulet of Guarding", def:1},
    {type:"accessory", name:"Charm of Focus", atk:1, def:1},
  ];
  const base = t[Math.floor(rng()*t.length)];
  if(tier===0) return {...base};
  if(tier===1) return {...base, name: "Fine " + base.name, atk:(base.atk||0)+1, def:(base.def||0)+1};
  return {...base, name: "Mythic " + base.name, atk:(base.atk||0)+2, def:(base.def||0)+2};
}

function equipFromBag(index){
  const item = state.bag[index];
  if(!item || item.type==="consumable" || item.type==="quest") return;

  state.bag.splice(index,1);
  if(item.type==="weapon"){ if(state.weapon) state.bag.push(state.weapon); state.weapon=item; pushLog(`üß© Equipped Weapon: <b>${fmtItem(item)}</b>`); }
  if(item.type==="armor"){ if(state.armor) state.bag.push(state.armor); state.armor=item; pushLog(`üß© Equipped Armor: <b>${fmtItem(item)}</b>`); }
  if(item.type==="accessory"){ if(state.accessory) state.bag.push(state.accessory); state.accessory=item; pushLog(`üß© Equipped Accessory: <b>${fmtItem(item)}</b>`); }
  render();
}
function unequip(slot){
  if(slot==="weapon" && state.weapon){ state.bag.push(state.weapon); pushLog(`üì¶ Unequipped Weapon: <b>${fmtItem(state.weapon)}</b>`); state.weapon=null; }
  if(slot==="armor" && state.armor){ state.bag.push(state.armor); pushLog(`üì¶ Unequipped Armor: <b>${fmtItem(state.armor)}</b>`); state.armor=null; }
  if(slot==="accessory" && state.accessory){ state.bag.push(state.accessory); pushLog(`üì¶ Unequipped Accessory: <b>${fmtItem(state.accessory)}</b>`); state.accessory=null; }
  render();
}

/* ============================================================
   TIME + DAY TICK
============================================================ */
function startNewDay(){
  const drain = (state.energyDrainPerDayMin + Math.floor(Math.random()*(state.energyDrainPerDayMax - state.energyDrainPerDayMin + 1)));
  state.energyDrainToday = drain;
  state.energy = clamp(state.energy - drain, 0, state.energyMax);

  state.hunger = clamp(state.hunger - 2, 0, state.hungerMax);
  if(state.hunger===0){
    state.hp = clamp(state.hp - 2, 0, state.hpMax);
    pushLog(`<span style="color:var(--warn)">üçó You wake starving and lose 2 HP.</span>`);
  }
  pushLog(`üåÖ Day ${state.day} begins. Energy drains today: -${drain}.`);
}

function passTime(minutes, reason){
  if(minutes<=0) return;

  state.minutes += minutes;

  while(state.minutes >= 1440){
    state.minutes -= 1440;
    state.day += 1;
    startNewDay();
  }

  // hunger effect: 1 hunger per 4 hours
  const hungerLoss = Math.floor(minutes / 240);
  if(hungerLoss>0){
    state.hunger = clamp(state.hunger - hungerLoss, 0, state.hungerMax);
    if(state.hunger===0){
      const hpLoss = Math.max(1, hungerLoss);
      state.hp = clamp(state.hp - hpLoss, 0, state.hpMax);
      pushLog(`<span style="color:var(--warn)">üçó Starving while time passes: -${hpLoss} HP.</span>`);
    }
  }

  if(reason) pushLog(`‚è≥ Time passes (${Math.round(minutes)} min): ${reason}.`);
}

/* ============================================================
   WORLD GENERATION (HUGE MAP, terrain, curved routes, bridges)
   - "20x bigger": we run a 3200x2200 world coordinate system
============================================================ */
const WORLD_W = 3200;
const WORLD_H = 2200;
const WORLD_SEED = "apex-kingdoms-001";

/* -------- deterministic RNG + noise ---------- */
function makeRNG(seedStr){
  let h = 2166136261;
  for(let i=0;i<seedStr.length;i++){ h ^= seedStr.charCodeAt(i); h = Math.imul(h, 16777619); }
  let s = h >>> 0;
  return function(){
    s ^= s << 13; s >>>= 0;
    s ^= s >> 17; s >>>= 0;
    s ^= s << 5;  s >>>= 0;
    return (s >>> 0) / 4294967296;
  };
}
const rngWorld = makeRNG(WORLD_SEED);

function hash2(x,y){
  // quick hash
  let n = x*374761393 + y*668265263;
  n = (n ^ (n >> 13)) * 1274126177;
  return ((n ^ (n >> 16)) >>> 0) / 4294967296;
}
function smoothstep(t){ return t*t*(3-2*t); }
function lerp(a,b,t){ return a + (b-a)*t; }

function valueNoise(x,y,scale){
  const fx = x/scale, fy=y/scale;
  const x0 = Math.floor(fx), y0=Math.floor(fy);
  const tx = fx-x0, ty=fy-y0;

  const v00 = hash2(x0,y0);
  const v10 = hash2(x0+1,y0);
  const v01 = hash2(x0,y0+1);
  const v11 = hash2(x0+1,y0+1);

  const sx = smoothstep(tx), sy=smoothstep(ty);
  const ix0 = lerp(v00,v10,sx);
  const ix1 = lerp(v01,v11,sx);
  return lerp(ix0,ix1,sy);
}
function fbm(x,y){
  let f=0, amp=0.55, scale=300;
  for(let i=0;i<5;i++){
    f += amp*valueNoise(x+123.4*i, y+987.6*i, scale);
    amp *= 0.55;
    scale *= 0.55;
  }
  return f; // ~0..1
}

/* -------- landmask with coastline noise ---------- */
function landMask(x,y){
  // base ellipse island
  const cx = WORLD_W*0.47, cy=WORLD_H*0.52;
  const nx = (x-cx)/(WORLD_W*0.52);
  const ny = (y-cy)/(WORLD_H*0.48);
  const d = Math.sqrt(nx*nx + ny*ny);

  // coastline noise pushes boundary
  const n = fbm(x*1.0, y*1.0);
  const coast = 0.88 + (n-0.5)*0.22; // boundary varies
  const m = 1 - clamp((d - coast)/0.12, 0, 1);
  return m; // 0 sea, 1 deep land
}

function elevation(x,y){
  const base = fbm(x*0.9, y*0.9);
  const lat = 1 - Math.abs((y/WORLD_H)-0.55); // mid lat tends higher life
  let e = base*0.72 + lat*0.28;
  e = clamp(e,0,1);
  // mountains ridge
  const ridge = Math.abs((fbm(x*1.7+400, y*1.7+200)-0.5))*2;
  e = clamp(e + ridge*0.18, 0, 1);
  return e;
}

function temperature(x,y){
  // colder north/south edges; warmer center
  const lat = y/WORLD_H; // 0..1
  const t = 1 - Math.abs(lat-0.55)*1.4;
  const n = fbm(x+222, y+444);
  return clamp(t*0.75 + n*0.25, 0, 1);
}

function moisture(x,y){
  const n = fbm(x+777, y+333);
  // coastal tends wet
  const coast = landMask(x,y);
  return clamp(n*0.75 + (1-coast)*0.15 + 0.10, 0, 1);
}

function terrainType(x,y){
  const m = landMask(x,y);
  if(m < 0.12) return "ocean";
  if(m < 0.20) return "coast";

  const temp = temperature(x,y);
  const moist = moisture(x,y);
  const elev = elevation(x,y);

  if(elev > 0.78) return "mountains";

  // arctic / tundra / desert / forest / grasslands / woody
  if(temp < 0.25) return (moist>0.55) ? "arctic" : "tundra";
  if(temp > 0.72 && moist < 0.28) return "desert";
  if(moist > 0.66) return "forest";
  if(moist > 0.52) return "woody";
  return "grasslands";
}

/* -------- pre-render terrain to an offscreen map ---------- */
let terrainImg = null;
let terrainIcons = []; // {x,y,kind}
let rivers = [];       // array of polyline points
let bridges = [];      // {x,y}

function buildTerrain(){
  const tw=820, th=560; // low-res texture (fast)
  const off = document.createElement("canvas");
  off.width = tw; off.height=th;
  const tctx = off.getContext("2d");
  const img = tctx.createImageData(tw, th);
  const data = img.data;

  terrainIcons = [];
  rivers = [];
  bridges = [];

  // simple major river polyline (only on land)
  function genRiver(seedX, seedY){
    let pts = [];
    let x = seedX, y=seedY;
    let steps=0;
    while(steps<180){
      pts.push({x,y});
      // flow roughly to sea (toward nearest edge) + noise
      const toEast = (WORLD_W-x);
      const toWest = x;
      const toNorth = y;
      const toSouth = (WORLD_H-y);
      // pick direction toward closest border (sea likely there)
      let dx=0, dy=0;
      const min = Math.min(toEast,toWest,toNorth,toSouth);
      if(min===toEast) dx=+1;
      else if(min===toWest) dx=-1;
      else if(min===toNorth) dy=-1;
      else dy=+1;

      // add meander
      const ang = (fbm(x*1.2+90, y*1.2+22)-0.5)*Math.PI*1.2;
      const mx = Math.cos(ang), my=Math.sin(ang);

      x += (dx*0.8 + mx*0.9) * 18;
      y += (dy*0.8 + my*0.9) * 18;

      if(x<0||y<0||x>WORLD_W||y>WORLD_H) break;
      if(landMask(x,y)<0.18) break; // reached coast
      steps++;
    }
    if(pts.length>40) rivers.push(pts);
  }
  // seed rivers in mountains
  for(let i=0;i<5;i++){
    // find mountain-ish point
    let tries=0;
    while(tries++<2000){
      const x = rngWorld()*WORLD_W;
      const y = rngWorld()*WORLD_H;
      if(landMask(x,y)>0.45 && elevation(x,y)>0.78){
        genRiver(x,y);
        break;
      }
    }
  }

  // paint
  for(let j=0;j<th;j++){
    for(let i=0;i<tw;i++){
      const x = (i/(tw-1))*WORLD_W;
      const y = (j/(th-1))*WORLD_H;

      const t = terrainType(x,y);
      const m = landMask(x,y);
      const elev = elevation(x,y);
      const temp = temperature(x,y);

      // base colors
      let r=8,g=18,b=52; // sea base
      if(t==="ocean"){
        const deep = 0.45 + fbm(x*0.7,y*0.7)*0.55;
        r = 10 + deep*10; g = 30 + deep*40; b = 80 + deep*95;
      } else if(t==="coast"){
        r = 20 + m*30; g = 60 + m*45; b = 110 + m*55;
      } else {
        // land shading by elevation and moisture
        const moist = moisture(x,y);
        const shade = 0.60 + elev*0.35;

        if(t==="grasslands"){ r=40; g=115; b=70; }
        if(t==="woody"){ r=32; g=92; b=60; }
        if(t==="forest"){ r=26; g=74; b=52; }
        if(t==="desert"){ r=160; g=130; b=70; }
        if(t==="tundra"){ r=95; g=120; b=120; }
        if(t==="arctic"){ r=180; g=200; b=210; }
        if(t==="mountains"){ r=95; g=100; b=110; }

        // subtle terrain shading
        r = r*shade; g=g*shade; b=b*shade;

        // cooler tint toward arctic
        if(temp<0.33){
          const cool = (0.33-temp)/0.33;
          r = lerp(r, 170, cool*0.35);
          g = lerp(g, 200, cool*0.35);
          b = lerp(b, 220, cool*0.35);
        }
      }

      // coastline edge highlight
      if(m>0.12 && m<0.24){
        r = lerp(r, 210, 0.05);
        g = lerp(g, 230, 0.05);
        b = lerp(b, 240, 0.05);
      }

      const idx = (j*tw+i)*4;
      data[idx]=Math.round(clamp(r,0,255));
      data[idx+1]=Math.round(clamp(g,0,255));
      data[idx+2]=Math.round(clamp(b,0,255));
      data[idx+3]=255;
    }
  }

  // draw rivers onto the texture
  tctx.putImageData(img,0,0);
  tctx.save();
  tctx.globalAlpha=0.78;
  tctx.strokeStyle="rgba(147,197,253,.85)";
  tctx.lineWidth=2.2;
  for(const river of rivers){
    tctx.beginPath();
    for(let i=0;i<river.length;i++){
      const px = (river[i].x/WORLD_W)*tw;
      const py = (river[i].y/WORLD_H)*th;
      if(i===0) tctx.moveTo(px,py); else tctx.lineTo(px,py);
    }
    tctx.stroke();
  }
  tctx.restore();

  // sample icons
  // mountains + forests icons sprinkled (visual only)
  for(let k=0;k<900;k++){
    const x = rngWorld()*WORLD_W;
    const y = rngWorld()*WORLD_H;
    if(landMask(x,y)<0.25) continue;
    const t = terrainType(x,y);
    if(t==="mountains" && rngWorld()<0.20) terrainIcons.push({x,y,kind:"mountain"});
    if((t==="forest"||t==="woody") && rngWorld()<0.10) terrainIcons.push({x,y,kind:"tree"});
    if(t==="desert" && rngWorld()<0.06) terrainIcons.push({x,y,kind:"dune"});
    if((t==="tundra"||t==="arctic") && rngWorld()<0.05) terrainIcons.push({x,y,kind:"snow"});
  }

  terrainImg = off; // store offscreen canvas
}

/* ============================================================
   WORLD NODES + ROUTES (curved, no-crossing attempt)
============================================================ */
function isLand(x,y){ return landMask(x,y) >= 0.22; }
function pickLandPoint(){
  for(let t=0;t<6000;t++){
    const x = rngWorld()*WORLD_W;
    const y = rngWorld()*WORLD_H;
    if(isLand(x,y) && elevation(x,y)<0.83) return {x,y};
  }
  return {x:WORLD_W*0.5,y:WORLD_H*0.5};
}
function pickCoastPoint(){
  for(let t=0;t<9000;t++){
    const x = rngWorld()*WORLD_W;
    const y = rngWorld()*WORLD_H;
    const m = landMask(x,y);
    if(m>0.18 && m<0.28) return {x,y};
  }
  return {x:WORLD_W*0.7,y:WORLD_H*0.5};
}

function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function segmentsIntersect(a,b,c,d){
  function ccw(p1,p2,p3){ return (p3.y-p1.y)*(p2.x-p1.x) > (p2.y-p1.y)*(p3.x-p1.x); }
  return (ccw(a,c,d) !== ccw(b,c,d)) && (ccw(a,b,c) !== ccw(a,b,d));
}

function routeCurvaturePoints(A,B,kind){
  // roads hug land: push control points along a "coastward" gradient
  // sea routes: gentle arc
  const mid = {x:(A.x+B.x)/2, y:(A.y+B.y)/2};
  const dx = B.x-A.x, dy=B.y-A.y;
  const len = Math.hypot(dx,dy) || 1;
  const nx = -dy/len, ny=dx/len;

  const n1 = fbm(mid.x+123, mid.y+456)-0.5;
  const arc = (kind==="sea" ? 0.22 : 0.35) * len * n1;

  // "hug land": try to bias roads inward (higher landMask)
  let bias = 0;
  if(kind==="road" || kind==="bridge"){
    const left = landMask(mid.x+nx*90, mid.y+ny*90);
    const right= landMask(mid.x-nx*90, mid.y-ny*90);
    bias = (left-right) * 0.55 * len * 0.06; // choose side with higher landness
  }

  const c1 = {x: A.x + dx*0.33 + nx*(arc + bias), y: A.y + dy*0.33 + ny*(arc + bias)};
  const c2 = {x: A.x + dx*0.66 + nx*(arc*0.65 + bias*0.65), y: A.y + dy*0.66 + ny*(arc*0.65 + bias*0.65)};

  // add subtle wobble to reduce straight-line feel
  const wob = (kind==="sea"?0.05:0.08)*len;
  const wob2= (fbm(A.x+77,B.y+88)-0.5)*2;
  c1.x += nx*wob*wob2; c1.y += ny*wob*wob2;
  c2.x -= nx*wob*wob2; c2.y -= ny*wob*wob2;

  return {c1,c2};
}

const world = { nodes: [], edges: [] };
let nodeById = {};

function buildWorld(){
  // base structure: Capital + Kingdom cities + ports + many points
  world.nodes = [];
  world.edges = [];

  // Capital kingdom in lush heartland near center-ish
  const cap = {id:"capital_aurelia", name:"Aurelia (Capital)", type:"capital", x:WORLD_W*0.50, y:WORLD_H*0.52, kingdom:true};
  world.nodes.push(cap);

  // big kingdom ring cities
  const ring = [
    {id:"city_embergate", name:"Embergate", type:"city"},
    {id:"city_silverford", name:"Silverford", type:"city"},
    {id:"city_westcliff", name:"Westcliff", type:"city"},
    {id:"city_mornspire", name:"Mornspire", type:"city"},
    {id:"city_greenhollow", name:"Greenhollow", type:"city"},
    {id:"city_southwatch", name:"Southwatch", type:"city"},
  ];
  for(let i=0;i<ring.length;i++){
    const ang = (i/ring.length)*Math.PI*2;
    const r = 420 + rngWorld()*120;
    const p = {x: cap.x + Math.cos(ang)*r, y: cap.y + Math.sin(ang)*r};
    // snap to land
    let tries=0;
    while(tries++<120 && !isLand(p.x,p.y)){
      p.x += (rngWorld()-0.5)*60; p.y += (rngWorld()-0.5)*60;
    }
    world.nodes.push({...ring[i], x: clamp(p.x,120,WORLD_W-120), y: clamp(p.y,120,WORLD_H-120)});
  }

  // Ports along coast
  const ports = [];
  const portNames = ["Grandport","Seabreak","Dawnwharf","Rimepier","Saltmere","Coralhaven","Blackwater Quay","Gullwatch"];
  for(let i=0;i<8;i++){
    const p = pickCoastPoint();
    ports.push({id:`port_${i}`, name:portNames[i], type:"port", x:p.x, y:p.y});
  }
  world.nodes.push(...ports);

  // Many towns/camps
  const townNames = [
    "Stonehaven","Pinewatch","Redfen","Briarfield","Hawthorn","Ravenmoor","Oakmere","Sunvale","Ironridge","Mistwood",
    "Frostbarrow","Sandspire","Wyrmrest","Oldbridge","Marrowwick","Kingsfall","Westmere","Glimmerholt","Ashenford","Larkstone"
  ];
  const campNames = ["Wayfarer Camp","Hunter‚Äôs Rest","Pilgrim Fire","Ridge Camp","Bogwatch Camp","Pinelean Camp","Silt Camp","Northline Camp"];
  let ti=0, ci=0;

  for(let i=0;i<20;i++){
    const p = pickLandPoint();
    world.nodes.push({id:`town_${i}`, name:townNames[ti++%townNames.length], type:"town", x:p.x, y:p.y});
  }
  for(let i=0;i<12;i++){
    const p = pickLandPoint();
    world.nodes.push({id:`camp_${i}`, name:campNames[ci++%campNames.length], type:"camp", x:p.x, y:p.y});
  }

  // Many caves/forests (dungeons)
  const caveNames = ["Mournroot Cave","Saltwind Grotto","Hollowfang Den","Cinderjaw Caverns","Shatterstone Depths","Moonshale Cave","Duskveil Tunnels","Ironmouth Pit"];
  const forestNames = ["Gloamwood","Briarwild","Mossreach","Wolfsong Thicket","Crownleaf Grove","Deepbark","Rimewood","Duskmere Glade","Sable Forest","Hollow Pines"];
  for(let i=0;i<10;i++){
    const p = pickLandPoint();
    world.nodes.push({id:`cave_${i}`, name:caveNames[i%caveNames.length], type:"cave", x:p.x, y:p.y, dungeonKind:"cave"});
  }
  for(let i=0;i<12;i++){
    const p = pickLandPoint();
    world.nodes.push({id:`forest_${i}`, name:forestNames[i%forestNames.length], type:"forest", x:p.x, y:p.y, dungeonKind:"forest"});
  }

  // Build lookup
  nodeById = Object.fromEntries(world.nodes.map(n=>[n.id,n]));

  // Build roads on land: MST-ish + extra edges; reject intersections to reduce crossings
  const landNodes = world.nodes.filter(n => n.type!=="port");
  const seaNodes = world.nodes.filter(n => n.type==="port");

  // helper: connect with intersection avoidance
  function addEdge(a,b,kind,extra={}){
    if(a===b) return false;
    // prevent duplicates
    if(world.edges.some(e => (e.a===a && e.b===b) || (e.a===b && e.b===a))) return false;

    const A=nodeById[a], B=nodeById[b];
    const newSeg = {p1:{x:A.x,y:A.y}, p2:{x:B.x,y:B.y}};

    // avoid crossing with same or different kind (especially roads vs sea)
    for(const e of world.edges){
      const E1=nodeById[e.a], E2=nodeById[e.b];
      // allow share endpoints
      if([a,b].includes(e.a) || [a,b].includes(e.b)) continue;
      // disallow crossing always (keeps routes cleaner)
      if(segmentsIntersect(newSeg.p1,newSeg.p2,{x:E1.x,y:E1.y},{x:E2.x,y:E2.y})) return false;
    }

    const curve = routeCurvaturePoints(A,B,kind);
    world.edges.push({a,b,kind, ...extra, c1:curve.c1, c2:curve.c2});
    return true;
  }

  // MST-ish: connect each node to nearest already-connected to ensure connected graph
  const connected = new Set([cap.id]);
  const remaining = new Set(landNodes.map(n=>n.id).filter(id=>id!==cap.id));

  while(remaining.size){
    let best=null;
    for(const id of remaining){
      const N=nodeById[id];
      // find nearest connected
      let bestC=null, bestD=1e18;
      for(const cid of connected){
        const C=nodeById[cid];
        const d=dist(N,C);
        if(d<bestD){ bestD=d; bestC=cid; }
      }
      if(!best || bestD<best.d) best={id, c:bestC, d:bestD};
    }
    if(best){
      addEdge(best.id, best.c, "road");
      connected.add(best.id);
      remaining.delete(best.id);
    } else break;
  }

  // add extra roads: kNN style
  const landIds = landNodes.map(n=>n.id);
  for(const id of landIds){
    const A=nodeById[id];
    // pick nearest 3
    const near = landIds
      .filter(o=>o!==id)
      .map(o=>({o, d:dist(A,nodeById[o])}))
      .sort((x,y)=>x.d-y.d)
      .slice(0,4);
    for(const n of near){
      if(n.d<520) addEdge(id, n.o, "road");
    }
  }

  // connect ports to nearest land towns/cities + a few sea lanes between ports
  for(const p of seaNodes){
    // nearest 3 land nodes (prefer cities/towns)
    const candidates = world.nodes.filter(n=>n.type==="city"||n.type==="town"||n.type==="capital");
    const near = candidates
      .map(n=>({id:n.id, d:dist(p,n)}))
      .sort((a,b)=>a.d-b.d)
      .slice(0,2);
    for(const n of near){
      // docks/roads that hug land: we still treat as road if endpoint on land and short distance
      addEdge(p.id, n.id, "road", {dock:true});
    }
  }
  // sea lanes between ports
  for(let i=0;i<seaNodes.length;i++){
    const P=seaNodes[i];
    const near = seaNodes
      .filter((_,j)=>j!==i)
      .map(n=>({id:n.id,d:dist(P,n)}))
      .sort((a,b)=>a.d-b.d)
      .slice(0,2);
    for(const n of near){
      const fare = clamp(Math.round(n.d/120), 6, 18);
      addEdge(P.id, n.id, "sea", {fare});
    }
  }

  // mark bridges where roads cross rivers
  function sampleBezier(e,t){
    const A=nodeById[e.a], B=nodeById[e.b];
    const c1=e.c1, c2=e.c2;
    const u=1-t;
    const x = u*u*u*A.x + 3*u*u*t*c1.x + 3*u*t*t*c2.x + t*t*t*B.x;
    const y = u*u*u*A.y + 3*u*u*t*c1.y + 3*u*t*t*c2.y + t*t*t*B.y;
    return {x,y};
  }
  function pointNearPolyline(p, poly, thresh){
    for(let i=1;i<poly.length;i++){
      const a=poly[i-1], b=poly[i];
      const d = pointToSegmentDistance(p,a,b);
      if(d<thresh) return {hit:true, i};
    }
    return {hit:false};
  }
  function pointToSegmentDistance(p,a,b){
    const vx=b.x-a.x, vy=b.y-a.y;
    const wx=p.x-a.x, wy=p.y-a.y;
    const c1 = vx*wx + vy*wy;
    if(c1<=0) return Math.hypot(p.x-a.x,p.y-a.y);
    const c2 = vx*vx + vy*vy;
    if(c2<=c1) return Math.hypot(p.x-b.x,p.y-b.y);
    const t = c1/c2;
    const px=a.x+t*vx, py=a.y+t*vy;
    return Math.hypot(p.x-px,p.y-py);
  }

  for(const e of world.edges){
    if(e.kind!=="road") continue;
    // sample along curve
    let bestBridge=null;
    for(let s=0;s<=20;s++){
      const t=s/20;
      const p = sampleBezier(e,t);
      // check each river
      for(const r of rivers){
        const hit = pointNearPolyline(p,r,10);
        if(hit.hit){
          bestBridge = p;
          break;
        }
      }
      if(bestBridge) break;
    }
    if(bestBridge){
      bridges.push(bestBridge);
      e.kind = "bridge"; // visually mark
    }
  }

  // ensure starting node exists
  if(!nodeById[state.currentNode]) state.currentNode = cap.id;
  if(!nodeById[state.lastSafeNode]) state.lastSafeNode = cap.id;
}

/* ============================================================
   ROUTING / NEIGHBORS
============================================================ */
function edgeBetween(a,b){
  return world.edges.find(e => (e.a===a && e.b===b) || (e.a===b && e.b===a));
}
function neighbors(id){
  return world.edges.filter(e=>e.a===id||e.b===id).map(e=>e.a===id?e.b:e.a);
}

/* ============================================================
   QUESTS (now scalable; a bunch across the world)
============================================================ */
const QUESTS = [
  {id:"q_crate_1", title:"Deliver Sealed Crate", from:"town_0", to:"port_0", item:{type:"quest",name:"Sealed Crate"}, reward:{gold:25, key:1, xp:30}, text:"A merchant needs a sealed crate delivered to the docks. No questions asked."},
  {id:"q_herbs_1", title:"Medicinal Herbs Run", from:"camp_0", to:"city_greenhollow", item:{type:"quest",name:"Herb Satchel"}, reward:{gold:18, key:0, xp:24}, text:"Bring a satchel of herbs to the healer in Greenhollow."},
  {id:"q_letter_1", title:"Captain‚Äôs Letter", from:"port_2", to:"capital_aurelia", item:{type:"quest",name:"Captain‚Äôs Letter"}, reward:{gold:22, key:0, xp:26}, text:"Carry a sealed letter to the capital‚Äôs steward."},
  {id:"q_tools_1", title:"Tools for Redfen Camp", from:"city_embergate", to:"camp_3", item:{type:"quest",name:"Tool Bundle"}, reward:{gold:16, key:1, xp:22}, text:"Deliver tools to the camp. They‚Äôll spare a key for your trouble."},
  {id:"q_tomes_1", title:"Return Lost Tomes", from:"city_mornspire", to:"city_silverford", item:{type:"quest",name:"Bundle of Tomes"}, reward:{gold:30, key:0, xp:38}, text:"Return rare tomes to Silverford‚Äôs library. Don‚Äôt get them wet."},
  {id:"q_guild_1", title:"Guild Contract Drop", from:"capital_aurelia", to:"city_westcliff", item:{type:"quest",name:"Guild Contract"}, reward:{gold:28, key:1, xp:35}, text:"Deliver an official guild contract for Westcliff‚Äôs chapter."},
];

function questBoardForNode(nodeId){
  return QUESTS.filter(q=>q.from===nodeId);
}
function questStatus(qid){ return state.quests[qid] || {accepted:false, completed:false}; }
function setQuestStatus(qid, patch){
  const cur = questStatus(qid);
  state.quests[qid] = {...cur, ...patch};
}
function activeQuest(){
  if(!state.activeQuestId) return null;
  return QUESTS.find(q=>q.id===state.activeQuestId) || null;
}
function hasQuestItem(name){ return state.bag.some(x=>x.type==="quest" && x.name===name); }
function removeQuestItem(name){
  const idx = state.bag.findIndex(x=>x.type==="quest" && x.name===name);
  if(idx>=0) state.bag.splice(idx,1);
}
function addQuestItem(item){ if(!hasQuestItem(item.name)) state.bag.push({...item}); }

function tryDeliverQuest(){
  const q = activeQuest();
  if(!q) return false;
  const st = questStatus(q.id);
  if(!st.accepted || st.completed) return false;

  if(state.currentNode===q.to && hasQuestItem(q.item.name)){
    removeQuestItem(q.item.name);
    state.gold += q.reward.gold||0;
    state.keys += q.reward.key||0;
    gainXP(q.reward.xp||0);
    setQuestStatus(q.id, {completed:true});
    pushLog(`<span style="color:var(--good)">üì¶ Quest complete: ${q.title}! +${q.reward.gold||0}g${q.reward.key?` +${q.reward.key} key`:""} +${q.reward.xp||0}xp.</span>`);
    state.activeQuestId = null;
    return true;
  }
  return false;
}

/* ============================================================
   PER-VISIT LOOT
============================================================ */
function enterNode(nodeId){
  state.currentNode = nodeId;
  state.visitCounter += 1;
  state.nodeVisitStamp[nodeId] = state.visitCounter;

  const n = nodeById[nodeId];
  if(n.type==="town"||n.type==="city"||n.type==="camp"||n.type==="port"||n.type==="capital") state.lastSafeNode=nodeId;

  tryDeliverQuest();

  // center view gently on new location (world only)
  if(state.mode==="world"){
    softCenterOnNode(nodeId);
  }

  render();
}
function areaLootAvailable(){
  const stamp = state.nodeVisitStamp[state.currentNode] || 0;
  const used  = state.nodeLootStamp[state.currentNode] || 0;
  return used !== stamp;
}

function outcomeCheck(statKey, dc){
  const s = getEffectiveStats();
  const mod = statMod(s[statKey]||10);
  const d20 = roll(20);
  return {d20, mod, total:d20+mod, pass:(d20+mod)>=dc};
}

function useAreaLoot(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't loot during combat."); render(); return; }
  if(!areaLootAvailable()){
    pushLog("üß∫ Area loot already used for this visit.");
    render(); return;
  }

  passTime(25, "Area loot");
  state.nodeLootStamp[state.currentNode] = state.nodeVisitStamp[state.currentNode];

  const n=nodeById[state.currentNode];
  const r=roll(100);

  // terrain influences loot
  const tt = terrainType(n.x,n.y);

  if(n.type==="capital"||n.type==="city"){
    if(r<=50){ const g=roll(10)+6; state.gold+=g; pushLog(`üß∫ You find <b>${g}</b> gold in the bustle.`); gainXP(6); }
    else if(r<=70){ addToBag({type:"consumable", name:"Ration", kind:"food", qty:1}); pushLog("üß∫ Found <b>1 Ration</b>."); }
    else { const item=randomGear(); state.bag.push(item); pushLog(`üß∫ Found gear: <b>${fmtItem(item)}</b>.`); }
  } else if(n.type==="town"||n.type==="port"){
    if(r<=55){ const g=roll(8)+3; state.gold+=g; pushLog(`üß∫ You find <b>${g}</b> gold.`); }
    else { addToBag({type:"consumable", name:"Ration", kind:"food", qty:1}); pushLog("üß∫ Found <b>1 Ration</b>."); }
  } else if(n.type==="camp"){
    if(r<=40){ addToBag({type:"consumable", name:"Ration", kind:"food", qty:1}); pushLog("üß∫ Camp supplies: <b>1 Ration</b>."); }
    else { const item=randomGear(); state.bag.push(item); pushLog(`üß∫ Found gear: <b>${fmtItem(item)}</b>.`); }
  } else {
    if(r<=40){ const g=roll(12)+4; state.gold+=g; pushLog(`üß∫ Found <b>${g}</b> gold.`); }
    else { const item=randomGear(); state.bag.push(item); pushLog(`üß∫ Found <b>${fmtItem(item)}</b>.`); }
  }

  // terrain perk
  if(tt==="desert" && roll(100)<=25){
    state.hunger = clamp(state.hunger-1,0,state.hungerMax);
    pushLog(`<span style="color:var(--warn)">üèúÔ∏è Heat drains you: -1 hunger.</span>`);
  }
  if((tt==="tundra"||tt==="arctic") && roll(100)<=22){
    state.hp = clamp(state.hp-1,0,state.hpMax);
    pushLog(`<span style="color:var(--warn)">‚ùÑÔ∏è Bitter cold bites: -1 HP.</span>`);
  }

  // small world encounter chance: influenced by CHA/WIS
  const chk = outcomeCheck("WIS", 12);
  if(roll(100)<= (chk.pass ? 8 : 14)){
    startCombat(makeEnemy("ambush"), {origin:"world"});
  }

  render();
}

/* ============================================================
   TRAVEL RULES (curved routes but time based on distance)
   - Sea fare required + sea risks
============================================================ */
function distanceNode(a,b){
  const A=nodeById[a], B=nodeById[b];
  return Math.hypot(A.x-B.x, A.y-B.y);
}
function travelTimeMinutes(from,to){
  const d = distanceNode(from,to);
  // scaled for huge world
  return clamp(Math.round(d * 0.18), 25, 260);
}
function canTravelTo(toId){
  if(state.mode!=="world") return false;
  return !!edgeBetween(state.currentNode,toId);
}

function travelTo(toId){
  if(state.mode!=="world") return;
  const e=edgeBetween(state.currentNode,toId);
  if(!e){ pushLog("üö´ No route."); render(); return; }

  // sea fare
  if(e.kind==="sea"){
    const fare=e.fare||0;
    if(state.gold<fare){
      pushLog(`‚õ¥Ô∏è Fare required: ${fare}g. You only have ${state.gold}g.`);
      render(); return;
    }
    state.gold -= fare;
    pushLog(`‚õ¥Ô∏è Paid fare <b>${fare}g</b> for sea travel.`);
  }

  const minutes = travelTimeMinutes(state.currentNode,toId);
  passTime(minutes, "Travel");

  // travel checks influenced by terrain
  const fromN=nodeById[state.currentNode];
  const toN=nodeById[toId];
  const tt = terrainType(toN.x,toN.y);

  if(e.kind==="sea"){
    if(roll(100)<=14){
      pushLog(`<span style="color:var(--warn)">üåä Rough waters! You fall into the sea.</span>`);
      const dmg = roll(4)+1;
      state.hp = clamp(state.hp - dmg, 0, state.hpMax);
      if(countItem("food")>0 && roll(100)<=30){
        consumeItem("food",1);
        pushLog(`<span style="color:var(--warn)">üçó You lose a ration to the waves.</span>`);
      }
      if(state.hp<=0){
        state.hp=1;
        pushLog(`<b style="color:var(--bad)">‚ò†Ô∏è You nearly drown and wash ashore at your last safe location.</b>`);
        enterNode(state.lastSafeNode);
        render(); return;
      }
    }
    if(roll(100)<=28){
      const type = (roll(100)<=55) ? "pirates" : "sea";
      startCombat(makeEnemy(type), {origin:"sea"});
      state.pendingArrival = toId;
      pushLog(`‚öì Combat triggered during sea travel to <b>${toN.name}</b>.`);
      render(); return;
    }
  } else {
    // overland hazards by terrain
    let chance = 16;
    if(tt==="forest"||tt==="woody") chance=20;
    if(tt==="desert") chance=14;
    if(tt==="tundra"||tt==="arctic") chance=18;
    if(tt==="mountains") chance=22;

    // WIS helps avoid
    const avoid = outcomeCheck("WIS", 13);
    chance = clamp(chance + (avoid.pass?-5:+0), 8, 28);

    if(roll(100)<=chance){
      startCombat(makeEnemy("road"), {origin:"road"});
      state.pendingArrival = toId;
      pushLog(`‚ö†Ô∏è Encounter on the route toward <b>${toN.name}</b>.`);
      render(); return;
    }
  }

  pushLog(`üß≠ Arrived at <b>${toN.name}</b>.`);
  enterNode(toId);
  render();
}

/* ============================================================
   DUNGEONS (Persistent) ‚Äî unchanged concept, expanded reveal via torches
============================================================ */
function randomGearFromRng(rng){ return randomGear(rng); }

function dungeonChestContents(rng){
  const contents = [];
  contents.push({type:"gold", amount: 10 + Math.floor(rng()*24)});
  if(rng()<0.72) contents.push({type:"gear", item: randomGearFromRng(rng)});
  if(rng()<0.58) contents.push({type:"consumable", item:{type:"consumable", name:"Ration", kind:"food", qty:1}});
  if(rng()<0.30) contents.push({type:"key", amount:1});
  if(rng()<0.18) contents.push({type:"xp", amount: 12 + Math.floor(rng()*20)});
  return contents;
}
function makeDungeonEnemy(type,x,y){
  const base = {
    "Goblin": {hp:12, ac:10, atk:3, xp:18},
    "Bandit": {hp:16, ac:11, atk:3, xp:22},
    "Cultist":{hp:14, ac:12, atk:3, xp:24},
    "Slime":  {hp:15, ac:10, atk:2, xp:20},
    "Wolf":   {hp:10, ac:10, atk:2, xp:16},
    "Boar":   {hp:14, ac:11, atk:3, xp:20},
    "Warg":   {hp:18, ac:12, atk:4, xp:28},
  }[type] || {hp:12, ac:10, atk:2, xp:18};
  // scale slightly with level
  const lv = Math.max(1,state.level);
  const hp = base.hp + Math.floor((lv-1)*2);
  const atk = base.atk + Math.floor((lv-1)/2);
  const ac = base.ac + Math.floor((lv-1)/3);
  const xp = base.xp + Math.floor((lv-1)*4);
  return {x,y,type, hp, ac, atk, xp};
}

function generateDungeon(kind, id){
  const rng = makeRNG(kind+"::"+id);
  const w = 28, h = 18;

  let grid = Array.from({length:h}, ()=>Array.from({length:w}, ()=> (rng()< (kind==="forest"?0.44:0.50) ? "wall" : "floor")));
  for(let y=0;y<h;y++){ grid[y][0]="wall"; grid[y][w-1]="wall"; }
  for(let x=0;x<w;x++){ grid[0][x]="wall"; grid[h-1][x]="wall"; }

  function countWalls(x,y){
    let c=0;
    for(let yy=y-1; yy<=y+1; yy++){
      for(let xx=x-1; xx<=x+1; xx++){
        if(xx===x && yy===y) continue;
        if(yy<0||xx<0||yy>=h||xx>=w){ c++; continue; }
        if(grid[yy][xx]==="wall") c++;
      }
    }
    return c;
  }
  const iters = kind==="forest"?5:6;
  for(let i=0;i<iters;i++){
    const next = grid.map(row=>row.slice());
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const walls = countWalls(x,y);
        next[y][x] = (walls>=5) ? "wall" : "floor";
      }
    }
    grid=next;
  }

  function randomFloor(){
    for(let t=0;t<4000;t++){
      const x = 1 + Math.floor(rng()*(w-2));
      const y = 1 + Math.floor(rng()*(h-2));
      if(grid[y][x]==="floor") return {x,y};
    }
    return {x:2,y:2};
  }

  const entrance = randomFloor();
  const exit = randomFloor();
  grid[entrance.y][entrance.x]="entrance";
  grid[exit.y][exit.x]="exit";

  const seen = Array.from({length:h}, ()=>Array.from({length:w}, ()=>false));
  const chests = {};
  const keysOnGround = {};
  const doors = {};
  const enemies = [];

  // door
  let doorPos=null;
  for(let tries=0;tries<2200;tries++){
    const p=randomFloor();
    if(Math.abs(p.x-entrance.x)+Math.abs(p.y-entrance.y)<6) continue;
    if(Math.abs(p.x-exit.x)+Math.abs(p.y-exit.y)<6) continue;
    doorPos=p; break;
  }
  if(doorPos){
    grid[doorPos.y][doorPos.x]="doorLocked";
    doors[`${doorPos.x},${doorPos.y}`]={locked:true, opened:false};
  }

  // key
  let keyPos=null;
  for(let tries=0;tries<2200;tries++){
    const p=randomFloor();
    if(doorPos && p.x===doorPos.x && p.y===doorPos.y) continue;
    if(Math.abs(p.x-entrance.x)+Math.abs(p.y-entrance.y)<4) continue;
    keyPos=p; break;
  }
  if(keyPos){
    grid[keyPos.y][keyPos.x]="key";
    keysOnGround[`${keyPos.x},${keyPos.y}`]={taken:false};
  }

  // chests
  const chestCount = kind==="forest"?4:5;
  for(let i=0;i<chestCount;i++){
    let p=null;
    for(let tries=0;tries<3000;tries++){
      const c=randomFloor();
      if(grid[c.y][c.x]!=="floor") continue;
      if(Math.abs(c.x-entrance.x)+Math.abs(c.y-entrance.y)<5) continue;
      const k=`${c.x},${c.y}`;
      if(chests[k]) continue;
      p=c; break;
    }
    if(!p) continue;
    const locked = rng()<0.48;
    grid[p.y][p.x]= locked ? "chestLocked" : "chest";
    chests[`${p.x},${p.y}`]={locked, opened:false, contents:dungeonChestContents(rng)};
  }

  // enemies placed
  const enemyCount = kind==="forest"?7:6;
  const enemyTypes = kind==="forest" ? ["Wolf","Bandit","Boar","Warg"] : ["Goblin","Bandit","Cultist","Slime"];
  for(let i=0;i<enemyCount;i++){
    let p=null;
    for(let tries=0;tries<3400;tries++){
      const c=randomFloor();
      if(grid[c.y][c.x]!=="floor") continue;
      if(Math.abs(c.x-entrance.x)+Math.abs(c.y-entrance.y)<4) continue;
      const k=`${c.x},${c.y}`;
      if(chests[k]||keysOnGround[k]||doors[k]) continue;
      if(enemies.some(e=>e.x===c.x && e.y===c.y)) continue;
      p=c; break;
    }
    if(!p) continue;
    const t = enemyTypes[Math.floor(rng()*enemyTypes.length)];
    enemies.push(makeDungeonEnemy(t,p.x,p.y));
  }

  return {kind,id,w,h,tiles:grid,seen,px:entrance.x,py:entrance.y,enemies,chests,keysOnGround,doors};
}

function revealAround(d, px,py,r){
  for(let y=py-r;y<=py+r;y++){
    for(let x=px-r;x<=px+r;x++){
      if(x>=0&&y>=0&&x<d.w&&y<d.h) d.seen[y][x]=true;
    }
  }
}

function currentDungeon(){
  if(!state.dungeonId) return null;
  return state.dungeons[state.dungeonId] || null;
}
function enterDungeon(nodeId){
  const n=nodeById[nodeId];
  if(!n || !(n.type==="cave"||n.type==="forest")) return;

  state.mode="dungeon";
  state.dungeonId = nodeId;

  if(!state.dungeons[nodeId]){
    state.dungeons[nodeId] = generateDungeon(n.dungeonKind || (n.type==="forest"?"forest":"cave"), nodeId);
  }

  const d=currentDungeon();
  const baseR=2;
  const torchBonus = Math.min(2, state.torches>0 ? 1 : 0); // if you own torches, better baseline
  revealAround(d,d.px,d.py, baseR+torchBonus);

  pushLog(`üïØÔ∏è Entered ${n.name}. Fog-of-war active.`);
  render();
}
function leaveDungeon(){
  const n=nodeById[state.currentNode];
  pushLog(`üå§Ô∏è You return to the surface near <b>${n.name}</b>.`);
  state.mode="world";
  state.dungeonId=null;
  render();
}
function tileAt(d,x,y){ return d.tiles?.[y]?.[x] || "wall"; }
function isWalkable(d,x,y){
  const t=tileAt(d,x,y);
  if(t==="wall") return false;
  if(t==="doorLocked"){
    const door=d.doors[`${x},${y}`];
    return door && door.opened;
  }
  return true;
}
function dungeonMove(dx,dy){
  if(state.mode!=="dungeon" || state.mode==="combat") return;
  const d=currentDungeon(); if(!d) return;

  const nx=d.px+dx, ny=d.py+dy;
  if(nx<0||ny<0||nx>=d.w||ny>=d.h) return;

  const t=tileAt(d,nx,ny);
  if(t==="wall"){ pushLog("ü™® Blocked."); render(); return; }
  if(t==="doorLocked"){
    const door=d.doors[`${nx},${ny}`];
    if(door && !door.opened){
      pushLog("üö™ Locked door. Use Interact to unlock (requires key).");
      render(); return;
    }
  }

  passTime(8, "Dungeon movement");
  d.px=nx; d.py=ny;

  const baseR=2;
  const torchBonus = (state.torches>0 ? 1 : 0);
  revealAround(d,nx,ny, baseR+torchBonus);

  const ei = d.enemies.findIndex(e=>e.x===nx && e.y===ny);
  if(ei>=0){
    const e=d.enemies[ei];
    startCombat(makeEnemyFromDungeon(e), {origin:"dungeon", dungeonId: state.dungeonId, enemyPos:{x:nx,y:ny}, dungeonEnemyXP:e.xp||20});
  }

  render();
}

/* ============================================================
   TILE-BASED INTERACTIONS + CITY ESTABLISHMENTS
============================================================ */
function addInteractButton(label, fn){
  const b=document.createElement("button");
  b.className="secondary";
  b.textContent=label;
  b.onclick=fn;
  $("interactButtons").appendChild(b);
}

function buildCityMenu(node){
  // establishments: church, tavern, inn, shop, library, guild
  const list = [];
  list.push({name:"Inn", icon:"üõèÔ∏è", fn:()=>openInn(node)});
  list.push({name:"Tavern", icon:"üç∫", fn:()=>openTavern(node)});
  list.push({name:"Shop", icon:"üõí", fn:()=>openShop(node)});
  list.push({name:"Church", icon:"‚õ™", fn:()=>openChurch(node)});
  list.push({name:"Library", icon:"üìö", fn:()=>openLibrary(node)});
  list.push({name:"Guild", icon:"üõ°Ô∏è", fn:()=>openGuild(node)});
  return list;
}

function buildInteractOptions(){
  const btns = $("interactButtons");
  btns.innerHTML = "";

  if(state.mode==="combat"){
    $("interactHint").textContent = "Combat: use Attack or Flee.";
    return;
  }

  if(state.mode==="world"){
    const n=nodeById[state.currentNode];
    let msg = `You are in ${n.name}. `;
    $("interactHint").textContent = msg;

    // dungeons entry
    if(n.type==="cave"||n.type==="forest"){
      msg += "You can enter this area.";
      $("interactHint").textContent = msg;
      addInteractButton(`Enter ${n.type==="cave"?"Cave":"Forest"}`, ()=>enterDungeon(n.id));
      return;
    }

    // city/town/capital/port menus
    if(n.type==="capital"||n.type==="city"||n.type==="town"||n.type==="port"||n.type==="camp"){
      $("interactHint").textContent = `${n.name}: choose an establishment.`;
      const menu = buildCityMenu(n);
      for(const m of menu){
        addInteractButton(`${m.icon} ${m.name}`, m.fn);
      }
      // also allow quick quest board
      addInteractButton("üìú Quest Board", openQuestBoard);
      return;
    }

    $("interactHint").textContent = msg;
    return;
  }

  // dungeon mode
  const d=currentDungeon(); if(!d) return;
  const x=d.px, y=d.py;
  const t=tileAt(d,x,y);

  const lines = [];
  lines.push(`Dungeon: (${x},${y}) ‚Ä¢ Tile: ${t}`);

  if(t==="chest" || t==="chestLocked"){
    const c=d.chests[`${x},${y}`];
    if(c?.opened){
      lines.push("Chest: opened.");
    } else {
      lines.push(t==="chestLocked" ? "Chest: locked." : "Chest: unlocked.");
      addInteractButton("Open Chest", ()=>openChestAt(x,y));
    }
  }
  if(t==="key"){
    const k=d.keysOnGround[`${x},${y}`];
    if(k && !k.taken){
      lines.push("Key on the ground.");
      addInteractButton("Pick up Key", ()=>pickupKeyAt(x,y));
    }
  }
  if(t==="doorLocked"){
    const door=d.doors[`${x},${y}`];
    if(door?.opened){
      lines.push("Door: unlocked.");
    } else {
      lines.push("Door: locked.");
      addInteractButton("Unlock Door (1 key)", ()=>unlockDoorAt(x,y));
    }
  }
  if(t==="exit"){
    lines.push("Exit to surface.");
    addInteractButton("Leave Dungeon", ()=>leaveDungeon());
  }

  lines.push("Search reveals more (no energy cost).");
  addInteractButton("Search (Reveal)", ()=>dungeonSearch());

  $("interactHint").textContent = lines.join(" ‚Ä¢ ");
}

function pickupKeyAt(x,y){
  const d=currentDungeon(); if(!d) return;
  const k=d.keysOnGround[`${x},${y}`];
  if(!k || k.taken) return;
  k.taken=true;
  state.keys += 1;
  d.tiles[y][x]="floor";
  passTime(3, "Pick up key");
  pushLog(`üîë You pick up a key. Keys: <b>${state.keys}</b>`);
  render();
}
function unlockDoorAt(x,y){
  const d=currentDungeon(); if(!d) return;
  const door=d.doors[`${x},${y}`];
  if(!door || door.opened) return;
  if(state.keys<=0){
    pushLog("üîë You need a key to unlock this door.");
    render(); return;
  }
  state.keys -= 1;
  door.opened=true;
  door.locked=false;
  passTime(5, "Unlock door");
  pushLog(`üö™ Unlocked the door. Keys left: <b>${state.keys}</b>`);
  render();
}
function openChestAt(x,y){
  const d=currentDungeon(); if(!d) return;
  const c=d.chests[`${x},${y}`];
  const t=tileAt(d,x,y);
  if(!c || c.opened) return;

  const locked = (t==="chestLocked") || c.locked;
  if(locked){
    if(state.keys<=0){
      pushLog("üîí Chest is locked. Need a key.");
      render(); return;
    }
    state.keys -= 1;
    pushLog("üîì You unlock the chest using a key.");
  }

  c.opened=true;
  d.tiles[y][x]="floor";
  passTime(6, "Open chest");

  let gained=[];
  for(const item of c.contents){
    if(item.type==="gold"){ state.gold += item.amount; gained.push(`${item.amount}g`); }
    if(item.type==="gear"){ state.bag.push(item.item); gained.push(fmtItem(item.item)); }
    if(item.type==="consumable"){ addToBag(item.item); gained.push(item.item.name); }
    if(item.type==="key"){ state.keys += item.amount; gained.push(`${item.amount} key`); }
    if(item.type==="xp"){ gainXP(item.amount); gained.push(`${item.amount}xp`); }
  }
  pushLog(`üì¶ Chest opened! Gained: <b>${gained.join(", ")}</b>`);
  render();
}
function dungeonSearch(){
  const d=currentDungeon(); if(!d) return;
  passTime(12, "Search dungeon area");

  const baseR=3;
  const torchBonus = (state.torches>0 ? 1 : 0);
  revealAround(d,d.px,d.py, baseR+torchBonus);

  // search check (INT or WIS)
  const chk = (state.class==="Mage") ? outcomeCheck("INT", 12) : outcomeCheck("WIS", 12);
  if(chk.pass && roll(100)<=30){
    const g=roll(12)+5; state.gold+=g;
    pushLog(`‚ú® Search success (${chk.total}): hidden stash <b>${g}g</b>.`);
    gainXP(8);
  } else {
    pushLog("üïØÔ∏è You search carefully and reveal more of the area.");
  }
  render();
}

/* ============================================================
   CITY ESTABLISHMENTS (modal-driven)
============================================================ */
function openInn(node){
  if(state.mode!=="world") return;
  const price = (node.type==="capital"||node.type==="city") ? 10 : 7;
  const html = `
    <div class="panel">
      <div><b>Inn</b> ‚Äî Rest safely and recover.</div>
      <div class="muted" style="margin-top:8px">Cost: <b>${price}g</b> ‚Ä¢ Heals and advances to next morning.</div>
      <div class="row" style="margin-top:12px">
        <button class="small" onclick="payAndSleep(${price})">Pay & Sleep</button>
        <button class="small secondary" onclick="closeModal()">Leave</button>
      </div>
    </div>
  `;
  openModal(`üõèÔ∏è Inn ‚Äî ${node.name}`, html);
}
function payAndSleep(price){
  if(state.gold<price){ pushLog("üõèÔ∏è Not enough gold for the inn."); render(); return; }
  state.gold -= price;
  closeModal();
  sleep(true); // inn sleep
}
function openTavern(node){
  if(state.mode!=="world") return;
  // rumors based on terrain + quest hints
  const q = activeQuest();
  const rumor = (() => {
    const t = terrainType(node.x,node.y);
    const list = [
      "A traveler swears the caves remember what you‚Äôve opened ‚Äî chests don‚Äôt reset.",
      "Guild contracts pay well if you can deliver without picking fights.",
      "Torches make your dungeon searches reveal more ground.",
      "Desert routes are safer at dawn‚Ä¶ but hunger hits harder in the heat.",
      "In the tundra, the wind steals your strength ‚Äî pack rations and rest often.",
      "Bandits avoid confident folk ‚Äî a strong presence can sometimes avert trouble."
    ];
    if(q) list.unshift(`Your active quest leads toward <b>${nodeById[q.to]?.name || "your destination"}</b>.`);
    if(t==="mountains") list.unshift("Mountain passes hide shortcuts ‚Äî but beasts nest near cliffs.");
    if(t==="forest"||t==="woody") list.unshift("Forests conceal ambushes. Keep your wits about you.");
    return list[Math.floor(Math.random()*list.length)];
  })();

  const html = `
    <div class="panel">
      <div><b>Tavern</b> ‚Äî Drinks, chatter, and work.</div>
      <div class="muted" style="margin-top:10px">Rumor: ${rumor}</div>
      <div class="row" style="margin-top:12px">
        <button class="small" onclick="openQuestBoard()">Quest Board</button>
        <button class="small secondary" onclick="closeModal()">Leave</button>
      </div>
    </div>
  `;
  openModal(`üç∫ Tavern ‚Äî ${node.name}`, html);
}
function openShop(node){
  if(state.mode!=="world") return;
  const goods = [
    {label:"Ration", cost:5, action:"buy_ration"},
    {label:"Torch", cost:4, action:"buy_torch"},
    {label:"Basic Key", cost:14, action:"buy_key"},
    {label:"Healing Poultice", cost:12, action:"buy_poultice"},
  ];
  const sellables = state.bag
    .map((it,idx)=>({it,idx}))
    .filter(x=>x.it.type==="weapon"||x.it.type==="armor"||x.it.type==="accessory");

  let html = `<div class="panel"><div><b>Shop</b> ‚Äî Buy supplies or sell gear.</div>`;
  html += `<div class="muted" style="margin-top:8px">Gold: <b>${state.gold}g</b></div>`;
  html += `<div style="margin-top:12px"><b>Buy</b></div><div style="display:grid;gap:10px;margin-top:8px">`;
  for(const g of goods){
    html += `
      <div class="panel" style="display:flex;justify-content:space-between;gap:10px;align-items:center">
        <div>${g.label}</div>
        <div class="row">
          <span class="muted"><b>${g.cost}g</b></span>
          <button class="small" onclick="shopBuy('${g.action}', ${g.cost})">Buy</button>
        </div>
      </div>
    `;
  }
  html += `</div>`;

  html += `<div style="margin-top:14px"><b>Sell gear</b> <span class="muted">(50% value)</span></div>`;
  if(sellables.length===0){
    html += `<div class="muted" style="margin-top:8px">No sellable gear in your backpack.</div>`;
  } else {
    html += `<div style="display:grid;gap:10px;margin-top:8px">`;
    for(const s of sellables){
      const value = gearValue(s.it);
      const sell = Math.floor(value*0.5);
      html += `
        <div class="panel" style="display:flex;justify-content:space-between;gap:10px;align-items:center">
          <div><b>${s.it.name}</b> <span class="muted">${s.it.type}</span></div>
          <div class="row">
            <span class="muted">Sell: <b>${sell}g</b></span>
            <button class="small secondary" onclick="shopSell(${s.idx})">Sell</button>
          </div>
        </div>
      `;
    }
    html += `</div>`;
  }

  html += `<div class="row" style="margin-top:12px"><button class="small secondary" onclick="closeModal()">Leave</button></div></div>`;
  openModal(`üõí Shop ‚Äî ${node.name}`, html);
}
function gearValue(it){
  let v=10;
  v += (it.atk||0)*7 + (it.def||0)*7;
  if((it.name||"").includes("Fine")) v += 8;
  if((it.name||"").includes("Mythic")) v += 18;
  return v;
}
function shopBuy(action, cost){
  if(state.gold < cost){ pushLog("üõí Not enough gold."); render(); return; }
  state.gold -= cost;
  if(action==="buy_ration") addToBag({type:"consumable", name:"Ration", kind:"food", qty:1});
  if(action==="buy_torch") state.torches += 1;
  if(action==="buy_key") state.keys += 1;
  if(action==="buy_poultice") addToBag({type:"consumable", name:"Poultice", kind:"heal", qty:1});
  pushLog(`üõí Purchased item for <b>${cost}g</b>.`);
  openShop(nodeById[state.currentNode]); // refresh modal
  render();
}
function shopSell(idx){
  const it = state.bag[idx];
  if(!it) return;
  const sell = Math.floor(gearValue(it)*0.5);
  state.bag.splice(idx,1);
  state.gold += sell;
  pushLog(`üí∞ Sold <b>${it.name}</b> for <b>${sell}g</b>.`);
  openShop(nodeById[state.currentNode]);
  render();
}

function openChurch(node){
  if(state.mode!=="world") return;
  const donate = (node.type==="capital"||node.type==="city") ? 8 : 6;
  const html = `
    <div class="panel">
      <div><b>Church</b> ‚Äî Quiet prayers and healing.</div>
      <div class="muted" style="margin-top:8px">Donate <b>${donate}g</b> to restore HP and ease hardship.</div>
      <div class="row" style="margin-top:12px">
        <button class="small" onclick="churchHeal(${donate})">Donate & Heal</button>
        <button class="small secondary" onclick="closeModal()">Leave</button>
      </div>
    </div>
  `;
  openModal(`‚õ™ Church ‚Äî ${node.name}`, html);
}
function churchHeal(cost){
  if(state.gold<cost){ pushLog("‚õ™ Not enough gold to donate."); render(); return; }
  state.gold -= cost;
  const s=getEffectiveStats();
  const heal = 6 + roll(6) + Math.max(0, statMod(s.WIS));
  state.hp = clamp(state.hp + heal, 0, state.hpMax);
  state.hunger = clamp(state.hunger + 2, 0, state.hungerMax);
  gainXP(10);
  pushLog(`<span style="color:var(--good)">‚õ™ You feel restored. Healed <b>${heal}</b> HP.</span>`);
  closeModal();
  render();
}

function openLibrary(node){
  if(state.mode!=="world") return;
  const chk = outcomeCheck("INT", 13);
  const text = chk.pass
    ? `You study maps and histories. <b>INT check ${chk.total} (pass)</b> ‚Äî you gain insight and feel sharper.`
    : `You leaf through dusty tomes. <b>INT check ${chk.total} (fail)</b> ‚Äî mostly confusing diagrams.`;

  const html = `
    <div class="panel">
      <div><b>Library</b> ‚Äî Research and lore.</div>
      <div class="muted" style="margin-top:10px">${text}</div>
      <div class="row" style="margin-top:12px">
        <button class="small" onclick="libraryStudy(${chk.pass ? 1:0})">Study</button>
        <button class="small secondary" onclick="closeModal()">Leave</button>
      </div>
    </div>
  `;
  openModal(`üìö Library ‚Äî ${node.name}`, html);
}
function libraryStudy(pass){
  passTime(40, "Library study");
  if(pass){
    gainXP(18);
    pushLog(`<span style="color:var(--good)">üìö You learn useful routes and tactics. +18xp.</span>`);
  } else {
    gainXP(6);
    pushLog(`üìö Some knowledge sticks. +6xp.`);
  }
  closeModal();
  render();
}

function openGuild(node){
  if(state.mode!=="world") return;
  const trainCost = 16 + (state.level-1)*4;
  const html = `
    <div class="panel">
      <div><b>Guild Hall</b> ‚Äî Contracts and training.</div>
      <div class="muted" style="margin-top:10px">Training costs <b>${trainCost}g</b> and grants XP (and a small permanent boost every few trainings later).</div>
      <div class="row" style="margin-top:12px">
        <button class="small" onclick="guildTrain(${trainCost})">Train</button>
        <button class="small secondary" onclick="openQuestBoard()">Quest Board</button>
        <button class="small secondary" onclick="closeModal()">Leave</button>
      </div>
    </div>
  `;
  openModal(`üõ°Ô∏è Guild ‚Äî ${node.name}`, html);
}
function guildTrain(cost){
  if(state.gold<cost){ pushLog("üõ°Ô∏è Not enough gold for training."); render(); return; }
  state.gold -= cost;
  passTime(60, "Guild training");
  gainXP(28);
  pushLog(`<span style="color:var(--good)">üõ°Ô∏è You train hard. +28xp.</span>`);
  closeModal();
  render();
}

/* ============================================================
   COMBAT (attack only in combat; stats affect rolls)
============================================================ */
function makeEnemy(tag){
  // scale with player level
  const lv = Math.max(1,state.level);
  const bumpHp = Math.floor((lv-1)*2);
  const bumpAtk = Math.floor((lv-1)/2);
  const bumpAc = Math.floor((lv-1)/3);
  const bumpXp = Math.floor((lv-1)*5);

  if(tag==="pirates") return {name:"Pirate Skiff", hp:18+bumpHp, hpMax:18+bumpHp, ac:12+bumpAc, atk:4+bumpAtk, xp:28+bumpXp, tag:"pirates"};
  if(tag==="sea"){
    const pick = (roll(2)===1) ? "Sea Serpent" : "Reef Stalker";
    return {name:pick, hp:16+bumpHp, hpMax:16+bumpHp, ac:11+bumpAc, atk:4+bumpAtk, xp:26+bumpXp, tag:"sea"};
  }
  if(tag==="road"){
    const pick = ["Bandit","Wolf","Cultist"][roll(3)-1];
    return makeEnemyByName(pick, tag);
  }
  const pick = ["Goblin","Bandit","Wolf"][roll(3)-1];
  return makeEnemyByName(pick, tag);

  function makeEnemyByName(name, tag){
    const base = {
      "Goblin": {hp:12, ac:10, atk:3, xp:18},
      "Bandit": {hp:16, ac:11, atk:3, xp:22},
      "Wolf":   {hp:10, ac:10, atk:2, xp:16},
      "Cultist":{hp:14, ac:12, atk:3, xp:24},
      "Slime":  {hp:15, ac:10, atk:2, xp:20},
    }[name] || {hp:12, ac:10, atk:2, xp:18};
    return {name, hp:base.hp+bumpHp, hpMax:base.hp+bumpHp, ac:base.ac+bumpAc, atk:base.atk+bumpAtk, xp:base.xp+bumpXp, tag};
  }
}
function makeEnemyFromDungeon(e){
  return {name:e.type, hp:e.hp, hpMax:e.hp, ac:e.ac, atk:e.atk, xp:e.xp||22, tag:"dungeon"};
}

function startCombat(enemy, meta){
  state.mode="combat";
  state.enemy=enemy;
  state.enemyMeta=meta||{};
  pushLog(`‚ö†Ô∏è Encounter: <b>${enemy.name}</b> appears!`);
  render();
}
function endCombat(victory){
  const meta=state.enemyMeta||{};
  if(victory){
    const gold=roll(12)+4;
    state.gold+=gold;

    const xpGain = state.enemy?.xp || meta.dungeonEnemyXP || 18;
    gainXP(xpGain);

    pushLog(`‚úÖ Victory! You gain <b>${gold}g</b> and <b>${xpGain}xp</b>.`);

    if(roll(100)<=26){ const gear=randomGear(); state.bag.push(gear); pushLog(`üì¶ Loot: <b>${fmtItem(gear)}</b>.`); }
    if(roll(100)<=22){ addToBag({type:"consumable", name:"Ration", kind:"food", qty:1}); pushLog(`üçó Loot: <b>Ration</b>`); }
    if(roll(100)<=14){ addToBag({type:"consumable", name:"Poultice", kind:"heal", qty:1}); pushLog(`üß¥ Loot: <b>Poultice</b>`); }

    if(state.pendingArrival){
      const toId=state.pendingArrival;
      state.pendingArrival=null;
      pushLog(`üß≠ You continue and arrive at <b>${nodeById[toId].name}</b>.`);
      enterNode(toId);
    }

    if(meta.origin==="dungeon" && meta.dungeonId && meta.enemyPos){
      const d=state.dungeons[meta.dungeonId];
      if(d){
        d.enemies = d.enemies.filter(en => !(en.x===meta.enemyPos.x && en.y===meta.enemyPos.y));
        pushLog("üó∫Ô∏è That enemy is gone for good.");
      }
    }
  } else {
    pushLog(`üèÉ You escape!`);
    state.pendingArrival=null;
  }

  state.enemy=null;
  state.enemyMeta=null;

  if(state.dungeonId) state.mode="dungeon";
  else state.mode="world";

  render();
}

function playerAttack(){
  if(state.mode!=="combat" || !state.enemy) return;

  const s=getEffectiveStats();
  const cls=CLASSES[state.class] || CLASSES["Fighter"];
  const primary = cls.primary;
  const mod = statMod(s[primary]||10);

  const d20=roll(20);
  const total = d20 + mod + Math.floor((state.level-1)/2);
  pushLog(`üé≤ You roll d20: <b>${d20}</b> + mod <b>${mod}</b> = <b>${total}</b>`);

  if(d20===20){
    const dmg=(roll(6)+roll(6)) + getAtk();
    state.enemy.hp -= dmg;
    pushLog(`<span style="color:var(--good)">üí• Critical! You deal <b>${dmg}</b>.</span>`);
  } else if(total >= state.enemy.ac){
    const dmg=roll(6)+getAtk();
    state.enemy.hp -= dmg;
    pushLog(`‚öîÔ∏è Hit! You deal <b>${dmg}</b>.`);
  } else {
    pushLog(`‚ùå Miss.`);
  }

  if(state.enemy.hp<=0){
    pushLog(`üíÄ ${state.enemy.name} defeated.`);
    endCombat(true);
    return;
  }
  enemyTurn();
}
function enemyTurn(){
  const d20=roll(20);
  const total = d20 + state.enemy.atk;
  pushLog(`üé≤ ${state.enemy.name} rolls d20: <b>${d20}</b> + atk <b>${state.enemy.atk}</b> = <b>${total}</b>`);
  if(total >= playerAC()){
    const dmg=roll(6)+state.enemy.atk;
    state.hp = clamp(state.hp - dmg, 0, state.hpMax);
    pushLog(`<span style="color:var(--bad)">ü©∏ You take ${dmg} damage.</span>`);
  } else pushLog(`üõ°Ô∏è Enemy misses.`);

  if(state.hp<=0){
    state.hp=1;
    pushLog(`<b style="color:var(--bad)">‚ò†Ô∏è You collapse‚Ä¶ and wake at your last safe location.</b>`);
    state.mode="world";
    state.dungeonId=null;
    state.enemy=null;
    state.enemyMeta=null;
    state.pendingArrival=null;
    enterNode(state.lastSafeNode);
  }
  render();
}
function flee(){
  if(state.mode!=="combat") return;
  const chk = outcomeCheck("DEX", 13);
  pushLog(`üèÉ Flee attempt: d20 <b>${chk.d20}</b> + DEX mod <b>${chk.mod}</b> = <b>${chk.total}</b>`);
  if(chk.pass) endCombat(false);
  else { pushLog("‚ùå Failed to flee."); enemyTurn(); }
}

/* ============================================================
   SEARCH / EXPLORE
============================================================ */
function searchExplore(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't search during combat."); render(); return; }
  if(state.mode==="dungeon"){ dungeonSearch(); return; }

  passTime(20, "World search");

  const n=nodeById[state.currentNode];
  const tt=terrainType(n.x,n.y);

  // Stat check varies by class/terrain
  let stat = "WIS";
  if(state.class==="Rogue") stat="DEX";
  if(state.class==="Mage") stat="INT";
  if(tt==="desert") stat="CON";
  if(tt==="mountains") stat="STR";

  const chk = outcomeCheck(stat, 13);
  if(chk.pass){
    const r=roll(100);
    if(r<=35){ const g=roll(14)+6; state.gold+=g; pushLog(`üîé Success (${chk.total}): found <b>${g}g</b>.`); gainXP(10); }
    else if(r<=58){ const item=randomGear(); state.bag.push(item); pushLog(`üîé Success (${chk.total}): found <b>${fmtItem(item)}</b>.`); gainXP(12); }
    else { addToBag({type:"consumable", name:"Ration", kind:"food", qty:1}); pushLog(`üîé Success (${chk.total}): found <b>Ration</b>.`); gainXP(8); }
  } else {
    pushLog(`üîé Search fails (${chk.total}). Nothing useful.`);
    gainXP(2);
  }

  // Encounter chance reduced by CHA (presence)
  const cha = outcomeCheck("CHA", 12);
  let encounter = 12;
  if(cha.pass) encounter = 8;

  if(roll(100)<=encounter) startCombat(makeEnemy("ambush"), {origin:"world"});
  render();
}

/* ============================================================
   SLEEP / EAT / BUY
============================================================ */
function canSleepHere(){
  const n=nodeById[state.currentNode];
  return state.mode==="world" && (n.type==="town"||n.type==="city"||n.type==="camp"||n.type==="port"||n.type==="capital");
}
function sleep(isInn=false){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't sleep in combat."); render(); return; }
  if(!canSleepHere()){ pushLog("üõå You can only sleep in a safe location."); render(); return; }

  const now = state.minutes;
  const target = 8*60;
  let delta = (target - now);
  if(delta<=0) delta += 1440;
  passTime(delta, isInn ? "Inn Sleep" : "Sleep");

  const s=getEffectiveStats();
  const heal = (isInn?10:8) + roll(6) + Math.max(0, statMod(s.CON));
  state.hp = clamp(state.hp + heal, 0, state.hpMax);
  state.hunger = clamp(state.hunger + (isInn?5:3), 0, state.hungerMax);
  pushLog(`<span style="color:var(--good)">üõå Slept safely. Healed ${heal} HP.</span>`);
  render();
}
function eat(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't eat in combat."); render(); return; }
  // allow poultice usage from bag too (heals)
  if(countItem("food")<=0){ pushLog("üçó No rations."); render(); return; }
  consumeItem("food",1);
  const s=getEffectiveStats();
  state.hunger = clamp(state.hunger + 5, 0, state.hungerMax);
  state.hp = clamp(state.hp + 2 + Math.max(0,statMod(s.CON)), 0, state.hpMax);
  pushLog(`<span style="color:var(--good)">üçó Ate a ration. +Hunger, +HP.</span>`);
  render();
}
function usePoultice(){
  if(state.mode==="combat"){ pushLog("üß¥ You can apply a poultice after combat."); render(); return; }
  const has = state.bag.find(x=>x.type==="consumable" && x.kind==="heal");
  if(!has){ pushLog("üß¥ No poultices."); render(); return; }
  consumeItem("heal",1);
  const s=getEffectiveStats();
  const heal = 6 + roll(6) + Math.max(0,statMod(s.WIS));
  state.hp = clamp(state.hp + heal, 0, state.hpMax);
  pushLog(`<span style="color:var(--good)">üß¥ Applied poultice. Healed ${heal} HP.</span>`);
  render();
}
function canBuyHere(){
  const n=nodeById[state.currentNode];
  return state.mode==="world" && (n.type==="town"||n.type==="city"||n.type==="port"||n.type==="camp"||n.type==="capital");
}
function buyRation(){
  if(!canBuyHere()){ pushLog("üõí Buy rations in safe locations."); render(); return; }
  if(state.gold<5){ pushLog("üõí Not enough gold for a ration."); render(); return; }
  state.gold -= 5;
  addToBag({type:"consumable", name:"Ration", kind:"food", qty:1});
  pushLog("üõí Bought <b>1 Ration</b> for 5g.");
  render();
}
function buyTorch(){
  if(!canBuyHere()){ pushLog("üõí Buy torches in safe locations."); render(); return; }
  if(state.gold<4){ pushLog("üõí Not enough gold for a torch."); render(); return; }
  state.gold -= 4;
  state.torches += 1;
  pushLog("üïØÔ∏è Bought <b>1 Torch</b> for 4g.");
  render();
}

/* ============================================================
   QUEST BOARD
============================================================ */
function openQuestBoard(){
  const n=nodeById[state.currentNode];
  if(state.mode!=="world" || !(n.type==="town"||n.type==="city"||n.type==="camp"||n.type==="port"||n.type==="capital")){
    openModal("Quest Board", "You can only access a quest board in a safe location.");
    return;
  }

  const list = questBoardForNode(n.id);
  let html = `<div style="margin-top:10px;color:var(--muted)">Available quests in <b>${n.name}</b>:</div><div style="margin-top:10px;display:grid;gap:10px">`;

  if(list.length===0){
    html += `<div class="panel">No quests here right now.</div>`;
  } else {
    for(const q of list){
      const st=questStatus(q.id);
      const canAccept = !st.accepted && !st.completed && !state.activeQuestId;
      const isActive = state.activeQuestId===q.id && st.accepted && !st.completed;
      html += `
        <div class="panel">
          <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap">
            <div><b>${q.title}</b><div class="muted">${q.text}</div></div>
            <div class="muted">To: <b>${nodeById[q.to]?.name || q.to}</b> ‚Ä¢ Reward: <b>${q.reward.gold}g</b>${q.reward.key?` + <b>${q.reward.key}</b> key`:""} + <b>${q.reward.xp||0}xp</b></div>
          </div>
          <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap">
            ${st.completed ? `<button class="secondary small" disabled>Completed</button>` : ""}
            ${isActive ? `<button class="secondary small" disabled>Active</button>` : ""}
            ${canAccept ? `<button class="small" onclick="acceptQuest('${q.id}')">Accept</button>` : ""}
            ${(!canAccept && !st.completed && !isActive && st.accepted) ? `<button class="secondary small" disabled>Accepted</button>` : ""}
            ${(!canAccept && !st.completed && !isActive && !st.accepted && state.activeQuestId) ? `<span class="muted">Finish/clear your active quest first.</span>` : ""}
          </div>
        </div>
      `;
    }
  }
  html += `</div>`;
  openModal("üìú Quest Board", html);
}

function acceptQuest(qid){
  closeModal();
  const q = QUESTS.find(x=>x.id===qid);
  if(!q) return;
  const st=questStatus(qid);
  if(st.completed || st.accepted) return;
  if(state.activeQuestId){ pushLog("üìú You already have an active quest."); render(); return; }

  setQuestStatus(qid,{accepted:true,completed:false});
  state.activeQuestId = qid;
  addQuestItem(q.item);
  pushLog(`üìú Quest accepted: <b>${q.title}</b>. Deliver to <b>${nodeById[q.to]?.name || q.to}</b>.`);
  render();
}

/* ============================================================
   MAP ENGINE (zoom/pan/hover/route highlighting) ‚Äî for HUGE world
============================================================ */
let view = {
  scale: 0.55,
  minScale: 0.25,
  maxScale: 2.6,
  ox: 0,
  oy: 0,
  dragging: false,
  dragStart: {x:0,y:0,ox:0,oy:0},
  hoverNode: null,
  hoverEdge: null
};

function resizeCanvas(){
  const r = mapCanvas.getBoundingClientRect();
  mapCanvas.width = Math.floor(r.width * devicePixelRatio);
  mapCanvas.height = Math.floor(r.height * devicePixelRatio);
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}

function worldToScreen(x,y){ return { x: x*view.scale + view.ox, y: y*view.scale + view.oy }; }
function screenToWorld(x,y){ return { x: (x - view.ox)/view.scale, y: (y - view.oy)/view.scale }; }

function softCenterOnNode(nodeId){
  const n=nodeById[nodeId];
  if(!n) return;
  const r = mapCanvas.getBoundingClientRect();
  const targetOx = r.width/2 - n.x*view.scale;
  const targetOy = r.height/2 - n.y*view.scale;
  // blend
  view.ox = lerp(view.ox, targetOx, 0.45);
  view.oy = lerp(view.oy, targetOy, 0.45);
}

function drawWorld(){
  const r=mapCanvas.getBoundingClientRect();
  ctx.clearRect(0,0,r.width,r.height);

  // background: draw pre-rendered terrain (huge texture scaled to world coords)
  if(terrainImg){
    ctx.save();
    ctx.translate(view.ox, view.oy);
    ctx.scale(view.scale, view.scale);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(terrainImg, 0,0, WORLD_W, WORLD_H);
    ctx.restore();
  } else {
    // fallback sea
    const g = ctx.createLinearGradient(0,0,0,r.height);
    g.addColorStop(0, "rgba(20,40,120,.65)");
    g.addColorStop(1, "rgba(10,20,60,.75)");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,r.width,r.height);
  }

  // kingdom highlight
  ctx.save();
  ctx.translate(view.ox, view.oy);
  ctx.scale(view.scale, view.scale);
  const cap=nodeById["capital_aurelia"];
  if(cap){
    ctx.beginPath();
    ctx.fillStyle="rgba(124,92,255,.10)";
    ctx.strokeStyle="rgba(124,92,255,.30)";
    ctx.lineWidth=8/view.scale;
    ctx.arc(cap.x,cap.y,420,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
    // walls ring
    ctx.setLineDash([18/view.scale, 14/view.scale]);
    ctx.strokeStyle="rgba(255,255,255,.14)";
    ctx.lineWidth=5/view.scale;
    ctx.beginPath();
    ctx.arc(cap.x,cap.y,300,0,Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  ctx.restore();

  // terrain icons overlay (mountains/trees/etc)
  ctx.save();
  ctx.translate(view.ox, view.oy);
  ctx.scale(view.scale, view.scale);
  ctx.globalAlpha=0.55;
  ctx.fillStyle="rgba(255,255,255,.85)";
  for(const ic of terrainIcons){
    // skip if too far off screen (quick cull)
    // (cull in world-space using inverse)
    const sx = ic.x*view.scale+view.ox;
    const sy = ic.y*view.scale+view.oy;
    if(sx<-40 || sy<-40 || sx>r.width+40 || sy>r.height+40) continue;
    ctx.font = `${14/view.scale}px system-ui`;
    const ch = ic.kind==="mountain" ? "‚õ∞Ô∏è" : ic.kind==="tree" ? "üå≤" : ic.kind==="dune" ? "üèúÔ∏è" : "‚ùÑÔ∏è";
    ctx.fillText(ch, ic.x, ic.y);
  }
  ctx.globalAlpha=1;
  ctx.restore();

  // draw rivers again in world space (crisper)
  ctx.save();
  ctx.translate(view.ox, view.oy);
  ctx.scale(view.scale, view.scale);
  ctx.globalAlpha=0.85;
  ctx.strokeStyle="rgba(147,197,253,.65)";
  ctx.lineWidth=4/view.scale;
  for(const river of rivers){
    ctx.beginPath();
    for(let i=0;i<river.length;i++){
      const p=river[i];
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke();
  }
  ctx.globalAlpha=1;
  ctx.restore();

  // routes + nodes
  ctx.save();
  ctx.translate(view.ox, view.oy);
  ctx.scale(view.scale, view.scale);

  const here = state.currentNode;
  const neigh = new Set(neighbors(here));

  // draw routes as bezier to avoid straight-line feel
  function strokeBezier(A,B,c1,c2,style){
    ctx.beginPath();
    ctx.moveTo(A.x,A.y);
    ctx.bezierCurveTo(c1.x,c1.y, c2.x,c2.y, B.x,B.y);
    ctx.strokeStyle=style.stroke;
    ctx.lineWidth=style.w/view.scale;
    if(style.dash) ctx.setLineDash(style.dash.map(v=>v/view.scale));
    else ctx.setLineDash([]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  for(const e of world.edges){
    const A=nodeById[e.a], B=nodeById[e.b];
    const isFromHere = (e.a===here || e.b===here);
    const isHover = view.hoverEdge && ((view.hoverEdge.a===e.a && view.hoverEdge.b===e.b) || (view.hoverEdge.a===e.b && view.hoverEdge.b===e.a));
    const thick = (isHover?7:(isFromHere?6:3.5));

    if(e.kind==="sea"){
      strokeBezier(A,B,e.c1,e.c2,{
        stroke: isHover ? "rgba(147,197,253,.9)" : "rgba(147,197,253,.45)",
        w: thick,
        dash: [14,12]
      });
      // fare label
      const mx=(A.x+B.x)/2, my=(A.y+B.y)/2;
      ctx.fillStyle="rgba(229,231,235,.85)";
      ctx.font = `${12/view.scale}px system-ui`;
      ctx.fillText(`‚õ¥ ${e.fare}g`, mx+8, my-8);
    } else if(e.kind==="bridge"){
      // road + bridge accent
      strokeBezier(A,B,e.c1,e.c2,{
        stroke: isHover ? "rgba(251,191,36,.75)" : (isFromHere ? "rgba(251,191,36,.45)" : "rgba(251,191,36,.24)"),
        w: thick
      });
    } else {
      strokeBezier(A,B,e.c1,e.c2,{
        stroke: isHover ? "rgba(251,191,36,.75)" : (isFromHere ? "rgba(251,191,36,.45)" : "rgba(251,191,36,.20)"),
        w: thick
      });
    }
  }

  // draw bridge icons where roads cross rivers
  for(const b of bridges){
    ctx.font = `${14/view.scale}px system-ui`;
    ctx.fillStyle="rgba(229,231,235,.92)";
    ctx.fillText("üåâ", b.x, b.y);
  }

  // nodes
  for(const n of world.nodes){
    const isHere = n.id===here;
    const isNeighbor = neigh.has(n.id);
    const isHover = view.hoverNode && view.hoverNode.id===n.id;

    let fill="rgba(255,255,255,.12)", icon="‚Ä¢", rNode=14;
    if(n.type==="capital"){ fill="rgba(124,92,255,.35)"; icon="üè∞"; rNode=18; }
    if(n.type==="city"){ fill="rgba(124,92,255,.22)"; icon="üèôÔ∏è"; rNode=16; }
    if(n.type==="town"){ fill="rgba(124,92,255,.18)"; icon="üèòÔ∏è"; rNode=15; }
    if(n.type==="camp"){ fill="rgba(52,211,153,.18)"; icon="‚õ∫"; rNode=14; }
    if(n.type==="port"){ fill="rgba(59,130,246,.20)"; icon="‚öì"; rNode=15; }
    if(n.type==="cave"){ fill="rgba(251,113,133,.16)"; icon="üï≥Ô∏è"; rNode=14; }
    if(n.type==="forest"){ fill="rgba(34,197,94,.14)"; icon="üå≤"; rNode=14; }

    if(isHere){
      ctx.beginPath();
      ctx.fillStyle="rgba(124,92,255,.22)";
      ctx.arc(n.x,n.y,rNode+12,0,Math.PI*2);
      ctx.fill();
    }

    ctx.beginPath();
    ctx.fillStyle = fill;
    ctx.strokeStyle = isNeighbor ? "rgba(255,255,255,.42)" : "rgba(255,255,255,.18)";
    ctx.lineWidth = (isHover?3:2)/view.scale;
    ctx.arc(n.x,n.y,rNode,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle="rgba(229,231,235,.95)";
    ctx.font = `${14/view.scale}px system-ui`;
    ctx.fillText(icon, n.x-(rNode*0.65), n.y+(rNode*0.35));

    ctx.fillStyle = isHover ? "rgba(255,255,255,.98)" : "rgba(229,231,235,.92)";
    ctx.font = `${12/view.scale}px system-ui`;
    ctx.fillText(n.name, n.x+(rNode+10), n.y+4);
  }

  ctx.restore();
}

function drawDungeon(){
  const r=mapCanvas.getBoundingClientRect();
  ctx.clearRect(0,0,r.width,r.height);
  ctx.fillStyle="rgba(0,0,0,.45)";
  ctx.fillRect(0,0,r.width,r.height);

  const d=currentDungeon(); if(!d) return;
  const pad=14;
  const cell=Math.min((r.width-pad*2)/d.w,(r.height-pad*2)/d.h);

  for(let y=0;y<d.h;y++){
    for(let x=0;x<d.w;x++){
      const sx=pad+x*cell, sy=pad+y*cell;
      const seen=d.seen[y]?.[x];

      if(!seen){
        ctx.fillStyle="rgba(0,0,0,.90)";
        ctx.fillRect(sx,sy,cell,cell);
        continue;
      }

      const t=tileAt(d,x,y);
      if(t==="wall") ctx.fillStyle = d.kind==="forest" ? "rgba(16,60,35,.55)" : "rgba(255,255,255,.10)";
      else ctx.fillStyle = d.kind==="forest" ? "rgba(35,95,60,.25)" : "rgba(255,255,255,.18)";
      ctx.fillRect(sx,sy,cell,cell);

      if(t==="entrance"){ ctx.fillStyle="rgba(52,211,153,.9)"; ctx.fillRect(sx+cell*0.25,sy+cell*0.25,cell*0.5,cell*0.5); }
      if(t==="exit"){ ctx.fillStyle="rgba(124,92,255,.9)"; ctx.fillRect(sx+cell*0.25,sy+cell*0.25,cell*0.5,cell*0.5); }
      if(t==="key"){ ctx.fillStyle="rgba(251,191,36,.95)"; ctx.fillRect(sx+cell*0.3,sy+cell*0.3,cell*0.4,cell*0.4); }
      if(t==="chest" || t==="chestLocked"){
        ctx.fillStyle=(t==="chestLocked")?"rgba(251,113,133,.9)":"rgba(147,197,253,.9)";
        ctx.fillRect(sx+cell*0.25,sy+cell*0.35,cell*0.5,cell*0.35);
      }
      if(t==="doorLocked"){
        const door=d.doors[`${x},${y}`];
        ctx.fillStyle = door?.opened ? "rgba(52,211,153,.6)" : "rgba(251,191,36,.75)";
        ctx.fillRect(sx+cell*0.15,sy+cell*0.15,cell*0.7,cell*0.7);
      }

      const enemyHere=d.enemies.some(en=>en.x===x && en.y===y);
      if(enemyHere){
        ctx.beginPath();
        ctx.fillStyle="rgba(251,113,133,.9)";
        ctx.arc(sx+cell/2,sy+cell/2,Math.max(3,cell*0.18),0,Math.PI*2);
        ctx.fill();
      }
    }
  }

  const px=pad+d.px*cell+cell/2;
  const py=pad+d.py*cell+cell/2;
  ctx.beginPath();
  ctx.fillStyle="rgba(251,191,36,.95)";
  ctx.arc(px,py,Math.max(4,cell*0.22),0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="rgba(229,231,235,.9)";
  ctx.font="12px system-ui";
  ctx.fillText(`${d.kind==="forest"?"Forest":"Cave"} ‚Ä¢ Torches: ${state.torches} ‚Ä¢ Keys: ${state.keys}`, 14, 16);
}

function drawMap(){
  if(state.mode==="dungeon" || state.dungeonId) drawDungeon();
  else drawWorld();
}

/* ============================================================
   Hover + click + zoom + pan (world)
============================================================ */
function canvasPoint(evt){
  const rect = mapCanvas.getBoundingClientRect();
  return {x: evt.clientX-rect.left, y: evt.clientY-rect.top, rect};
}
function hitNodeWorld(wx,wy){
  for(const n of world.nodes){
    const dx=n.x-wx, dy=n.y-wy;
    if(Math.sqrt(dx*dx+dy*dy)<=22) return n;
  }
  return null;
}
function pointToSegmentDistance(p,a,b){
  const vx=b.x-a.x, vy=b.y-a.y;
  const wx=p.x-a.x, wy=p.y-a.y;
  const c1 = vx*wx + vy*wy;
  if(c1<=0) return Math.hypot(p.x-a.x,p.y-a.y);
  const c2 = vx*vx + vy*vy;
  if(c2<=c1) return Math.hypot(p.x-b.x,p.y-b.y);
  const t = c1/c2;
  const px=a.x+t*vx, py=a.y+t*vy;
  return Math.hypot(p.x-px,p.y-py);
}
function hitEdgeWorld(wx,wy){
  // approximate by checking endpoints (good enough for highlight)
  let best=null, bestDist=99999;
  for(const e of world.edges){
    const A=nodeById[e.a], B=nodeById[e.b];
    const dist = pointToSegmentDistance({x:wx,y:wy},{x:A.x,y:A.y},{x:B.x,y:B.y});
    if(dist<18 && dist<bestDist){ best=e; bestDist=dist; }
  }
  return best;
}

mapCanvas.addEventListener("mousemove",(evt)=>{
  if(state.mode!=="world") return;
  const {x,y}=canvasPoint(evt);
  const w=screenToWorld(x,y);
  const n=hitNodeWorld(w.x,w.y);
  const e=hitEdgeWorld(w.x,w.y);

  view.hoverNode=n;
  view.hoverEdge=e;

  if(n){
    tooltip.style.display="block";
    tooltip.style.left = `${x+14}px`;
    tooltip.style.top = `${y+14}px`;

    const neigh = neighbors(n.id);
    const fromHere = neighbors(state.currentNode).includes(n.id);
    const edge = edgeBetween(state.currentNode,n.id);
    const travelMin = edge ? travelTimeMinutes(state.currentNode,n.id) : null;

    const tt = terrainType(n.x,n.y);
    const tNice = tt==="woody" ? "woodland" : tt;

    tooltip.innerHTML = `
      <div><b>${n.name}</b> <span style="color:var(--muted)">(${n.type})</span></div>
      <div style="color:var(--muted);margin-top:4px">Terrain: <b>${tNice}</b></div>
      ${fromHere ? `<div style="color:var(--muted);margin-top:4px">From here: ${Math.round(travelMin)} min ‚Ä¢ ${edge.kind==="sea"?`Fare: ${edge.fare}g`:(edge.kind==="bridge"?"Bridge / Road":"Road")}</div>` : ""}
      <div style="color:var(--muted);margin-top:4px">Connected: ${neigh.map(id=>nodeById[id].name).slice(0,6).join(", ")}${neigh.length>6?"‚Ä¶":""}</div>
    `;
  } else if(e){
    tooltip.style.display="block";
    tooltip.style.left = `${x+14}px`;
    tooltip.style.top = `${y+14}px`;
    const A=nodeById[e.a], B=nodeById[e.b];
    const kind = e.kind==="sea" ? `Sea ‚Ä¢ Fare ${e.fare}g` : (e.kind==="bridge" ? "Bridge / Road" : "Road");
    tooltip.innerHTML = `<div><b>Route</b>: ${A.name} ‚Üî ${B.name}</div><div style="color:var(--muted)">${kind}</div>`;
  } else {
    tooltip.style.display="none";
  }

  drawMap();
});

mapCanvas.addEventListener("mouseleave",()=>{
  view.hoverNode=null;
  view.hoverEdge=null;
  tooltip.style.display="none";
  drawMap();
});

mapCanvas.addEventListener("mousedown",(evt)=>{
  if(state.mode!=="world") return;
  view.dragging=true;
  const {x,y}=canvasPoint(evt);
  view.dragStart={x,y,ox:view.ox,oy:view.oy};
});
window.addEventListener("mouseup",()=>{ view.dragging=false; });
window.addEventListener("mousemove",(evt)=>{
  if(!view.dragging || state.mode!=="world") return;
  const rect=mapCanvas.getBoundingClientRect();
  const x=evt.clientX-rect.left;
  const y=evt.clientY-rect.top;
  view.ox = view.dragStart.ox + (x-view.dragStart.x);
  view.oy = view.dragStart.oy + (y-view.dragStart.y);
  drawMap();
});

mapCanvas.addEventListener("wheel",(evt)=>{
  if(state.mode!=="world") return;
  evt.preventDefault();
  const {x,y}=canvasPoint(evt);
  const before = screenToWorld(x,y);
  const delta = Math.sign(evt.deltaY);
  const factor = (delta>0) ? 0.90 : 1.10;
  const next = clamp(view.scale*factor, view.minScale, view.maxScale);
  view.scale = next;
  const after = screenToWorld(x,y);
  view.ox += (after.x-before.x)*view.scale;
  view.oy += (after.y-before.y)*view.scale;
  drawMap();
},{passive:false});

mapCanvas.addEventListener("click",(evt)=>{
  if(state.mode!=="world") return;
  const {x,y}=canvasPoint(evt);
  const w=screenToWorld(x,y);
  const hit=hitNodeWorld(w.x,w.y);
  if(!hit) return;
  if(hit.id===state.currentNode) return;

  if(!canTravelTo(hit.id)){
    pushLog(`üö´ No route to ${hit.name}.`);
    render(); return;
  }
  travelTo(hit.id);
});

/* ============================================================
   BUTTONS + KEYBOARD
============================================================ */
$("areaLootBtn").addEventListener("click", useAreaLoot);
$("searchBtn").addEventListener("click", searchExplore);
$("sleepBtn").addEventListener("click", ()=>sleep(false));
$("eatBtn").addEventListener("click", eat);
$("questBoardBtn").addEventListener("click", openQuestBoard);
$("charBtn").addEventListener("click", openCharacterSheet);
$("buyFoodBtn").addEventListener("click", buyRation);
$("buyTorchBtn").addEventListener("click", buyTorch);

$("attackBtn").addEventListener("click", playerAttack);
$("fleeBtn").addEventListener("click", flee);

$("resetBtn").addEventListener("click", ()=>{
  localStorage.removeItem(SAVE_KEY);
  state = defaultState();
  pushLog("üßπ Save reset.");
  init(true);
});

window.addEventListener("resize", ()=>{ resizeCanvas(); drawMap(); render(); });

window.addEventListener("keydown",(e)=>{
  if(state.mode!=="dungeon" || state.mode==="combat") return;
  const k=e.key.toLowerCase();
  if(k==="w" || e.key==="ArrowUp"){ e.preventDefault(); dungeonMove(0,-1); }
  if(k==="s" || e.key==="ArrowDown"){ e.preventDefault(); dungeonMove(0,1); }
  if(k==="a" || e.key==="ArrowLeft"){ e.preventDefault(); dungeonMove(-1,0); }
  if(k==="d" || e.key==="ArrowRight"){ e.preventDefault(); dungeonMove(1,0); }
});

/* ============================================================
   CHARACTER CREATION + SHEET
============================================================ */
function rollStat4d6(){
  const dice=[roll(6),roll(6),roll(6),roll(6)].sort((a,b)=>a-b);
  return dice[1]+dice[2]+dice[3]; // drop lowest
}
function rollAllStats(){
  return {
    STR: rollStat4d6(),
    DEX: rollStat4d6(),
    CON: rollStat4d6(),
    INT: rollStat4d6(),
    WIS: rollStat4d6(),
    CHA: rollStat4d6()
  };
}
function openCharacterCreation(){
  const raceOptions = Object.keys(RACES).map(r=>`<option value="${r}" ${state.race===r?"selected":""}>${r}</option>`).join("");
  const classOptions = Object.keys(CLASSES).map(c=>`<option value="${c}" ${state.class===c?"selected":""}>${c}</option>`).join("");
  const sexOptions = ["Male","Female","Non-binary","Unspecified"].map(s=>`<option value="${s}" ${state.sex===s?"selected":""}>${s}</option>`).join("");

  const stats = state.stats;
  const eff = getEffectiveStats();

  const html = `
    <div class="panel">
      <div><b>Character Creation</b></div>
      <div class="muted" style="margin-top:6px">Choose race/sex/class, then roll stats (4d6 drop lowest). Stats affect combat and checks.</div>

      <div class="formGrid" style="margin-top:12px">
        <div>
          <label>Name</label>
          <input type="text" id="cc_name" value="${escapeHtml(state.name||"Adventurer")}" />
        </div>
        <div>
          <label>Race</label>
          <select id="cc_race">${raceOptions}</select>
          <div class="muted" style="margin-top:6px" id="cc_race_desc">${escapeHtml(RACES[state.race]?.desc||"")}</div>
        </div>
        <div>
          <label>Sex</label>
          <select id="cc_sex">${sexOptions}</select>
        </div>
        <div>
          <label>Class</label>
          <select id="cc_class">${classOptions}</select>
          <div class="muted" style="margin-top:6px" id="cc_class_desc">${escapeHtml(CLASSES[state.class]?.desc||"")}</div>
        </div>
        <div class="panel" style="grid-column:span 2">
          <div class="muted">Rerolls left: <b id="cc_rerolls">${state.rerollsLeft}</b></div>
          <div class="row" style="margin-top:10px">
            <button class="small" onclick="ccRollStats()">Roll Stats</button>
            <button class="small secondary" onclick="ccApply()">Save Character</button>
          </div>
          <div class="muted" style="margin-top:10px">Race modifiers apply after rolling (shown below).</div>
        </div>
      </div>

      <div class="statGrid">
        ${statCard("STR", stats.STR, eff.STR)}
        ${statCard("DEX", stats.DEX, eff.DEX)}
        ${statCard("CON", stats.CON, eff.CON)}
        ${statCard("INT", stats.INT, eff.INT)}
        ${statCard("WIS", stats.WIS, eff.WIS)}
        ${statCard("CHA", stats.CHA, eff.CHA)}
      </div>

      <div class="row" style="margin-top:12px">
        <span class="muted">Tip: Fighter uses STR, Rogue uses DEX, Mage uses INT, Cleric uses WIS.</span>
      </div>
    </div>
  `;
  openModal("üßæ Character", html);

  // wire change listeners for description updates
  setTimeout(()=>{
    const rSel = document.getElementById("cc_race");
    const cSel = document.getElementById("cc_class");
    if(rSel){
      rSel.addEventListener("change", ()=>{
        const r = rSel.value;
        document.getElementById("cc_race_desc").textContent = RACES[r]?.desc || "";
        // preview effective stats by temporarily applying race (no save)
        const tmpRace = state.race;
        state.race = r;
        openCharacterCreation(); // quick refresh
        state.race = tmpRace;
      });
    }
    if(cSel){
      cSel.addEventListener("change", ()=>{
        const c = cSel.value;
        document.getElementById("cc_class_desc").textContent = CLASSES[c]?.desc || "";
      });
    }
  },0);
}
function openCharacterSheet(){
  openCharacterCreation();
}
function statCard(key, base, eff){
  const bm = statMod(base);
  const em = statMod(eff);
  const delta = eff-base;
  const deltaTxt = delta===0 ? "" : (delta>0 ? ` <span style="color:var(--good)">(+${delta})</span>` : ` <span style="color:var(--bad)">(${delta})</span>`);
  return `
    <div class="statCell">
      <div class="k">${key}</div>
      <div class="v">${base}${deltaTxt}</div>
      <div class="m">Mod: ${bm>=0?"+":""}${bm} ‚Ä¢ Eff Mod: ${em>=0?"+":""}${em}</div>
    </div>
  `;
}
function ccRollStats(){
  if(state.rerollsLeft<=0){
    pushLog("üé≤ No rerolls left.");
    render();
    return;
  }
  state.rerollsLeft -= 1;
  state.stats = rollAllStats();
  computeDerived();
  openCharacterCreation();
  render();
}
function ccApply(){
  const name = document.getElementById("cc_name")?.value?.trim() || "Adventurer";
  const race = document.getElementById("cc_race")?.value || "Human";
  const sex  = document.getElementById("cc_sex")?.value || "Unspecified";
  const cls  = document.getElementById("cc_class")?.value || "Fighter";

  state.name = name;
  state.race = race;
  state.sex = sex;
  state.class = cls;
  state.characterCreated = true;

  computeDerived();
  closeModal();
  pushLog(`<span style="color:var(--good)">üßæ Character saved:</span> <b>${escapeHtml(state.name)}</b> ‚Äî ${state.race} ${state.class}.`);
  render();
}
function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, s => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[s]));
}

/* ============================================================
   RENDER UI
============================================================ */
function render(){
  computeDerived();

  $("hp").textContent=state.hp;
  $("hpMax").textContent=state.hpMax;
  $("atk").textContent=getAtk();
  $("def").textContent=getDef();
  $("energy").textContent=state.energy;
  $("energyMax").textContent=state.energyMax;
  $("hunger").textContent=state.hunger;

  $("gold").textContent=state.gold;
  $("keys").textContent=state.keys;
  $("rationCount").textContent=countItem("food");
  $("clockBadge").textContent = `Day ${state.day} ‚Ä¢ ${fmtTime(state.minutes)}`;

  $("level").textContent = state.level;
  $("xp").textContent = state.xp;
  $("xpNext").textContent = xpToNext(state.level);

  $("charName").textContent = state.name || "Adventurer";
  $("charRace").textContent = state.race || "Human";
  $("charSex").textContent = state.sex || "Unspecified";
  $("charClass").textContent = state.class || "Fighter";

  const eff=getEffectiveStats();
  const modsLine = `Mods: STR ${fmtMod(eff.STR)} ‚Ä¢ DEX ${fmtMod(eff.DEX)} ‚Ä¢ CON ${fmtMod(eff.CON)} ‚Ä¢ INT ${fmtMod(eff.INT)} ‚Ä¢ WIS ${fmtMod(eff.WIS)} ‚Ä¢ CHA ${fmtMod(eff.CHA)}`;
  $("charModsLine").textContent = modsLine;

  $("modeBadge").textContent =
    state.mode==="combat" ? "Mode: Combat" :
    state.mode==="dungeon" ? `Mode: ${(currentDungeon()?.kind==="forest")?"Forest":"Cave"}` :
    "Mode: World";
  $("locBadge").textContent = `Location: ${nodeById[state.currentNode]?.name || "‚Äî"}`;

  $("areaLootBtn").disabled = (state.mode!=="world") || !areaLootAvailable();
  $("searchBtn").disabled = (state.mode==="combat");
  $("sleepBtn").disabled = !canSleepHere() || (state.mode==="combat");
  $("eatBtn").disabled = (countItem("food")<=0) || (state.mode==="combat");
  $("buyFoodBtn").disabled = !canBuyHere();
  $("buyTorchBtn").disabled = !canBuyHere();
  $("questBoardBtn").disabled = !(state.mode==="world" && canBuyHere());

  $("combatRow").style.display = (state.mode==="combat") ? "flex" : "none";
  $("enemyPanel").style.display = (state.mode==="combat" && state.enemy) ? "block" : "none";
  if(state.enemy){
    $("enemyName").textContent=state.enemy.name;
    $("enemyHp").textContent=Math.max(0,state.enemy.hp);
    $("enemyAC").textContent=state.enemy.ac;
  }

  $("weaponSlot").innerHTML = `
    <strong>Weapon</strong>
    <div class="itemName">${state.weapon ? fmtItem(state.weapon) : "None"}</div>
    <div>${state.weapon ? `<button class="small secondary" onclick="unequip('weapon')">Unequip</button>` : ""}</div>
  `;
  $("armorSlot").innerHTML = `
    <strong>Armor</strong>
    <div class="itemName">${state.armor ? fmtItem(state.armor) : "None"}</div>
    <div>${state.armor ? `<button class="small secondary" onclick="unequip('armor')">Unequip</button>` : ""}</div>
  `;
  $("accessorySlot").innerHTML = `
    <strong>Accessory</strong>
    <div class="itemName">${state.accessory ? fmtItem(state.accessory) : "None"}</div>
    <div>${state.accessory ? `<button class="small secondary" onclick="unequip('accessory')">Unequip</button>` : ""}</div>
  `;

  // bag
  $("bag").innerHTML="";
  if(state.bag.length===0){
    const empty=document.createElement("div");
    empty.className="itemCard";
    empty.style.gridColumn="1/-1";
    empty.innerHTML=`<div class="meta">Backpack empty.</div>`;
    $("bag").appendChild(empty);
  } else {
    state.bag.forEach((item,i)=>{
      const d=document.createElement("div");
      d.className="itemCard";
      if(item.type==="consumable"){
        const isFood = item.kind==="food";
        const isHeal = item.kind==="heal";
        d.innerHTML=`
          <div><b>${item.name}</b> √ó ${item.qty||1}</div>
          <div class="meta">CONSUMABLE</div>
          ${
            isFood ? `<button class="small" onclick="eat()">Eat</button>` :
            isHeal ? `<button class="small" onclick="usePoultice()">Use</button>` :
            `<button class="small secondary" disabled>Use</button>`
          }
        `;
      } else if(item.type==="quest"){
        d.innerHTML=`
          <div><b>${item.name}</b></div>
          <div class="meta">QUEST ITEM</div>
          <button class="small secondary" disabled>Cannot drop</button>
        `;
      } else {
        d.innerHTML=`
          <div><b>${item.name}</b></div>
          <div class="meta">${item.type.toUpperCase()} ‚Ä¢ ${item.atk?`+${item.atk} ATK `:""}${item.def?`+${item.def} DEF`:""}</div>
          <button class="small" onclick="equipFromBag(${i})">Equip</button>
        `;
      }
      $("bag").appendChild(d);
    });
  }

  // log
  $("log").innerHTML = state.log.map(x=>`<div>${x}</div>`).join("");
  $("log").scrollTop = $("log").scrollHeight;

  // interact panel
  buildInteractOptions();

  // map
  drawMap();

  save();
}

function fmtMod(v){
  const m=statMod(v);
  return `${m>=0?"+":""}${m}`;
}

/* ============================================================
   INIT
============================================================ */
function init(resetLog=false){
  resizeCanvas();

  // build terrain + world once per load
  buildTerrain();
  buildWorld();

  // sanity
  if(!nodeById[state.currentNode]) state.currentNode="capital_aurelia";
  if(!nodeById[state.lastSafeNode]) state.lastSafeNode="capital_aurelia";

  // stamp current node visit if missing
  state.nodeVisitStamp[state.currentNode] = state.nodeVisitStamp[state.currentNode] || state.visitCounter;

  if(state.log.length===0 || resetLog){
    state.log=[];
    pushLog("üß≠ Welcome to the Kingdoms build!");
    pushLog("üó∫Ô∏è Huge world map: terrain regions, curved roads/sea lanes, bridges, and a capital kingdom.");
    pushLog("üèôÔ∏è In towns/cities: visit Inn, Tavern, Shop, Church, Library, Guild.");
    pushLog("üï≥Ô∏è Caves/forests persist: opened chests/enemies stay cleared when you return.");
    pushLog("üßæ Open Character to roll stats and choose race/sex/class ‚Äî stats affect checks and combat.");
  }

  // day drain init
  if(!state.energyDrainToday) startNewDay();

  // center view on current node at start
  softCenterOnNode(state.currentNode);

  // force character creation if not done
  if(!state.characterCreated){
    // give them a good first roll if empty
    if(state.rerollsLeft===3 && state.stats.STR===10 && state.stats.DEX===10){
      state.stats = rollAllStats();
      computeDerived();
    }
    openCharacterCreation();
  }

  render();
}

init();
</script>
</body>
</html>
