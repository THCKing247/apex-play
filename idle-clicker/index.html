<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Apex Dice RPG</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
:root{
  --bg0:#070b1a;
  --bg1:#0b1026;
  --accent:#7c5cff;
  --card:rgba(255,255,255,.08);
  --border:rgba(255,255,255,.14);
  --text:#e5e7eb;
  --muted:#9ca3af;
  --good:#34d399;
  --bad:#fb7185;
  --warn:#fbbf24;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  background:
    radial-gradient(1200px 600px at 60% -10%, #7c5cff55, transparent 60%),
    linear-gradient(180deg,var(--bg0),var(--bg1));
  color:var(--text);
  min-height:100vh;
}
.wrap{max-width:1400px;margin:auto;padding:26px}
h1{margin:0 0 6px;font-size:34px}
p{margin:0 0 16px;color:var(--muted)}
.card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:20px;
  padding:18px;
  backdrop-filter:blur(14px);
  box-shadow:0 30px 80px rgba(0,0,0,.35);
}
.grid{display:grid;grid-template-columns:1fr 460px;gap:18px;align-items:start}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
button{
  background:linear-gradient(135deg,#7c5cff,#5f4cff);
  border:none;color:#fff;
  padding:12px 16px;border-radius:12px;cursor:pointer;
  font-size:15px;
}
button.secondary{
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
}
button.small{
  font-size:12px;
  padding:8px 10px;
  border-radius:10px;
}
button:disabled{opacity:.45;cursor:not-allowed}
.badge{
  display:inline-flex;align-items:center;gap:8px;
  padding:6px 10px;border-radius:999px;
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  color:var(--muted);
  font-size:12px;
}
.kv{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:10px;
  margin-top:10px;
}
.tile{
  background:rgba(0,0,0,.30);
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:10px;
  text-align:center;
}
.tile strong{font-size:18px}
.sub{color:var(--muted);font-size:12px;margin-top:6px}
.log{
  background:rgba(0,0,0,.4);
  border-radius:14px;
  padding:12px;
  height:230px;
  overflow:auto;
  font-size:14px;
}
hr{border:none;border-top:1px solid var(--border);margin:14px 0}

/* Map */
.mapWrap{display:grid;grid-template-columns:1fr;gap:12px}
.mapTitle{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.mapCanvas{
  width:100%;
  height:460px;
  border-radius:16px;
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  overflow:hidden;
  position:relative;
}
.mapCanvas canvas{width:100%;height:100%;display:block}
.hint{color:var(--muted);font-size:12px}

/* Inventory */
.inventory{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
.slot{
  background:rgba(0,0,0,.35);
  border:1px dashed var(--border);
  border-radius:14px;
  padding:10px;
  min-height:82px;
  text-align:center;
  font-size:14px;
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  gap:8px;
}
.slot strong{display:block;font-size:12px;color:var(--muted)}
.slot .itemName{line-height:1.2}
.bagGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:10px}
.itemCard{
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  border-radius:14px;
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:98px;
}
.itemCard .meta{font-size:12px;color:var(--muted)}

/* Modal */
.overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.55);
  display:none;
  align-items:center;
  justify-content:center;
  padding:18px;
  z-index:50;
}
.modal{
  width:min(760px, 96vw);
  background:rgba(15,18,40,.92);
  border:1px solid var(--border);
  border-radius:18px;
  padding:16px;
  box-shadow:0 40px 120px rgba(0,0,0,.55);
}
.modal .top{display:flex;justify-content:space-between;align-items:center;gap:10px}
.modal h3{margin:0}
.modal p{margin:6px 0 0;color:var(--muted)}
kbd{
  font-family:ui-monospace,SFMono-Regular,Menlo,monospace;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.15);
  padding:2px 6px;
  border-radius:6px;
  color:var(--text);
  font-size:12px;
}
</style>
</head>

<body>
<div class="wrap">
  <h1>üé≤ Apex Dice RPG</h1>
  <p>Explore a coastal region, pay fares for sea routes, delve into caves/forests with fog-of-war, open chests, and complete delivery quests.</p>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="mapWrap">
        <div class="mapTitle">
          <div class="row">
            <span class="badge" id="modeBadge">Mode: Exploring</span>
            <span class="badge" id="locBadge">Location: ‚Äî</span>
            <span class="badge" id="areaBadge">Area Loot: Available</span>
          </div>
          <div class="row">
            <button class="secondary" id="areaLootBtn">Area Loot</button>
            <button class="secondary" id="searchBtn">Search / Explore</button>
            <button class="secondary" id="sleepBtn">Sleep</button>
            <button class="secondary" id="eatBtn">Eat (Ration)</button>
          </div>
          <div class="hint">
            World: click connected locations ‚Ä¢ Dungeon: move with <kbd>WASD</kbd>/<kbd>‚Üë‚Üì‚Üê‚Üí</kbd>
          </div>
        </div>

        <div class="mapCanvas">
          <canvas id="map"></canvas>
        </div>

        <!-- Combat buttons appear only in combat -->
        <div class="row" id="combatRow" style="display:none;margin-top:6px">
          <button id="attackBtn">Attack (d20)</button>
          <button class="secondary" id="fleeBtn">Flee</button>
        </div>

        <div id="enemyPanel" style="display:none;margin-top:6px">
          <span class="badge">Enemy: <b id="enemyName"></b> ‚Ä¢ HP <b id="enemyHp"></b> ‚Ä¢ AC <b id="enemyAC"></b></span>
        </div>

        <hr>

        <h3 style="margin:0 0 8px">Log</h3>
        <div class="log" id="log"></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <h2 style="margin:0">Player</h2>

      <div class="kv">
        <div class="tile">‚ù§Ô∏è HP<br><strong id="hp">20</strong><div class="sub">Max <span id="hpMax">20</span></div></div>
        <div class="tile">‚öîÔ∏è ATK<br><strong id="atk">2</strong><div class="sub">Base + Gear</div></div>
        <div class="tile">üõ°Ô∏è DEF<br><strong id="def">1</strong><div class="sub">Base + Gear</div></div>
        <div class="tile">‚ö° Energy<br><strong id="energy">10</strong><div class="sub">Max <span id="energyMax">10</span></div></div>
      </div>

      <div class="kv" style="margin-top:10px">
        <div class="tile" style="grid-column:span 2">üçó Hunger<br>
          <strong id="hunger">10</strong>
          <div class="sub">0 = starving (HP drain on actions)</div>
        </div>
        <div class="tile" style="grid-column:span 2">üìú Quest<br>
          <strong id="questTitle">None</strong>
          <div class="sub" id="questSub">Pick one up in town.</div>
        </div>
      </div>

      <h3 style="margin:18px 0 10px">Equipment</h3>
      <div class="inventory">
        <div class="slot" id="weaponSlot"></div>
        <div class="slot" id="armorSlot"></div>
        <div class="slot" id="accessorySlot"></div>
        <div class="slot">
          <strong>Gold</strong>
          <div class="itemName"><span id="gold">0</span></div>
          <div></div>
        </div>
      </div>

      <h3 style="margin:18px 0 10px">Backpack</h3>
      <div class="bagGrid" id="bag"></div>

      <hr>
      <div class="row">
        <button class="secondary" id="buyFoodBtn">Buy Ration (5g)</button>
        <button class="secondary" id="resetBtn">Reset Save</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="overlay" id="overlay">
  <div class="modal">
    <div class="top">
      <h3 id="modalTitle">Notice</h3>
      <button class="secondary small" id="closeModal">Close</button>
    </div>
    <p id="modalBody"></p>
  </div>
</div>

<script>
/* =========================
   SAVE + STATE
========================= */
const SAVE_KEY = "apexDiceRpg_v3";

const defaultState = () => ({
  // stats
  hp: 20, hpMax: 20,
  energy: 10, energyMax: 10,
  hunger: 10, hungerMax: 10,

  atkBase: 2,
  defBase: 1,

  gold: 15,

  // equipment
  weapon: null,
  armor: null,
  accessory: null,

  // items
  bag: [
    {type:"consumable", name:"Ration", kind:"food", qty:2}
  ],

  // gameplay
  mode: "world", // world | dungeon | combat
  currentNode: "stonehaven",
  lastSafeNode: "stonehaven",

  // per-visit loot limiting
  visitCounter: 1,
  nodeVisitStamp: {},     // nodeId -> last stamp entered
  nodeLootStamp: {},      // nodeId -> stamp when area loot used

  // dungeon
  dungeon: {
    kind: null,      // "cave" | "forest"
    id: null,        // node id
    w: 22, h: 14,
    tiles: [],       // wall/floor/entrance/exit/chest/chestLocked/key/doorLocked
    seen: [],
    px: 2, py: 2,
    enemies: [],     // {x,y,type,hp,ac,atk}
    chests: {},      // "x,y" -> {locked:boolean, opened:boolean, contents:[]}
    keysOnGround: {},// "x,y" -> {taken:boolean}
    doors: {},       // "x,y" -> {locked:boolean, opened:boolean}
  },

  // combat
  enemy: null,      // {name,hp,hpMax,ac,atk,tag,origin}
  enemyPos: null,   // {x,y} if from dungeon

  // quest
  quest: null,      // {id,title,from,to,itemName,rewardGold,rewardKey,accepted}
  questDelivered: false,

  log: []
});

let state = JSON.parse(localStorage.getItem(SAVE_KEY) || "null") || defaultState();

/* =========================
   DOM helpers
========================= */
const $ = id => document.getElementById(id);
const mapCanvas = $("map");
const ctx = mapCanvas.getContext("2d");
function save(){ localStorage.setItem(SAVE_KEY, JSON.stringify(state)); }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function roll(s){ return Math.floor(Math.random()*s)+1; }
function pushLog(msg){
  state.log.push(msg);
  if(state.log.length>300) state.log = state.log.slice(-300);
}

/* =========================
   WORLD MAP (land + sea)
========================= */
const world = {
  nodes: [
    { id:"stonehaven", name:"Stonehaven", type:"town", x:140, y:210, land:true },
    { id:"pinewatch",  name:"Pinewatch",  type:"camp", x:290, y:135, land:true },
    { id:"emberrest",  name:"Emberrest",  type:"town", x:330, y:310, land:true },
    { id:"redfen",     name:"Redfen",     type:"camp", x:470, y:265, land:true },
    { id:"grandport",  name:"Grandport",  type:"port", x:640, y:170, land:true },

    { id:"cave_mourn", name:"Mournroot Cave", type:"cave", x:520, y:380, land:true, dungeonKind:"cave" },
    { id:"cave_salt",  name:"Saltwind Grotto", type:"cave", x:720, y:330, land:true, dungeonKind:"cave" },

    { id:"forest_gloom", name:"Gloamwood", type:"forest", x:250, y:395, land:true, dungeonKind:"forest" },
    { id:"forest_briar", name:"Briarwild", type:"forest", x:410, y:120, land:true, dungeonKind:"forest" },
  ],
  edges: [
    // land roads
    {a:"stonehaven", b:"pinewatch", kind:"road", costEnergy:1},
    {a:"stonehaven", b:"emberrest", kind:"road", costEnergy:1},
    {a:"pinewatch", b:"emberrest",  kind:"road", costEnergy:1},
    {a:"emberrest", b:"redfen",     kind:"road", costEnergy:1},
    {a:"redfen", b:"grandport",     kind:"road", costEnergy:1},
    {a:"redfen", b:"cave_mourn",    kind:"road", costEnergy:1},
    {a:"emberrest", b:"forest_gloom", kind:"road", costEnergy:1},
    {a:"pinewatch", b:"forest_briar", kind:"road", costEnergy:1},

    // sea routes (fare required)
    {a:"stonehaven", b:"grandport", kind:"sea", fare:8, costEnergy:2},
    {a:"grandport",  b:"cave_salt", kind:"sea", fare:6, costEnergy:2},
    {a:"cave_mourn", b:"cave_salt", kind:"sea", fare:5, costEnergy:2},
  ]
};
const nodeById = Object.fromEntries(world.nodes.map(n=>[n.id,n]));

function edgeBetween(a,b){
  return world.edges.find(e => (e.a===a && e.b===b) || (e.a===b && e.b===a));
}
function neighbors(id){
  return world.edges
    .filter(e=>e.a===id || e.b===id)
    .map(e=> (e.a===id? e.b : e.a));
}

/* =========================
   Stats (derived)
========================= */
function getAtk(){
  return state.atkBase + (state.weapon?.atk||0) + (state.accessory?.atk||0);
}
function getDef(){
  return state.defBase + (state.armor?.def||0) + (state.accessory?.def||0);
}

/* =========================
   Hunger/Energy costs
========================= */
function spendEnergy(amount, reason){
  if(state.energy < amount){
    pushLog(`‚ö° Not enough energy to ${reason}.`);
    return false;
  }
  state.energy -= amount;
  return true;
}
function spendHunger(amount){
  state.hunger = clamp(state.hunger - amount, 0, state.hungerMax);
}
function starvingPenalty(){
  if(state.hunger===0){
    state.hp = clamp(state.hp - 1, 0, state.hpMax);
    pushLog(`<span style="color:var(--warn)">üçó Starving: you lose 1 HP.</span>`);
  }
}
function actionTick({energyCost=0, hungerCost=1, reason="act"}){
  if(energyCost>0 && !spendEnergy(energyCost, reason)) return false;
  spendHunger(hungerCost);
  starvingPenalty();
  return true;
}

/* =========================
   Inventory helpers (stack consumables)
========================= */
function addToBag(item){
  if(item.type==="consumable"){
    const found = state.bag.find(x=>x.type==="consumable" && x.kind===item.kind && x.name===item.name);
    if(found){ found.qty += item.qty||1; return; }
  }
  state.bag.push(item);
}
function countItem(kind){
  return state.bag
    .filter(x=>x.type==="consumable" && x.kind===kind)
    .reduce((s,x)=>s+(x.qty||1),0);
}
function consumeItem(kind, qty=1){
  for(const item of state.bag){
    if(item.type==="consumable" && item.kind===kind){
      const take = Math.min(qty, item.qty||1);
      item.qty = (item.qty||1) - take;
      qty -= take;
      if(item.qty<=0) item._remove = true;
      if(qty<=0) break;
    }
  }
  state.bag = state.bag.filter(x=>!x._remove);
  return qty===0;
}

/* =========================
   Equipment (no stacking)
========================= */
function fmtItem(item){
  if(!item) return "None";
  const parts=[];
  if(item.atk) parts.push(`+${item.atk} ATK`);
  if(item.def) parts.push(`+${item.def} DEF`);
  return parts.length ? `${item.name} (${parts.join(", ")})` : item.name;
}
function equipFromBag(index){
  const item = state.bag[index];
  if(!item || item.type==="consumable") return;
  state.bag.splice(index,1);

  if(item.type==="weapon"){
    if(state.weapon) state.bag.push(state.weapon);
    state.weapon=item;
    pushLog(`üß© Equipped Weapon: <b>${fmtItem(item)}</b>`);
  }
  if(item.type==="armor"){
    if(state.armor) state.bag.push(state.armor);
    state.armor=item;
    pushLog(`üß© Equipped Armor: <b>${fmtItem(item)}</b>`);
  }
  if(item.type==="accessory"){
    if(state.accessory) state.bag.push(state.accessory);
    state.accessory=item;
    pushLog(`üß© Equipped Accessory: <b>${fmtItem(item)}</b>`);
  }
  render();
}
function unequip(slot){
  if(slot==="weapon" && state.weapon){ state.bag.push(state.weapon); pushLog(`üì¶ Unequipped Weapon: <b>${fmtItem(state.weapon)}</b>`); state.weapon=null; }
  if(slot==="armor" && state.armor){ state.bag.push(state.armor); pushLog(`üì¶ Unequipped Armor: <b>${fmtItem(state.armor)}</b>`); state.armor=null; }
  if(slot==="accessory" && state.accessory){ state.bag.push(state.accessory); pushLog(`üì¶ Unequipped Accessory: <b>${fmtItem(state.accessory)}</b>`); state.accessory=null; }
  render();
}

/* =========================
   Limited "Area Loot" per visit
========================= */
function enterNode(nodeId){
  state.currentNode = nodeId;

  // increment visit counter and stamp this node
  state.visitCounter += 1;
  state.nodeVisitStamp[nodeId] = state.visitCounter;

  // towns/camps = safe save point
  const n = nodeById[nodeId];
  if(n.type==="town" || n.type==="camp" || n.type==="port"){
    state.lastSafeNode = nodeId;
  }

  // Quest checks
  checkQuestProgress();

  // auto prompt to enter dungeon for cave/forest
  if((n.type==="cave" || n.type==="forest") && state.mode!=="combat"){
    openModal(
      `${n.type==="cave"?"Cave Entrance":"Forest Edge"}`,
      `You arrive at <b>${n.name}</b>.<br><br>
       <button class="small" onclick="enterDungeon('${nodeId}')">Enter</button>
       <button class="small secondary" onclick="closeModal()">Stay Outside</button>`
    );
  }
}

function areaLootAvailable(){
  const stamp = state.nodeVisitStamp[state.currentNode] || 0;
  const used  = state.nodeLootStamp[state.currentNode] || 0;
  return used !== stamp;
}
function useAreaLoot(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't loot during combat."); render(); return; }
  if(!areaLootAvailable()){
    pushLog("üß∫ Area loot already used for this visit.");
    render();
    return;
  }

  // costs energy + hunger
  if(!actionTick({energyCost:1, hungerCost:1, reason:"loot"})) { render(); return; }

  // mark used
  state.nodeLootStamp[state.currentNode] = state.nodeVisitStamp[state.currentNode];

  // outcomes based on location type
  const n = nodeById[state.currentNode];
  let r = roll(100);

  if(n.type==="town" || n.type==="port"){
    // towns: small gold or ration
    if(r<=50){ const g=roll(6)+2; state.gold+=g; pushLog(`üß∫ You rummage around and find <b>${g}</b> gold.`); }
    else { addToBag({type:"consumable", name:"Ration", kind:"food", qty:1}); pushLog("üß∫ Found <b>1 Ration</b>."); }
  } else if(n.type==="camp"){
    if(r<=45){ addToBag({type:"consumable", name:"Ration", kind:"food", qty:1}); pushLog("üß∫ Camp supplies: <b>1 Ration</b>."); }
    else { const item = randomGear(); state.bag.push(item); pushLog(`üß∫ Found gear: <b>${fmtItem(item)}</b>.`); }
  } else {
    // wild nodes
    if(r<=35){ const g=roll(10)+4; state.gold+=g; pushLog(`üß∫ Found <b>${g}</b> gold.`); }
    else { const item = randomGear(); state.bag.push(item); pushLog(`üß∫ Found <b>${fmtItem(item)}</b>.`); }
  }

  // small encounter chance from looting (not in combat)
  if(state.mode!=="combat" && roll(100)<=12){
    startCombat(makeEnemy("ambush"), {origin:"world"});
  }

  render();
}

/* =========================
   Travel rules (energy + hunger; sea fare + risks)
========================= */
function canTravelTo(toId){
  if(state.mode!=="world") return false;
  const e = edgeBetween(state.currentNode,toId);
  return !!e;
}

function travelTo(toId){
  if(state.mode!=="world") return;
  const e = edgeBetween(state.currentNode,toId);
  if(!e){ pushLog("üö´ No route."); render(); return; }

  // travel costs energy/hunger (combat does not)
  const energyCost = e.costEnergy || 1;
  if(!actionTick({energyCost, hungerCost:1, reason:"travel"})){ render(); return; }

  // sea fare requirement
  if(e.kind==="sea"){
    const fare = e.fare || 0;
    if(state.gold < fare){
      // refund energy cost since travel didn't happen
      state.energy = clamp(state.energy + energyCost, 0, state.energyMax);
      pushLog(`‚õ¥Ô∏è Fare required: ${fare} gold. You only have ${state.gold}.`);
      render(); return;
    }
    state.gold -= fare;
    pushLog(`‚õ¥Ô∏è Paid fare <b>${fare}g</b> to travel over water.`);
  }

  const from = nodeById[state.currentNode];
  const to = nodeById[toId];

  // sea travel risks
  if(e.kind==="sea"){
    // fall into water chance
    if(roll(100)<=15){
      pushLog(`<span style="color:var(--warn)">üåä Rough waters! You slip and fall into the sea.</span>`);
      state.hp = clamp(state.hp - (roll(4)+1), 0, state.hpMax);
      // lose a ration sometimes
      if(countItem("food")>0 && roll(100)<=35){
        consumeItem("food",1);
        pushLog(`<span style="color:var(--warn)">üçó You lose a ration to the waves.</span>`);
      }
      if(state.hp<=0){
        state.hp=1;
        pushLog(`<b style="color:var(--bad)">‚ò†Ô∏è You nearly drown and wash ashore at your last safe location.</b>`);
        enterNode(state.lastSafeNode);
        render();
        return;
      }
    }

    // water combat chance (pirates/sea creatures)
    if(roll(100)<=28){
      const type = (roll(100)<=55) ? "pirates" : "sea";
      startCombat(makeEnemy(type), {origin:"sea"});
      // still move location after combat ends? keep it simple:
      // travel completes immediately, encounter occurs en route (combat happens before arrival)
      state.pendingArrival = toId;
      pushLog(`‚öì Combat triggered en route to <b>${to.name}</b>.`);
      render();
      return;
    }
  } else {
    // land road encounter chance
    if(roll(100)<=18){
      startCombat(makeEnemy("road"), {origin:"road"});
      state.pendingArrival = toId;
      pushLog(`‚ö†Ô∏è Encounter on the road toward <b>${to.name}</b>.`);
      render();
      return;
    }
  }

  // no encounter: arrive
  pushLog(`üß≠ Traveled from <b>${from.name}</b> to <b>${to.name}</b>.`);
  enterNode(toId);
  render();
}

/* =========================
   Dungeon (Caves + Forests)
   - unique layouts per dungeon id
   - fog-of-war
   - manual WASD movement
   - enemies placed on map (not random)
   - chests + locked chests + keys + locked doors
========================= */
function makeRNG(seedStr){
  // xorshift-ish seeded rng for repeatable layouts per dungeon id
  let h = 2166136261;
  for(let i=0;i<seedStr.length;i++){ h ^= seedStr.charCodeAt(i); h = Math.imul(h, 16777619); }
  let s = h >>> 0;
  return function(){
    s ^= s << 13; s >>>= 0;
    s ^= s >> 17; s >>>= 0;
    s ^= s << 5;  s >>>= 0;
    return (s >>> 0) / 4294967296;
  };
}

function generateDungeon(kind, id){
  const rng = makeRNG(kind+"::"+id);
  const w = state.dungeon.w, h = state.dungeon.h;

  // cellular automata style generation
  let grid = Array.from({length:h}, ()=>Array.from({length:w}, ()=> (rng()< (kind==="forest"?0.47:0.50) ? "wall" : "floor")));

  // borders walls
  for(let y=0;y<h;y++){ grid[y][0]="wall"; grid[y][w-1]="wall"; }
  for(let x=0;x<w;x++){ grid[0][x]="wall"; grid[h-1][x]="wall"; }

  function countWalls(x,y){
    let c=0;
    for(let yy=y-1; yy<=y+1; yy++){
      for(let xx=x-1; xx<=x+1; xx++){
        if(xx===x && yy===y) continue;
        if(yy<0||xx<0||yy>=h||xx>=w){ c++; continue; }
        if(grid[yy][xx]==="wall") c++;
      }
    }
    return c;
  }

  // smooth
  const iters = kind==="forest"?5:6;
  for(let i=0;i<iters;i++){
    const next = grid.map(row=>row.slice());
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const walls = countWalls(x,y);
        if(walls>=5) next[y][x]="wall";
        else next[y][x]="floor";
      }
    }
    grid = next;
  }

  // pick entrance and exit on floor
  function randomFloor(){
    for(let t=0;t<2000;t++){
      const x = 1 + Math.floor(rng()*(w-2));
      const y = 1 + Math.floor(rng()*(h-2));
      if(grid[y][x]==="floor") return {x,y};
    }
    return {x:2,y:2};
  }
  const entrance = randomFloor();
  const exit = randomFloor();

  grid[entrance.y][entrance.x] = "entrance";
  grid[exit.y][exit.x] = "exit";

  // seen array
  const seen = Array.from({length:h}, ()=>Array.from({length:w}, ()=>false));

  // place keys, locked door, chests, enemies
  const chests = {};
  const keysOnGround = {};
  const doors = {};
  const enemies = [];

  // place one locked door somewhere on a corridor tile
  let doorPos = null;
  for(let tries=0; tries<1200; tries++){
    const p = randomFloor();
    if(Math.abs(p.x-entrance.x)+Math.abs(p.y-entrance.y) < 6) continue;
    if(Math.abs(p.x-exit.x)+Math.abs(p.y-exit.y) < 6) continue;
    doorPos = p; break;
  }
  if(doorPos){
    grid[doorPos.y][doorPos.x] = "doorLocked";
    doors[`${doorPos.x},${doorPos.y}`] = {locked:true, opened:false};
  }

  // place a key
  let keyPos = null;
  for(let tries=0; tries<1200; tries++){
    const p = randomFloor();
    if(doorPos && (p.x===doorPos.x && p.y===doorPos.y)) continue;
    if(Math.abs(p.x-entrance.x)+Math.abs(p.y-entrance.y) < 4) continue;
    keyPos = p; break;
  }
  if(keyPos){
    grid[keyPos.y][keyPos.x] = "key";
    keysOnGround[`${keyPos.x},${keyPos.y}`] = {taken:false};
  }

  // chests (some locked)
  const chestCount = kind==="forest"?3:4;
  for(let i=0;i<chestCount;i++){
    let p = null;
    for(let tries=0; tries<1400; tries++){
      const c = randomFloor();
      const k = `${c.x},${c.y}`;
      if(grid[c.y][c.x] !== "floor") continue;
      if(Math.abs(c.x-entrance.x)+Math.abs(c.y-entrance.y) < 5) continue;
      if(chests[k]) continue;
      p=c; break;
    }
    if(!p) continue;

    const locked = (rng()<0.45);
    grid[p.y][p.x] = locked ? "chestLocked" : "chest";
    chests[`${p.x},${p.y}`] = {locked, opened:false, contents: dungeonChestContents(rng)};
  }

  // enemies placed as markers on floor
  const enemyCount = kind==="forest"?6:5;
  const enemyTypes = kind==="forest" ? ["Wolf","Bandit","Boar","Warg"] : ["Goblin","Bandit","Cultist","Slime"];
  for(let i=0;i<enemyCount;i++){
    let p=null;
    for(let tries=0; tries<1600; tries++){
      const c = randomFloor();
      if(grid[c.y][c.x] !== "floor") continue;
      if(Math.abs(c.x-entrance.x)+Math.abs(c.y-entrance.y) < 4) continue;
      if(chests[`${c.x},${c.y}`]) continue;
      if(keysOnGround[`${c.x},${c.y}`]) continue;
      if(doors[`${c.x},${c.y}`]) continue;
      if(enemies.some(e=>e.x===c.x && e.y===c.y)) continue;
      p=c; break;
    }
    if(!p) continue;

    const t = enemyTypes[Math.floor(rng()*enemyTypes.length)];
    enemies.push(makeDungeonEnemy(t, p.x, p.y));
  }

  return {tiles:grid, seen, px:entrance.x, py:entrance.y, chests, keysOnGround, doors, enemies, entrance, exit};
}

function dungeonChestContents(rng){
  const contents = [];
  // always some gold
  contents.push({type:"gold", amount: 8 + Math.floor(rng()*18)});
  // chance gear
  if(rng()<0.70) contents.push({type:"gear", item: randomGearFromRng(rng)});
  // chance ration
  if(rng()<0.55) contents.push({type:"consumable", item:{type:"consumable", name:"Ration", kind:"food", qty:1}});
  // chance key
  if(rng()<0.25) contents.push({type:"key", amount:1});
  return contents;
}

function randomGear(){
  const table = [
    {type:"weapon", name:"Sword", atk:2},
    {type:"weapon", name:"Dagger", atk:1},
    {type:"weapon", name:"Warhammer", atk:3},
    {type:"armor", name:"Leather Armor", def:2},
    {type:"armor", name:"Chain Shirt", def:3},
    {type:"accessory", name:"Ring of Luck", atk:1},
    {type:"accessory", name:"Amulet of Guarding", def:1},
  ];
  return table[Math.floor(Math.random()*table.length)];
}
function randomGearFromRng(rng){
  const table = [
    {type:"weapon", name:"Sword", atk:2},
    {type:"weapon", name:"Dagger", atk:1},
    {type:"weapon", name:"Warhammer", atk:3},
    {type:"armor", name:"Leather Armor", def:2},
    {type:"armor", name:"Chain Shirt", def:3},
    {type:"accessory", name:"Ring of Luck", atk:1},
    {type:"accessory", name:"Amulet of Guarding", def:1},
  ];
  return table[Math.floor(rng()*table.length)];
}

function enterDungeon(nodeId){
  closeModal();
  const n = nodeById[nodeId];
  if(!n || !(n.type==="cave" || n.type==="forest")) return;

  state.mode = "dungeon";
  state.dungeon.kind = n.dungeonKind || (n.type==="forest" ? "forest" : "cave");
  state.dungeon.id = nodeId;

  const g = generateDungeon(state.dungeon.kind, nodeId);
  state.dungeon.tiles = g.tiles;
  state.dungeon.seen  = g.seen;
  state.dungeon.px = g.px;
  state.dungeon.py = g.py;
  state.dungeon.chests = g.chests;
  state.dungeon.keysOnGround = g.keysOnGround;
  state.dungeon.doors = g.doors;
  state.dungeon.enemies = g.enemies;

  revealAround(state.dungeon.px, state.dungeon.py, 2);
  pushLog(`üïØÔ∏è Entered ${n.name}. Fog-of-war active.`);
  pushLog(`‚å®Ô∏è Move with WASD / Arrow keys. Search/Explore reveals more.`);
  render();
}

function revealAround(px,py,r){
  const w=state.dungeon.w, h=state.dungeon.h;
  for(let y=py-r;y<=py+r;y++){
    for(let x=px-r;x<=px+r;x++){
      if(x>=0 && y>=0 && x<w && y<h) state.dungeon.seen[y][x]=true;
    }
  }
}

function tileAt(x,y){
  return state.dungeon.tiles?.[y]?.[x] || "wall";
}
function isWalkable(x,y){
  const t = tileAt(x,y);
  if(t==="wall") return false;
  if(t==="doorLocked"){
    const d = state.dungeon.doors[`${x},${y}`];
    return d && d.opened;
  }
  return true;
}

function dungeonMove(dx,dy){
  if(state.mode!=="dungeon") return;
  if(state.mode==="combat") return;

  const nx = state.dungeon.px + dx;
  const ny = state.dungeon.py + dy;

  if(nx<0||ny<0||nx>=state.dungeon.w||ny>=state.dungeon.h) return;
  const t = tileAt(nx,ny);

  // cannot walk into walls
  if(t==="wall"){
    pushLog("ü™® Blocked.");
    render();
    return;
  }

  // locked door behavior
  if(t==="doorLocked"){
    const d = state.dungeon.doors[`${nx},${ny}`];
    if(d && !d.opened){
      if(state.keys>0){
        d.opened=true;
        d.locked=false;
        state.keys -= 1;
        pushLog(`üîë Unlocked a door using a key.`);
      } else {
        pushLog(`üö™ Locked door. Need a key.`);
        render();
        return;
      }
    }
  }

  // movement costs energy + hunger (combat does not)
  if(!actionTick({energyCost:1, hungerCost:1, reason:"move"})){ render(); return; }

  state.dungeon.px = nx;
  state.dungeon.py = ny;

  // reveal
  revealAround(nx,ny,2);

  // interactions
  handleDungeonTile(nx,ny);

  render();
}

function handleDungeonTile(x,y){
  const key = `${x},${y}`;
  const t = tileAt(x,y);

  // enemy present?
  const enemyIdx = state.dungeon.enemies.findIndex(e=>e.x===x && e.y===y);
  if(enemyIdx >= 0){
    const e = state.dungeon.enemies[enemyIdx];
    // start combat, store position, remove enemy from map only upon defeat
    startCombat(makeEnemyFromDungeon(e), {origin:"dungeon", pos:{x,y}, dungeonEnemyIndex: enemyIdx});
    return;
  }

  // key pickup
  if(t==="key"){
    const k = state.dungeon.keysOnGround[key];
    if(k && !k.taken){
      k.taken=true;
      state.keys = (state.keys||0)+1;
      // convert tile to floor
      state.dungeon.tiles[y][x] = "floor";
      pushLog(`üîë You found a key. Keys: <b>${state.keys}</b>`);
    }
  }

  // chest
  if(t==="chest" || t==="chestLocked"){
    const c = state.dungeon.chests[key];
    if(!c) return;

    if(c.opened){
      pushLog("üì¶ Chest already opened.");
      return;
    }

    // show modal to open
    const locked = (t==="chestLocked") || c.locked;
    openModal(
      locked ? "Locked Chest" : "Chest",
      `You found a ${locked?"<b>locked</b> ":""}chest.<br><br>
       <button class="small" onclick="openChest(${x},${y})">Open</button>
       <button class="small secondary" onclick="closeModal()">Later</button>`
    );
  }

  // exit
  if(t==="exit"){
    openModal(
      "Exit",
      `You found an exit back to the surface.<br><br>
       <button class="small" onclick="leaveDungeon()">Leave</button>
       <button class="small secondary" onclick="closeModal()">Stay</button>`
    );
  }
}

function openChest(x,y){
  closeModal();
  const key = `${x},${y}`;
  const c = state.dungeon.chests[key];
  if(!c || c.opened) return;

  const t = tileAt(x,y);
  const locked = (t==="chestLocked") || c.locked;

  if(locked){
    if((state.keys||0) <= 0){
      pushLog("üîí Chest is locked. Need a key.");
      render();
      return;
    }
    state.keys -= 1;
    pushLog("üîì You unlock the chest using a key.");
  }

  c.opened = true;
  // turn tile into floor
  state.dungeon.tiles[y][x] = "floor";

  // grant contents
  let gained = [];
  for(const item of c.contents){
    if(item.type==="gold"){
      state.gold += item.amount;
      gained.push(`${item.amount}g`);
    }
    if(item.type==="gear"){
      state.bag.push(item.item);
      gained.push(fmtItem(item.item));
    }
    if(item.type==="consumable"){
      addToBag(item.item);
      gained.push(item.item.name);
    }
    if(item.type==="key"){
      state.keys = (state.keys||0) + item.amount;
      gained.push(`${item.amount} key`);
    }
  }
  pushLog(`üì¶ Chest opened! Gained: <b>${gained.join(", ")}</b>`);
  render();
}

function leaveDungeon(){
  closeModal();
  const surface = nodeById[state.currentNode];
  pushLog(`üå§Ô∏è You return to the surface near <b>${surface.name}</b>.`);
  state.mode = "world";
  // clear dungeon state but keep keys
  state.dungeon.kind=null;
  state.dungeon.id=null;
  state.dungeon.tiles=[];
  state.dungeon.seen=[];
  state.dungeon.enemies=[];
  state.dungeon.chests={};
  state.dungeon.keysOnGround={};
  state.dungeon.doors={};
  render();
}

/* =========================
   Combat (energy NOT used)
   Attack button only appears in combat
========================= */
function makeEnemy(tag){
  if(tag==="pirates"){
    return {name:"Pirate Skiff", hp:18, hpMax:18, ac:12, atk:4, tag:"pirates"};
  }
  if(tag==="sea"){
    const pick = (roll(2)===1) ? "Sea Serpent" : "Reef Stalker";
    return {name:pick, hp:16, hpMax:16, ac:11, atk:4, tag:"sea"};
  }
  if(tag==="road"){
    const pick = ["Bandit","Wolf","Cultist"][roll(3)-1];
    return makeEnemyByName(pick, tag);
  }
  // ambush
  const pick = ["Goblin","Bandit","Wolf"][roll(3)-1];
  return makeEnemyByName(pick, tag);
}
function makeEnemyByName(name, tag){
  const base = {
    "Goblin": {hp:12, ac:10, atk:3},
    "Bandit": {hp:16, ac:11, atk:3},
    "Wolf":   {hp:10, ac:10, atk:2},
    "Cultist":{hp:14, ac:12, atk:3},
    "Slime":  {hp:15, ac:10, atk:2},
  }[name] || {hp:12, ac:10, atk:2};
  return {name, hp:base.hp, hpMax:base.hp, ac:base.ac, atk:base.atk, tag};
}

function makeDungeonEnemy(type, x, y){
  const base = {
    "Goblin": {hp:12, ac:10, atk:3},
    "Bandit": {hp:16, ac:11, atk:3},
    "Cultist":{hp:14, ac:12, atk:3},
    "Slime":  {hp:15, ac:10, atk:2},
    "Wolf":   {hp:10, ac:10, atk:2},
    "Boar":   {hp:14, ac:11, atk:3},
    "Warg":   {hp:18, ac:12, atk:4},
  }[type] || {hp:12, ac:10, atk:2};
  return {x,y,type, hp:base.hp, ac:base.ac, atk:base.atk};
}
function makeEnemyFromDungeon(e){
  return {name:e.type, hp:e.hp, hpMax:e.hp, ac:e.ac, atk:e.atk, tag:"dungeon"};
}

function startCombat(enemy, meta){
  state.mode = "combat";
  state.enemy = enemy;
  state.enemyMeta = meta || {};
  $("combatRow").style.display="flex";
  pushLog(`‚ö†Ô∏è Encounter: <b>${enemy.name}</b> appears!`);
}

function endCombat(victory){
  const enemy = state.enemy;
  const meta = state.enemyMeta || {};

  if(victory){
    const gold = roll(12)+4;
    state.gold += gold;
    pushLog(`‚úÖ Victory! You gain <b>${gold}g</b>.`);

    // drop chance
    if(roll(100)<=28){
      const gear = randomGear();
      state.bag.push(gear);
      pushLog(`üì¶ Loot: <b>${fmtItem(gear)}</b>`);
    }
    if(roll(100)<=22){
      addToBag({type:"consumable", name:"Ration", kind:"food", qty:1});
      pushLog(`üçó Loot: <b>Ration</b>`);
    }

    // if combat was from travel en route, arrive now
    if(state.pendingArrival){
      const toId = state.pendingArrival;
      state.pendingArrival = null;
      const to = nodeById[toId];
      pushLog(`üß≠ You continue and arrive at <b>${to.name}</b>.`);
      enterNode(toId);
    }

    // if dungeon enemy, remove it from map now
    if(meta.origin==="dungeon" && meta.pos){
      const {x,y} = meta.pos;
      state.dungeon.enemies = state.dungeon.enemies.filter(en => !(en.x===x && en.y===y));
      pushLog(`üó∫Ô∏è The area is safer now.`);
    }
  } else {
    pushLog(`üèÉ You escape!`);
    // escape cancels pending arrival (you retreat to start)
    if(state.pendingArrival){
      state.pendingArrival = null;
      pushLog(`üß≠ You turn back to where you started.`);
    }
  }

  state.enemy = null;
  state.enemyMeta = null;

  // return to previous mode
  if(state.dungeon.id) state.mode = "dungeon";
  else state.mode = "world";
}

function playerAttack(){
  if(state.mode!=="combat" || !state.enemy) return;

  const d20 = roll(20);
  pushLog(`üé≤ You roll d20: <b>${d20}</b>`);
  if(d20 >= state.enemy.ac){
    const dmg = roll(6) + getAtk();
    state.enemy.hp -= dmg;
    pushLog(`‚öîÔ∏è Hit! You deal <b>${dmg}</b>.`);
  } else {
    pushLog(`‚ùå Miss.`);
  }

  if(state.enemy.hp <= 0){
    pushLog(`üíÄ ${state.enemy.name} defeated.`);
    endCombat(true);
    render();
    return;
  }

  enemyTurn();
  render();
}
function enemyTurn(){
  const d20 = roll(20);
  const playerAC = 10 + getDef();
  pushLog(`üé≤ ${state.enemy.name} rolls d20: <b>${d20}</b>`);
  if(d20 >= playerAC){
    const dmg = roll(6) + state.enemy.atk;
    state.hp -= dmg;
    pushLog(`<span style="color:var(--bad)">ü©∏ You take ${dmg} damage.</span>`);
  } else {
    pushLog(`üõ°Ô∏è Enemy misses.`);
  }

  if(state.hp <= 0){
    state.hp = 1;
    pushLog(`<b style="color:var(--bad)">‚ò†Ô∏è You collapse‚Ä¶ and wake at your last safe location.</b>`);
    // return to world
    state.mode = "world";
    state.dungeon.id = null;
    state.dungeon.kind = null;
    state.dungeon.tiles = [];
    state.dungeon.seen = [];
    state.dungeon.enemies = [];
    state.dungeon.chests = {};
    state.dungeon.keysOnGround = {};
    state.dungeon.doors = {};
    state.enemy = null;
    state.enemyMeta = null;
    state.pendingArrival = null;
    enterNode(state.lastSafeNode);
  }
}
function flee(){
  if(state.mode!=="combat") return;
  const d20 = roll(20);
  pushLog(`üèÉ Flee attempt d20: <b>${d20}</b>`);
  if(d20>=11){
    endCombat(false);
  } else {
    pushLog(`‚ùå Failed to flee.`);
    enemyTurn();
  }
  render();
}

/* =========================
   Search / Explore button
   - costs energy
   - in dungeon: reveals extra + can trigger chest/enemy already placed
========================= */
function searchExplore(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't search during combat."); render(); return; }

  if(state.mode==="dungeon"){
    if(!actionTick({energyCost:1, hungerCost:1, reason:"explore"})){ render(); return; }
    revealAround(state.dungeon.px, state.dungeon.py, 3);
    pushLog(`üïØÔ∏è You carefully search the surroundings‚Ä¶`);
    // small chance to find hidden gold in dungeon
    if(roll(100)<=18){
      const g=roll(10)+3;
      state.gold+=g;
      pushLog(`‚ú® You find <b>${g}g</b> in the shadows.`);
    }
    render();
    return;
  }

  // world search
  if(!actionTick({energyCost:1, hungerCost:1, reason:"search"})){ render(); return; }

  const r=roll(100);
  if(r<=18){
    const g=roll(12)+3; state.gold+=g;
    pushLog(`üîé Found <b>${g}g</b>.`);
  } else if(r<=30){
    const item=randomGear(); state.bag.push(item);
    pushLog(`üîé Found <b>${fmtItem(item)}</b>.`);
  } else {
    pushLog(`üîé Nothing useful.`);
  }

  if(roll(100)<=12){
    startCombat(makeEnemy("ambush"), {origin:"world"});
  }
  render();
}

/* =========================
   Sleep/Eat
========================= */
function canSleepHere(){
  const n=nodeById[state.currentNode];
  return state.mode==="world" && (n.type==="town"||n.type==="camp"||n.type==="port");
}
function sleep(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't sleep in combat."); render(); return; }
  if(!canSleepHere()){
    pushLog(`üõå You can only sleep in a Town, Camp, or Port.`);
    render(); return;
  }
  // sleeping does NOT cost energy; it restores it. Hunger drops slightly.
  state.energy = state.energyMax;
  const heal = 8 + roll(6);
  state.hp = clamp(state.hp + heal, 0, state.hpMax);
  spendHunger(1);
  pushLog(`<span style="color:var(--good)">üõå Slept safely. Energy restored. Healed ${heal} HP.</span>`);
  starvingPenalty();
  render();
}
function eat(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't eat in combat."); render(); return; }
  if(countItem("food")<=0){
    pushLog("üçó No rations.");
    render(); return;
  }
  consumeItem("food",1);
  state.hunger = clamp(state.hunger + 5, 0, state.hungerMax);
  state.energy = clamp(state.energy + 3, 0, state.energyMax);
  state.hp = clamp(state.hp + 2, 0, state.hpMax);
  pushLog(`<span style="color:var(--good)">üçó Ate a ration. +Hunger, +Energy, +HP.</span>`);
  render();
}

/* =========================
   Buying food (town/port/camp)
========================= */
function canBuyHere(){
  const n=nodeById[state.currentNode];
  return state.mode==="world" && (n.type==="town"||n.type==="port"||n.type==="camp");
}
function buyRation(){
  if(!canBuyHere()){
    pushLog("üõí You can only buy rations in town/camp/port.");
    render(); return;
  }
  if(state.gold<5){
    pushLog("üõí Not enough gold for a ration.");
    render(); return;
  }
  state.gold -= 5;
  addToBag({type:"consumable", name:"Ration", kind:"food", qty:1});
  pushLog("üõí Bought <b>1 Ration</b> for 5g.");
  render();
}

/* =========================
   Quest system (simple but real)
   - accept in towns
   - deliver item to port for reward
========================= */
function seedQuestIfNone(){
  if(state.quest) return;

  state.quest = {
    id:"deliver_crate",
    title:"Deliver Sealed Crate",
    from:"stonehaven",
    to:"grandport",
    itemName:"Sealed Crate",
    rewardGold: 25,
    rewardKey: 1,
    accepted:false
  };
}

function acceptQuest(){
  if(!state.quest || state.quest.accepted) return;
  const n = nodeById[state.currentNode];
  if(n.id !== state.quest.from){
    pushLog("üìú You can only accept this quest in Stonehaven.");
    render(); return;
  }
  state.quest.accepted = true;
  state.questDelivered = false;
  addToBag({type:"quest", name: state.quest.itemName});
  pushLog(`üìú Quest accepted: <b>${state.quest.title}</b>. Take the crate to <b>${nodeById[state.quest.to].name}</b>.`);
  render();
}

function hasQuestItem(name){
  return state.bag.some(x=>x.type==="quest" && x.name===name);
}
function removeQuestItem(name){
  const idx = state.bag.findIndex(x=>x.type==="quest" && x.name===name);
  if(idx>=0) state.bag.splice(idx,1);
}
function checkQuestProgress(){
  seedQuestIfNone();
  if(!state.quest || !state.quest.accepted || state.questDelivered) return;

  if(state.currentNode === state.quest.to && hasQuestItem(state.quest.itemName)){
    // deliver
    removeQuestItem(state.quest.itemName);
    state.gold += state.quest.rewardGold;
    state.keys = (state.keys||0) + state.quest.rewardKey;
    state.questDelivered = true;
    pushLog(`<span style="color:var(--good)">üì¶ Delivered the crate! +${state.quest.rewardGold}g and +${state.quest.rewardKey} key.</span>`);
  }
}

/* =========================
   Map rendering (land + sea + routes)
========================= */
function resizeCanvas(){
  const r = mapCanvas.getBoundingClientRect();
  mapCanvas.width = Math.floor(r.width * devicePixelRatio);
  mapCanvas.height = Math.floor(r.height * devicePixelRatio);
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}

function drawSeaAndLand(r){
  // Sea gradient
  const g = ctx.createLinearGradient(0,0,0,r.height);
  g.addColorStop(0, "rgba(20,40,120,.65)");
  g.addColorStop(1, "rgba(10,20,60,.75)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,r.width,r.height);

  // Landmass shape (simple painted polygon)
  ctx.beginPath();
  ctx.moveTo(60, 80);
  ctx.bezierCurveTo(200, 20, 360, 40, 520, 110);
  ctx.bezierCurveTo(650, 170, 720, 250, 770, 360);
  ctx.bezierCurveTo(680, 430, 560, 440, 420, 410);
  ctx.bezierCurveTo(300, 385, 210, 360, 120, 270);
  ctx.bezierCurveTo(70, 210, 40, 150, 60, 80);
  ctx.closePath();

  const land = ctx.createLinearGradient(0,0,r.width,r.height);
  land.addColorStop(0, "rgba(34,95,55,.85)");
  land.addColorStop(1, "rgba(22,60,40,.90)");
  ctx.fillStyle = land;
  ctx.fill();

  // shoreline highlight
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 3;
  ctx.stroke();

  // subtle waves
  ctx.globalAlpha = 0.10;
  ctx.strokeStyle = "rgba(255,255,255,.35)";
  for(let i=0;i<10;i++){
    ctx.beginPath();
    const y = 40 + i*40;
    ctx.moveTo(0, y);
    ctx.bezierCurveTo(r.width*0.25, y-10, r.width*0.55, y+10, r.width, y-5);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawWorld(){
  const r = mapCanvas.getBoundingClientRect();
  ctx.clearRect(0,0,r.width,r.height);

  drawSeaAndLand(r);

  // routes
  for(const e of world.edges){
    const A = nodeById[e.a], B = nodeById[e.b];
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);

    if(e.kind==="sea"){
      ctx.setLineDash([8,8]);
      ctx.strokeStyle = "rgba(147,197,253,.55)";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.setLineDash([]);

      // fare label mid
      const mx = (A.x+B.x)/2, my=(A.y+B.y)/2;
      ctx.fillStyle = "rgba(229,231,235,.85)";
      ctx.font = "12px system-ui";
      ctx.fillText(`‚õ¥ ${e.fare}g`, mx+6, my-6);
    } else {
      ctx.setLineDash([]);
      ctx.strokeStyle = "rgba(251,191,36,.35)";
      ctx.lineWidth = 4;
      ctx.stroke();
    }
  }

  // nodes
  for(const n of world.nodes){
    const isHere = n.id === state.currentNode;

    let fill = "rgba(255,255,255,.14)";
    let icon = "‚Ä¢";
    if(n.type==="town"){ fill="rgba(124,92,255,.30)"; icon="üèòÔ∏è"; }
    if(n.type==="camp"){ fill="rgba(52,211,153,.22)"; icon="‚õ∫"; }
    if(n.type==="port"){ fill="rgba(59,130,246,.22)"; icon="‚öì"; }
    if(n.type==="cave"){ fill="rgba(251,113,133,.18)"; icon="üï≥Ô∏è"; }
    if(n.type==="forest"){ fill="rgba(34,197,94,.18)"; icon="üå≤"; }

    if(isHere){
      ctx.beginPath();
      ctx.fillStyle="rgba(124,92,255,.35)";
      ctx.arc(n.x,n.y,22,0,Math.PI*2);
      ctx.fill();
    }

    ctx.beginPath();
    ctx.fillStyle = fill;
    ctx.strokeStyle = "rgba(255,255,255,.22)";
    ctx.lineWidth = 2;
    ctx.arc(n.x,n.y,15,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // icon
    ctx.fillStyle = "rgba(229,231,235,.95)";
    ctx.font = "14px system-ui";
    ctx.fillText(icon, n.x-10, n.y+6);

    // label
    ctx.fillStyle = "rgba(229,231,235,.92)";
    ctx.font = "12px system-ui";
    ctx.fillText(n.name, n.x+18, n.y+4);
  }
}

function drawDungeon(){
  const r = mapCanvas.getBoundingClientRect();
  ctx.clearRect(0,0,r.width,r.height);

  // dungeon background
  ctx.fillStyle = "rgba(0,0,0,.45)";
  ctx.fillRect(0,0,r.width,r.height);

  const w = state.dungeon.w, h = state.dungeon.h;
  const pad = 14;
  const cell = Math.min((r.width-pad*2)/w, (r.height-pad*2)/h);

  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const sx = pad + x*cell;
      const sy = pad + y*cell;
      const seen = state.dungeon.seen[y]?.[x];

      if(!seen){
        ctx.fillStyle="rgba(0,0,0,.90)";
        ctx.fillRect(sx,sy,cell,cell);
        continue;
      }

      const t = tileAt(x,y);
      if(t==="wall"){
        ctx.fillStyle = state.dungeon.kind==="forest" ? "rgba(16,60,35,.55)" : "rgba(255,255,255,.10)";
      } else {
        ctx.fillStyle = state.dungeon.kind==="forest" ? "rgba(35,95,60,.25)" : "rgba(255,255,255,.18)";
      }
      ctx.fillRect(sx,sy,cell,cell);

      // special tiles
      if(t==="entrance"){
        ctx.fillStyle="rgba(52,211,153,.9)";
        ctx.fillRect(sx+cell*0.25, sy+cell*0.25, cell*0.5, cell*0.5);
      }
      if(t==="exit"){
        ctx.fillStyle="rgba(124,92,255,.9)";
        ctx.fillRect(sx+cell*0.25, sy+cell*0.25, cell*0.5, cell*0.5);
      }
      if(t==="key"){
        ctx.fillStyle="rgba(251,191,36,.95)";
        ctx.fillRect(sx+cell*0.3, sy+cell*0.3, cell*0.4, cell*0.4);
      }
      if(t==="chest" || t==="chestLocked"){
        ctx.fillStyle = (t==="chestLocked") ? "rgba(251,113,133,.9)" : "rgba(147,197,253,.9)";
        ctx.fillRect(sx+cell*0.25, sy+cell*0.35, cell*0.5, cell*0.35);
      }
      if(t==="doorLocked"){
        const d = state.dungeon.doors[`${x},${y}`];
        ctx.fillStyle = d?.opened ? "rgba(52,211,153,.6)" : "rgba(251,191,36,.75)";
        ctx.fillRect(sx+cell*0.15, sy+cell*0.15, cell*0.7, cell*0.7);
      }

      // draw enemies as red dots (only if tile seen)
      const enemyHere = state.dungeon.enemies.some(en=>en.x===x && en.y===y);
      if(enemyHere){
        ctx.beginPath();
        ctx.fillStyle = "rgba(251,113,133,.9)";
        ctx.arc(sx+cell/2, sy+cell/2, Math.max(3, cell*0.18), 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // player marker
  const px = pad + state.dungeon.px*cell + cell/2;
  const py = pad + state.dungeon.py*cell + cell/2;
  ctx.beginPath();
  ctx.fillStyle = "rgba(251,191,36,.95)";
  ctx.arc(px,py, Math.max(4, cell*0.22), 0, Math.PI*2);
  ctx.fill();

  // label
  ctx.fillStyle="rgba(229,231,235,.9)";
  ctx.font="12px system-ui";
  const label = state.dungeon.kind==="forest" ? "Forest (Fog-of-War)" : "Cave (Fog-of-War)";
  ctx.fillText(`${label} ‚Ä¢ Keys: ${state.keys||0}`, 14, 16);
}

function drawMap(){
  if(state.mode==="dungeon" || (state.dungeon.id && state.mode!=="world")) drawDungeon();
  else drawWorld();
}

function canvasToPos(evt){
  const rect = mapCanvas.getBoundingClientRect();
  return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
}

function handleMapClick(evt){
  if(state.mode!=="world") return;
  const {x,y} = canvasToPos(evt);

  // hit nodes
  const hit = world.nodes.find(n=>{
    const dx=n.x-x, dy=n.y-y;
    return Math.sqrt(dx*dx+dy*dy) <= 18;
  });
  if(!hit) return;
  if(hit.id === state.currentNode) return;

  if(!canTravelTo(hit.id)){
    pushLog(`üö´ No route to ${hit.name}.`);
    render();
    return;
  }
  travelTo(hit.id);
}

/* =========================
   Modal
========================= */
function openModal(title, html){
  $("modalTitle").textContent = title;
  $("modalBody").innerHTML = html;
  $("overlay").style.display="flex";
}
function closeModal(){ $("overlay").style.display="none"; }
$("closeModal").addEventListener("click", closeModal);
$("overlay").addEventListener("click", (e)=>{ if(e.target.id==="overlay") closeModal(); });

/* =========================
   Render UI
========================= */
function render(){
  // derived
  $("hp").textContent = state.hp;
  $("hpMax").textContent = state.hpMax;
  $("atk").textContent = getAtk();
  $("def").textContent = getDef();
  $("energy").textContent = state.energy;
  $("energyMax").textContent = state.energyMax;
  $("hunger").textContent = state.hunger;
  $("gold").textContent = state.gold;

  // quest
  seedQuestIfNone();
  if(state.quest && !state.quest.accepted){
    $("questTitle").textContent = "Available";
    $("questSub").innerHTML = `In Stonehaven: <b>${state.quest.title}</b> <button class="small" onclick="acceptQuest()">Accept</button>`;
  } else if(state.quest && state.quest.accepted && !state.questDelivered){
    $("questTitle").textContent = "Active";
    $("questSub").textContent = `Deliver ${state.quest.itemName} to ${nodeById[state.quest.to].name}.`;
  } else if(state.quest && state.questDelivered){
    $("questTitle").textContent = "Completed";
    $("questSub").textContent = `Nice work.`;
  } else {
    $("questTitle").textContent = "None";
    $("questSub").textContent = "Pick one up in town.";
  }

  // mode/loc
  $("modeBadge").textContent =
    state.mode==="combat" ? "Mode: Combat" :
    state.mode==="dungeon" ? `Mode: ${state.dungeon.kind==="forest"?"Forest":"Cave"}` :
    "Mode: Exploring";

  $("locBadge").textContent = `Location: ${nodeById[state.currentNode]?.name || "‚Äî"}`;

  $("areaBadge").textContent = `Area Loot: ${areaLootAvailable() ? "Available" : "Used"}`;
  $("areaLootBtn").disabled = (state.mode!=="world") || !areaLootAvailable();
  $("searchBtn").disabled = (state.mode==="combat");
  $("sleepBtn").disabled = !canSleepHere() || (state.mode==="combat");
  $("eatBtn").disabled = (countItem("food")<=0) || (state.mode==="combat");
  $("buyFoodBtn").disabled = !canBuyHere();

  // combat visibility
  $("combatRow").style.display = (state.mode==="combat") ? "flex" : "none";
  $("enemyPanel").style.display = (state.mode==="combat" && state.enemy) ? "block" : "none";
  $("attackBtn").disabled = (state.mode!=="combat");
  $("fleeBtn").disabled = (state.mode!=="combat");

  if(state.enemy){
    $("enemyName").textContent = state.enemy.name;
    $("enemyHp").textContent = Math.max(0, state.enemy.hp);
    $("enemyAC").textContent = state.enemy.ac;
  }

  // equipment
  $("weaponSlot").innerHTML = `
    <strong>Weapon</strong>
    <div class="itemName">${state.weapon ? fmtItem(state.weapon) : "None"}</div>
    <div>${state.weapon ? `<button class="small secondary" onclick="unequip('weapon')">Unequip</button>` : ""}</div>
  `;
  $("armorSlot").innerHTML = `
    <strong>Armor</strong>
    <div class="itemName">${state.armor ? fmtItem(state.armor) : "None"}</div>
    <div>${state.armor ? `<button class="small secondary" onclick="unequip('armor')">Unequip</button>` : ""}</div>
  `;
  $("accessorySlot").innerHTML = `
    <strong>Accessory</strong>
    <div class="itemName">${state.accessory ? fmtItem(state.accessory) : "None"}</div>
    <div>${state.accessory ? `<button class="small secondary" onclick="unequip('accessory')">Unequip</button>` : ""}</div>
  `;

  // bag
  $("bag").innerHTML = "";
  if(state.bag.length===0){
    const empty=document.createElement("div");
    empty.className="itemCard";
    empty.style.gridColumn="1/-1";
    empty.innerHTML = `<div class="meta">Backpack empty.</div>`;
    $("bag").appendChild(empty);
  } else {
    state.bag.forEach((item,i)=>{
      const d=document.createElement("div");
      d.className="itemCard";

      if(item.type==="consumable"){
        d.innerHTML = `
          <div><b>${item.name}</b> √ó ${item.qty||1}</div>
          <div class="meta">CONSUMABLE</div>
          <button class="small" onclick="eat()">Eat</button>
        `;
      } else if(item.type==="quest"){
        d.innerHTML = `
          <div><b>${item.name}</b></div>
          <div class="meta">QUEST ITEM</div>
          <button class="small secondary" disabled>Cannot drop</button>
        `;
      } else {
        d.innerHTML = `
          <div><b>${item.name}</b></div>
          <div class="meta">${item.type.toUpperCase()} ‚Ä¢ ${item.atk?`+${item.atk} ATK `:""}${item.def?`+${item.def} DEF`:""}</div>
          <button class="small" onclick="equipFromBag(${i})">Equip</button>
        `;
      }
      $("bag").appendChild(d);
    });
  }

  // log
  $("log").innerHTML = state.log.map(x=>`<div>${x}</div>`).join("");
  $("log").scrollTop = $("log").scrollHeight;

  drawMap();
  save();
}

/* =========================
   Keyboard movement (WASD/Arrows)
========================= */
window.addEventListener("keydown",(e)=>{
  if(state.mode!=="dungeon") return;
  if(state.mode==="combat") return;

  const k = e.key.toLowerCase();
  if(k==="w" || e.key==="ArrowUp"){ e.preventDefault(); dungeonMove(0,-1); }
  if(k==="s" || e.key==="ArrowDown"){ e.preventDefault(); dungeonMove(0,1); }
  if(k==="a" || e.key==="ArrowLeft"){ e.preventDefault(); dungeonMove(-1,0); }
  if(k==="d" || e.key==="ArrowRight"){ e.preventDefault(); dungeonMove(1,0); }
});

/* =========================
   Button wiring
========================= */
$("areaLootBtn").addEventListener("click", useAreaLoot);
$("searchBtn").addEventListener("click", searchExplore);
$("sleepBtn").addEventListener("click", sleep);
$("eatBtn").addEventListener("click", eat);
$("buyFoodBtn").addEventListener("click", buyRation);

$("attackBtn").addEventListener("click", playerAttack);
$("fleeBtn").addEventListener("click", flee);

$("resetBtn").addEventListener("click", ()=>{
  localStorage.removeItem(SAVE_KEY);
  state = defaultState();
  pushLog("üßπ Save reset.");
  init(true);
});

mapCanvas.addEventListener("click", handleMapClick);
window.addEventListener("resize", ()=>{ resizeCanvas(); render(); });

/* =========================
   Init
========================= */
function init(resetLog=false){
  // ensure current node valid
  if(!nodeById[state.currentNode]) state.currentNode="stonehaven";
  if(!nodeById[state.lastSafeNode]) state.lastSafeNode="stonehaven";

  // ensure keys counter exists
  state.keys = state.keys || 0;

  // initial stamps
  if(!state.nodeVisitStamp[state.currentNode]){
    state.nodeVisitStamp[state.currentNode] = state.visitCounter;
  }

  resizeCanvas();

  if(state.log.length===0 || resetLog){
    state.log = [];
    pushLog(`üß≠ Welcome! Click connected locations to travel. Travel + Loot cost ‚ö° Energy.`);
    pushLog(`üçó Hunger drops with actions. Eat rations and Sleep in towns/camps/ports.`);
    pushLog(`üï≥Ô∏è Caves & üå≤ Forests use fog-of-war and manual movement (WASD).`);
    pushLog(`‚õ¥Ô∏è Sea travel requires fare and carries risks (falls + pirates/sea beasts).`);
  }

  // enter node without incrementing visitCounter on boot:
  // mark this node as current visit stamp
  state.nodeVisitStamp[state.currentNode] = state.nodeVisitStamp[state.currentNode] || state.visitCounter;

  seedQuestIfNone();
  checkQuestProgress();

  render();
}
init();
</script>
</body>
</html>
