<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Apex Dice RPG ‚Äî Kingdoms</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
:root{
  --bg0:#070b1a;
  --bg1:#0b1026;
  --accent:#7c5cff;
  --card:rgba(255,255,255,.08);
  --border:rgba(255,255,255,.14);
  --text:#e5e7eb;
  --muted:#9ca3af;
  --good:#34d399;
  --bad:#fb7185;
  --warn:#fbbf24;

  --sea:#143077;
  --land:#1f6b3f;

  --k1:rgba(124,92,255,.16);
  --k2:rgba(251,113,133,.14);
  --k3:rgba(52,211,153,.12);
  --k4:rgba(59,130,246,.12);
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  background:
    radial-gradient(1200px 600px at 60% -10%, #7c5cff55, transparent 60%),
    linear-gradient(180deg,var(--bg0),var(--bg1));
  color:var(--text);
  min-height:100vh;
}
.wrap{max-width:1600px;margin:auto;padding:22px}
h1{margin:0 0 6px;font-size:34px}
p{margin:0 0 14px;color:var(--muted)}
.card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:20px;
  padding:16px;
  backdrop-filter:blur(14px);
  box-shadow:0 30px 80px rgba(0,0,0,.35);
}
.grid{display:grid;grid-template-columns:1fr 520px;gap:16px;align-items:start}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
button{
  background:linear-gradient(135deg,#7c5cff,#5f4cff);
  border:none;color:#fff;
  padding:12px 16px;border-radius:12px;cursor:pointer;
  font-size:15px;
}
button.secondary{
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
}
button.small{font-size:12px;padding:8px 10px;border-radius:10px}
button:disabled{opacity:.45;cursor:not-allowed}
.badge{
  display:inline-flex;align-items:center;gap:8px;
  padding:6px 10px;border-radius:999px;
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  color:var(--muted);
  font-size:12px;
}
.kv{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}
.tile{
  background:rgba(0,0,0,.30);
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:10px;
  text-align:center;
}
.tile strong{font-size:18px}
.sub{color:var(--muted);font-size:12px;margin-top:6px}
.log{
  background:rgba(0,0,0,.4);
  border-radius:14px;
  padding:12px;
  height:210px;
  overflow:auto;
  font-size:14px;
}
hr{border:none;border-top:1px solid var(--border);margin:14px 0}

/* Map */
.mapTitle{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.mapCanvas{
  width:100%;
  height:640px; /* bigger */
  border-radius:16px;
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  overflow:hidden;
  position:relative;
}
.mapCanvas canvas{width:100%;height:100%;display:block}
.hint{color:var(--muted);font-size:12px}
.tooltip{
  position:absolute;
  pointer-events:none;
  background:rgba(10,10,20,.92);
  border:1px solid rgba(255,255,255,.18);
  padding:8px 10px;
  border-radius:12px;
  font-size:12px;
  color:var(--text);
  display:none;
  max-width:290px;
}

.minimap{
  position:absolute;
  right:12px; bottom:12px;
  width:180px; height:110px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(0,0,0,.35);
  overflow:hidden;
  box-shadow:0 20px 50px rgba(0,0,0,.35);
  cursor:pointer;
}
.minimap.expanded{
  width:520px; height:320px;
}
.minimap canvas{width:100%;height:100%;display:block;opacity:.97}
.miniHud{
  position:absolute;
  left:8px; top:8px;
  display:flex;
  gap:8px;
  align-items:center;
  padding:6px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.40);
  z-index:3;
  pointer-events:auto;
}
.miniLabel{font-size:11px;color:var(--muted);letter-spacing:.02em}
.miniBtn{
  width:26px;height:26px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.08);
  color:var(--text);
  cursor:pointer;
  display:grid;place-items:center;
  padding:0;
}
.miniBtn:hover{background:rgba(255,255,255,.12)}

.youAreHere{
  position:absolute;
  left:12px; bottom:12px;
  display:flex; gap:10px; align-items:center;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.35);
}
.pulseDot{
  width:10px;height:10px;border-radius:999px;background:rgba(251,191,36,.95);
  box-shadow:0 0 0 0 rgba(251,191,36,.6);
  animation:pulse 1.6s infinite;
}
@keyframes pulse{
  0%{ box-shadow:0 0 0 0 rgba(251,191,36,.55) }
  70%{ box-shadow:0 0 0 14px rgba(251,191,36,0) }
  100%{ box-shadow:0 0 0 0 rgba(251,191,36,0) }
}


/* Map legend + toggles */
.legendBox{
  position:absolute;
  left:12px; top:12px;
  max-width:360px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.35);
  backdrop-filter:blur(10px);
}
.legendTitle{display:flex;align-items:center;justify-content:space-between;gap:10px}
.legendTitle b{font-size:13px}
.legendGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:8px}
.legendItem{display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted)}
.legendIcon{width:18px;text-align:center}
.legendKingdoms{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
.kchip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.25);font-size:11px;color:var(--muted)}
.kdot{width:10px;height:10px;border-radius:999px}


/* Inventory */
.inventory{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
.slot{
  background:rgba(0,0,0,.35);
  border:1px dashed var(--border);
  border-radius:14px;
  padding:10px;
  min-height:86px;
  text-align:center;
  font-size:14px;
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  gap:8px;
}
.slot strong{display:block;font-size:12px;color:var(--muted)}
.slot .itemName{line-height:1.2}
.bagGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:10px}
.itemCard{
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  border-radius:14px;
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:110px;
}
.itemCard .meta{font-size:12px;color:var(--muted)}

.panel{
  background:rgba(0,0,0,.35);
  border:1px solid var(--border);
  border-radius:14px;
  padding:12px;
}
.panel h3{margin:0 0 10px;font-size:16px}
.panel .muted{color:var(--muted);font-size:12px}

.progressWrap{
  margin-top:10px;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.12);
  border-radius:999px;
  height:12px;
  overflow:hidden;
}
.progressBar{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(52,211,153,.9), rgba(124,92,255,.9));
}

/* Modal / Overlays */
.overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.60);
  display:none;
  align-items:center;
  justify-content:center;
  padding:18px;
  z-index:60;
}
.modal{
  width:min(980px, 96vw);
  background:rgba(15,18,40,.94);
  border:1px solid var(--border);
  border-radius:18px;
  padding:16px;
  box-shadow:0 40px 120px rgba(0,0,0,.55);
}
.modal .top{display:flex;justify-content:space-between;align-items:center;gap:10px}
.modal h3{margin:0}
.modal p{margin:6px 0 0;color:var(--muted)}
kbd{
  font-family:ui-monospace,SFMono-Regular,Menlo,monospace;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.15);
  padding:2px 6px;
  border-radius:6px;
  color:var(--text);
  font-size:12px;
}
input, select{
  width:100%;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.35);
  color:var(--text);
}
.formGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:12px}
.formGrid .panel{padding:12px}
.smallMuted{font-size:12px;color:var(--muted)}
.statGrid{display:grid;grid-template-columns:repeat(6,1fr);gap:10px;margin-top:10px}
.statBox{border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:10px;text-align:center;background:rgba(0,0,0,.35)}
.statBox b{font-size:18px}
.lockTag{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);color:var(--muted);font-size:12px}

.combatOverlay{
  position:fixed; inset:0;
  background:radial-gradient(900px 500px at 50% 0%, rgba(124,92,255,.25), transparent 65%),
             rgba(0,0,0,.72);
  display:none;
  z-index:80;
}
.combatScreen{
  max-width:1200px;
  margin:22px auto;
  padding:16px;
}
.combatGrid{
  display:grid;
  grid-template-columns:1fr 360px;
  gap:14px;
}
.combatCard{
  background:rgba(15,18,40,.88);
  border:1px solid rgba(255,255,255,.14);
  border-radius:18px;
  padding:14px;
  box-shadow:0 35px 100px rgba(0,0,0,.55);
}
.hpbarWrap{height:12px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);overflow:hidden}
.hpbar{height:100%;width:0%;background:linear-gradient(90deg, rgba(251,113,133,.95), rgba(251,191,36,.8))}
.hpbarGood{background:linear-gradient(90deg, rgba(52,211,153,.95), rgba(124,92,255,.75))}
.combatActions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
.combatLog{height:260px;overflow:auto;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:12px}
.portrait{
  height:220px;border-radius:16px;border:1px solid rgba(255,255,255,.12);
  background:linear-gradient(135deg, rgba(255,255,255,.08), rgba(0,0,0,.15));
  display:flex;align-items:center;justify-content:center;font-size:54px;
}
.tabs{display:flex;gap:8px;flex-wrap:wrap}
.tabBtn{padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.35);color:var(--text);cursor:pointer;font-size:12px}
.tabBtn.active{background:rgba(124,92,255,.35)}
.hidden{display:none!important}

/* --- Floating Map Overlay Controls --- */
.mapOverlay{
  position:absolute;
  top:16px;
  right:16px;
  width:min(420px, 42%);
  background:rgba(0,0,0,.38);
  border:1px solid rgba(255,255,255,.14);
  border-radius:16px;
  padding:12px;
  backdrop-filter:blur(12px);
  box-shadow:0 20px 60px rgba(0,0,0,.45);
  pointer-events:auto;
}
.mapOverlayTitle{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}
.mapOverlay .smallMuted{color:var(--muted); font-size:12px}
.mapOverlay .row{gap:8px}
.mapOverlay button.small{
  padding:8px 10px;
  font-size:12px;
  border-radius:999px;
}
@media (max-width: 1100px){
  .mapOverlay{width:min(440px, 60%);}
}
@media (max-width: 820px){
  .grid{grid-template-columns:1fr;}
  .mapOverlay{width:min(520px, 86%);}
}

</style>
</head>

<body>
<div class="wrap">
  <h1>üé≤ Apex Dice RPG ‚Äî Kingdoms</h1>
  <p>Big world map ‚Ä¢ multiple kingdoms ‚Ä¢ war zones ‚Ä¢ time-based travel ‚Ä¢ persistent dungeons ‚Ä¢ class rules ‚Ä¢ spells ‚Ä¢ XP/levels ‚Ä¢ carry weight ‚Ä¢ mounts ‚Ä¢ banks ‚Ä¢ properties ‚Ä¢ jobs ‚Ä¢ in-game guide.</p>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="mapTitle">
        <div class="row">
          <span class="badge" id="modeBadge">Mode: Exploring</span>
          <span class="badge" id="locBadge">Location: ‚Äî</span>
          <span class="badge" id="clockBadge">Day 1 ‚Ä¢ 08:00</span>
          <span class="badge" id="regionBadge">Birth Region: ‚Äî</span>
        </div>
        <div class="row">
          <button class="secondary" id="areaLootBtn">Area Loot</button>
          <button class="secondary" id="searchBtn">Search / Explore</button>
          <button class="secondary" id="sleepBtn">Sleep</button>
          <button class="secondary" id="eatBtn">Eat (Ration)</button>
          <button class="secondary" id="visitBtn">Visit (City)</button>
          <button class="secondary" id="questBoardBtn">Quest Board</button>
          <button class="secondary" id="guideBtn">Guide</button>
        </div>
        <div class="hint">
          World: click connected locations ‚Ä¢ zoom wheel ‚Ä¢ drag to pan ‚Ä¢ Dungeon: move with <kbd>WASD</kbd>/<kbd>‚Üë‚Üì‚Üê‚Üí</kbd>
        </div>
      </div>

      <div class="mapCanvas" id="mapWrap">
        <canvas id="map"></canvas>
        <div class="tooltip" id="tooltip"></div>

        <div class="mapOverlay" id="mapOverlay">
          <div class="mapOverlayTitle">
            <div style="font-weight:800">üó∫Ô∏è Map Controls</div>
            <div class="smallMuted" id="mapStatus">Ready</div>
          </div>
          <div class="row" style="margin-top:10px">
            <button class="small secondary" id="ovCenterBtn" title="Center camera on your location">Center</button>
            <button class="small secondary" id="ovFitBtn" title="Zoom to fit the whole world">Fit</button>
            <button class="small secondary" id="ovHomeBtn" title="Go to your birth capital">Home</button>
          </div>
          <div class="row" style="margin-top:10px">
            <button class="small secondary" id="ovCostsBtn" title="Show/hide gold costs on routes">Costs: Off</button>
            <button class="small secondary" id="ovRegionsBtn" title="Show/hide kingdom regions">Regions: On</button>
            <button class="small secondary" id="ovMiniBtn" title="Show/hide minimap">Minimap: On</button>
          </div>
          <div class="smallMuted" style="margin-top:10px">
            Tip: Hover a connected node to see travel time + cost. Click a connected node to travel.
          </div>
        </div>


        <div class="youAreHere">
          <span class="pulseDot"></span>
          <div style="line-height:1.15">
            <div style="font-weight:700">You are here</div>
            <div class="smallMuted" id="youAreHereText">‚Äî</div>
            <div class="row" style="margin-top:8px">
              <button class="small secondary" id="centerBtn" title="Center camera on your location">Center</button>
              <button class="small secondary" id="fitBtn" title="Zoom to fit the whole world">Fit</button>
            </div>
          </div>
        </div>

        <div class="legendBox" id="legendBox">
          <div class="legendTitle">
            <b>Legend</b>
            <span class="smallMuted">Node types</span>
          </div>
          <div class="legendGrid">
            <div class="legendItem"><span class="legendIcon">‚≠ê</span>Capital</div>
            <div class="legendItem"><span class="legendIcon">üèôÔ∏è</span>City</div>
            <div class="legendItem"><span class="legendIcon">üèòÔ∏è</span>Town</div>
            <div class="legendItem"><span class="legendIcon">‚öì</span>Port</div>
            <div class="legendItem"><span class="legendIcon">üè∞</span>Castle</div>
            <div class="legendItem"><span class="legendIcon">üï≥Ô∏è</span>Cave</div>
            <div class="legendItem"><span class="legendIcon">‚õ∫</span>Camp</div>
            <div class="legendItem"><span class="legendIcon">üå≤</span>Forest</div>
            <div class="legendItem"><span class="legendIcon">üóø</span>Ruins</div>
            <div class="legendItem"><span class="legendIcon">‚ùó</span>Landmark</div>
          </div>
          <div class="legendKingdoms">
            <span class="kchip"><span class="kdot" style="background:rgba(124,92,255,.9)"></span>Valoria</span>
            <span class="kchip"><span class="kdot" style="background:rgba(251,113,133,.9)"></span>Kragmire</span>
            <span class="kchip"><span class="kdot" style="background:rgba(52,211,153,.9)"></span>Eldwyn</span>
            <span class="kchip"><span class="kdot" style="background:rgba(59,130,246,.9)"></span>SableCoast</span>
          </div>
          <div class="smallMuted" style="margin-top:8px">Hover a connected node to see travel time + cost.</div>
        </div>


        <div class="minimap" id="miniWrap" title="Click to jump ‚Ä¢ Use ‚§¢ to expand">
          <div class="miniHud">
            <div class="miniLabel">Mini Map</div>
            <button class="miniBtn" id="miniToggle" title="Expand / collapse">‚§¢</button>
          </div>
          <canvas id="minimap"></canvas>
        </div>
      </div>

      <hr>

      <div class="panel" id="interactPanel">
        <h3>Interact</h3>
        <div class="muted" id="interactHint">World: click a connected location to travel. Dungeons: stand on something to interact.</div>
        <div class="row" id="interactButtons" style="margin-top:10px"></div>
      </div>

      <hr>

      <h3 style="margin:0 0 8px">Log</h3>
      <div class="log" id="log"></div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <h2 style="margin:0">Character</h2>

      <div class="kv">
        <div class="tile">‚≠ê Level<br><strong id="level">1</strong><div class="sub"><span id="xpText">0 / 100 XP</span></div></div>
        <div class="tile">‚ù§Ô∏è HP<br><strong id="hp">20</strong><div class="sub">Max <span id="hpMax">20</span></div></div>
        <div class="tile">‚öîÔ∏è ATK<br><strong id="atk">2</strong><div class="sub">Base + Gear</div></div>
        <div class="tile">üõ°Ô∏è DEF<br><strong id="def">1</strong><div class="sub">Base + Gear</div></div>
      </div>

      <div class="progressWrap" title="XP progress">
        <div class="progressBar" id="xpBar"></div>
      </div>

      <div class="kv" style="margin-top:10px">
        <div class="tile" style="grid-column:span 2">‚ö° Energy<br><strong id="energy">10</strong><div class="sub">Max <span id="energyMax">10</span></div></div>
        <div class="tile" style="grid-column:span 2">üçó Hunger<br><strong id="hunger">10</strong><div class="sub">0 = starving (HP drain)</div></div>
      </div>

      <div class="kv" style="margin-top:10px">
        <div class="tile" style="grid-column:span 2">ü™ô Gold<br><strong id="gold">0</strong><div class="sub">Cash on hand</div></div>
        <div class="tile" style="grid-column:span 2">üè¶ Bank<br><strong id="bank">0</strong><div class="sub">Interest daily ‚Ä¢ fee to withdraw</div></div>
      </div>

      <div class="kv" style="margin-top:10px">
        <div class="tile" style="grid-column:span 2">üéí Carry<br><strong id="carry">0/0</strong><div class="sub">Max from STR (+mount)</div></div>
        <div class="tile" style="grid-column:span 2">üê¥ Mount<br><strong id="mount">None</strong><div class="sub">Travel faster + carry</div></div>
      </div>

      <div class="panel" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <div>
            <div style="font-weight:700" id="charLine">‚Äî</div>
            <div class="smallMuted" id="charLine2">‚Äî</div>
          </div>
          <div class="smallMuted">
            Age: <b id="age">18</b> ‚Ä¢ Date: <b id="dateText">Year 1 ‚Ä¢ Spring ‚Ä¢ Day 1</b>
          </div>
        </div>
      </div>

      <h3 style="margin:16px 0 10px">Spells</h3>
      <div class="panel">
        <div class="smallMuted" id="spellInfo">No spells.</div>
        <div class="row" style="margin-top:10px" id="spellSlotsRow"></div>
      </div>

      <h3 style="margin:16px 0 10px">Equipment</h3>
      <div class="inventory">
        <div class="slot" id="weaponSlot"></div>
        <div class="slot" id="armorSlot"></div>
        <div class="slot" id="accessorySlot"></div>
        <div class="slot">
          <strong>Consumables</strong>
          <div class="itemName">Rations: <b id="rationCount">0</b></div>
          <div class="row" style="justify-content:center">
            <button class="small secondary" id="buyFoodBtn">Buy Ration (5g)</button>
          </div>
        </div>
      </div>

      <h3 style="margin:16px 0 10px">Backpack</h3>
      <div class="bagGrid" id="bag"></div>

      <hr>
      <div class="row">
        <button class="secondary" id="resetBtn">Reset Save</button>
      </div>
    </div>
  </div>
</div>

<!-- Generic Modal -->
<div class="overlay" id="overlay">
  <div class="modal">
    <div class="top">
      <h3 id="modalTitle">Notice</h3>
      <button class="secondary small" id="closeModal">Close</button>
    </div>
    <p id="modalBody"></p>
  </div>
</div>

<!-- Character Creator (locks permanently after confirm) -->
<div class="overlay" id="creatorOverlay">
  <div class="modal">
    <div class="top">
      <h3>Character Creator</h3>
      <span class="lockTag" id="creatorLockTag">Unconfirmed</span>
    </div>
    <p>Create your character. Once you confirm, all fields + stat rolls lock permanently (no rerolls).</p>

    <div class="formGrid">
      <div class="panel">
        <div class="smallMuted">Name</div>
        <input id="ccName" placeholder="e.g., Alaric" maxlength="20">
        <div class="smallMuted" style="margin-top:10px">Sex</div>
        <select id="ccSex">
          <option value="Male">Male</option>
          <option value="Female">Female</option>
          <option value="Nonbinary">Nonbinary</option>
        </select>
      </div>

      <div class="panel">
        <div class="smallMuted">Race</div>
        <select id="ccRace"></select>
        <div class="smallMuted" style="margin-top:10px">Class</div>
        <select id="ccClass"></select>
      </div>

      <div class="panel">
        <div class="smallMuted">Birth Region (starting kingdom)</div>
        <select id="ccBirth"></select>
        <div class="smallMuted" style="margin-top:10px">Notes</div>
        <div class="smallMuted">Birth region sets your starting city and flags faction relationships.</div>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
        <div>
          <div style="font-weight:700">Rolled Stats (4d6 drop lowest)</div>
          <div class="smallMuted">Stats affect carry weight, combat, spellcasting, and skill checks.</div>
        </div>
        <div class="row">
          <button class="secondary" id="ccRollBtn">Roll Stats</button>
          <button id="ccConfirmBtn">Confirm Character</button>
        </div>
      </div>

      <div class="statGrid" id="ccStats"></div>
      <div class="smallMuted" style="margin-top:10px" id="ccClassRules">‚Äî</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
        <div>
          <div style="font-weight:700">Important</div>
          <div class="smallMuted">After confirming, rerolls and changes are disabled. Reset Save to start over.</div>
        </div>
        <button class="secondary small" id="ccCloseHint" disabled>Close (disabled until confirmed)</button>
      </div>
    </div>
  </div>
</div>

<!-- Combat Screen -->
<div class="combatOverlay" id="combatOverlay">
  <div class="combatScreen">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="badge" id="combatTitle">Combat</div>
      <button class="secondary" id="combatExitBtn" disabled>Exit</button>
    </div>

    <div class="combatGrid" style="margin-top:12px">
      <div class="combatCard">
        <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
          <div>
            <div style="font-size:20px;font-weight:800" id="enemyName">Enemy</div>
            <div class="smallMuted" id="enemyMeta">‚Äî</div>
          </div>
          <div style="text-align:right">
            <div class="smallMuted">Enemy HP</div>
            <div style="font-weight:800"><span id="enemyHpText">0</span></div>
          </div>
        </div>
        <div class="hpbarWrap" style="margin-top:10px">
          <div class="hpbar" id="enemyHpBar"></div>
        </div>
        <div class="portrait" id="enemyPortrait" style="margin-top:12px">üó°Ô∏è</div>

        <div class="combatActions">
          <button id="combatAttackBtn">Attack (d20)</button>
          <button class="secondary" id="combatSpellBtn">Cast Spell</button>
          <button class="secondary" id="combatItemBtn">Use Item</button>
          <button class="secondary" id="combatFleeBtn">Flee</button>
        </div>

        <div class="panel" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap">
            <div>
              <div style="font-weight:800" id="playerNameLine">You</div>
              <div class="smallMuted" id="playerACLine">AC ‚Äî</div>
            </div>
            <div style="text-align:right">
              <div class="smallMuted">Your HP</div>
              <div style="font-weight:800"><span id="playerHpText">0</span></div>
            </div>
          </div>
          <div class="hpbarWrap" style="margin-top:10px">
            <div class="hpbar hpbarGood" id="playerHpBar"></div>
          </div>
        </div>
      </div>

      <div class="combatCard">
        <div class="tabs">
          <button class="tabBtn active" data-tab="clog">Combat Log</button>
          <button class="tabBtn" data-tab="spells">Spells</button>
          <button class="tabBtn" data-tab="items">Items</button>
        </div>

        <div id="tab-clog" style="margin-top:10px">
          <div class="combatLog" id="combatLog"></div>
        </div>

        <div id="tab-spells" class="hidden" style="margin-top:10px">
          <div class="panel">
            <div class="smallMuted">Select a spell to cast (consumes spell slots, if required).</div>
            <div class="row" id="combatSpellList" style="margin-top:10px"></div>
          </div>
        </div>

        <div id="tab-items" class="hidden" style="margin-top:10px">
          <div class="panel">
            <div class="smallMuted">Consumables only during combat.</div>
            <div class="row" id="combatItemList" style="margin-top:10px"></div>
          </div>
        </div>

        <div class="panel" style="margin-top:12px">
          <div style="font-weight:800">War Zone Note</div>
          <div class="smallMuted">Some roads in the two warring kingdoms have ongoing skirmishes (more encounters).</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   APEX DICE RPG ‚Äî BIG WORLD UPDATE
   - Very noticeable "you are here" marker + minimap viewport
   - Stat rolls lock permanently after confirm (no reroll)
   - Creator fields lock after confirm
   - More classes + spell system + spell slots
   - Weapon/armor restrictions by class
   - Level + XP bar
   - Combat uses a dedicated combat screen
   - Map expanded to a huge coordinate space + multiple kingdoms overlays
   - War kingdoms w/ skirmish zones, traders/bandits on roads
   - Snow areas + giant ice mountain "Frostspire" (no entrance; wastes time)
   - Shops by type + carry weight + mounts affect travel speed
   - Banks (big cities only) w/ interest + withdrawal fee
   - City population display
   - Non-adventuring jobs
   - Simple properties + businesses + income
   - In-game guide
   - Calendar + aging
========================================================= */

/* =========================
   SAVE + STATE
========================= */
const SAVE_KEY = "apexDiceRpg_v6_bigworld";

const defaultState = () => ({
  // character
  characterCreated: false,
  creatorLocked: false,
  char: {
    name: "",
    sex: "Male",
    race: "Human",
    class: "Fighter",
    birthKingdom: "Valoria",
    age: 18,
    // stats
    str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10,
    // leveling
    level: 1,
    xp: 0,
    // spells + slots
    spellsKnown: [],
    spellSlots: {1:0,2:0,3:0,4:0,5:0},
    // life sim
    spouse: null,
    kids: 0,
    jobsCompleted: 0
  },

  // core vitals
  hp: 20, hpMax: 20,
  energy: 10, energyMax: 10,
  hunger: 10, hungerMax: 10,

  atkBase: 2,
  defBase: 1,

  gold: 15,
  bank: 0,
  keys: 0,

  weapon: null,
  armor: null,
  accessory: null,

  // mounts / carry
  mount: null, // {type:"horse"|"wagon", name, speedMult, carryBonus, cost}
  properties: [], // {type:"land"|"house"|"castle"|"business", name, kingdom, nodeId, incomePerDay, boughtDay}
  businesses: [], // subset with income

  bag: [
    {type:"consumable", name:"Ration", kind:"food", qty:2, weight:0.5},
  ],

  mode: "world",          // world | dungeon | combat
  currentNode: null,
  lastSafeNode: null,

  // time / calendar
  year: 1,
  seasonIndex: 0, // 0 Spring, 1 Summer, 2 Autumn, 3 Winter
  dayOfSeason: 1, // 1..30
  day: 1,         // legacy counter
  minutes: 8*60,  // 08:00
  energyDrainPerDayMin: 1,
  energyDrainPerDayMax: 2,
  energyDrainToday: 1,

  // per-visit loot limiting
  visitCounter: 1,
  nodeVisitStamp: {},
  nodeLootStamp: {},

  // persistent dungeons keyed by nodeId
  dungeons: {},

  dungeonId: null,

  // combat
  enemy: null,
  enemyMeta: null,
  pendingArrival: null,
  combatLog: [],

  // quests
  quests: {},
  activeQuestId: null,

  // world encounters & flags
  lastInterestPaidDay: 0,
  lastIncomeDay: 0,

  log: []
});

let state = JSON.parse(localStorage.getItem(SAVE_KEY) || "null") || defaultState();

/* =========================
   DOM helpers
========================= */
const $ = id => document.getElementById(id);
const mapCanvas = $("map");
const ctx = mapCanvas.getContext("2d");
const miniCanvas = $("minimap");
const mctx = miniCanvas.getContext("2d");

function save(){ localStorage.setItem(SAVE_KEY, JSON.stringify(state)); }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function roll(s){ return Math.floor(Math.random()*s)+1; }
function fmtTime(mins){
  mins = ((mins%1440)+1440)%1440;
  const h = Math.floor(mins/60);
  const m = mins%60;
  return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}`;
}
function pushLog(msg){
  state.log.push(msg);
  if(state.log.length>450) state.log = state.log.slice(-450);
}
function pushCombat(msg){
  state.combatLog.push(msg);
  if(state.combatLog.length>300) state.combatLog = state.combatLog.slice(-300);
}

/* =========================
   RNG (seeded)
========================= */
function makeRNG(seedStr){
  let h = 2166136261;
  for(let i=0;i<seedStr.length;i++){ h ^= seedStr.charCodeAt(i); h = Math.imul(h, 16777619); }
  let s = h >>> 0;
  return function(){
    s ^= s << 13; s >>>= 0;
    s ^= s >> 17; s >>>= 0;
    s ^= s << 5;  s >>>= 0;
    return (s >>> 0) / 4294967296;
  };
}
const rngWorld = makeRNG("apex_bigworld_v6");

/* =========================
   Classes, races, proficiencies, spells
========================= */
const RACES = [
  {name:"Human", bonus:{str:0,dex:0,con:0,int:0,wis:0,cha:0}, note:"Adaptable."},
  {name:"Elf", bonus:{dex:2,wis:1}, note:"Keen senses."},
  {name:"Dwarf", bonus:{con:2,str:1}, note:"Sturdy."},
  {name:"Halfling", bonus:{dex:2,cha:1}, note:"Lucky."},
  {name:"Orc", bonus:{str:2,con:1}, note:"Powerful."},
  {name:"Tiefling", bonus:{cha:2,int:1}, note:"Infernal heritage."},
];

const CLASS_RULES = {
  "Fighter": {
    caster:false,
    weapons:["simple","martial"],
    armor:["light","medium","heavy","shield"],
    spellcasting:null,
    base:{atk:3,def:2,hpMax:24}
  },
  "Paladin": {
    caster:true,
    weapons:["simple","martial"],
    armor:["light","medium","heavy","shield"],
    spellcasting:{stat:"cha", type:"half"},
    base:{atk:3,def:2,hpMax:22}
  },
  "Ranger": {
    caster:true,
    weapons:["simple","martial"],
    armor:["light","medium","shield"],
    spellcasting:{stat:"wis", type:"half"},
    base:{atk:3,def:1,hpMax:22}
  },
  "Rogue": {
    caster:false,
    weapons:["simple","finesse","ranged"],
    armor:["light"],
    spellcasting:null,
    base:{atk:3,def:1,hpMax:20}
  },
  "Monk": {
    caster:false,
    weapons:["simple","monk"],
    armor:[], // no armor
    spellcasting:null,
    base:{atk:3,def:1,hpMax:20}
  },
  "Barbarian": {
    caster:false,
    weapons:["simple","martial"],
    armor:["light","medium"],
    spellcasting:null,
    base:{atk:4,def:1,hpMax:26}
  },
  "Cleric": {
    caster:true,
    weapons:["simple"],
    armor:["light","medium","shield"],
    spellcasting:{stat:"wis", type:"full"},
    base:{atk:2,def:2,hpMax:20}
  },
  "Wizard": {
    caster:true,
    weapons:["simple"],
    armor:[],
    spellcasting:{stat:"int", type:"full"},
    base:{atk:1,def:0,hpMax:18}
  },
  "Sorcerer": {
    caster:true,
    weapons:["simple"],
    armor:[],
    spellcasting:{stat:"cha", type:"full"},
    base:{atk:1,def:0,hpMax:18}
  },
  "Warlock": {
    caster:true,
    weapons:["simple"],
    armor:["light"],
    spellcasting:{stat:"cha", type:"pact"},
    base:{atk:2,def:0,hpMax:19}
  },
  "Bard": {
    caster:true,
    weapons:["simple","finesse","ranged"],
    armor:["light"],
    spellcasting:{stat:"cha", type:"full"},
    base:{atk:2,def:1,hpMax:19}
  },
  "Druid": {
    caster:true,
    weapons:["simple"],
    armor:["light","medium","shield"],
    spellcasting:{stat:"wis", type:"full"},
    base:{atk:2,def:1,hpMax:20}
  }
};

// Spell slot tables (simple)
const SLOT_TABLE_FULL = {
  1:{1:2}, 2:{1:3}, 3:{1:4,2:2}, 4:{1:4,2:3},
  5:{1:4,2:3,3:2}, 6:{1:4,2:3,3:3}, 7:{1:4,2:3,3:3,4:1},
  8:{1:4,2:3,3:3,4:2}, 9:{1:4,2:3,3:3,4:3,5:1}, 10:{1:4,2:3,3:3,4:3,5:2}
};
const SLOT_TABLE_HALF = {
  1:{}, 2:{1:2}, 3:{1:3}, 4:{1:3},
  5:{1:4,2:2}, 6:{1:4,2:2}, 7:{1:4,2:3}, 8:{1:4,2:3},
  9:{1:4,2:3,3:2}, 10:{1:4,2:3,3:2}
};
// Warlock pact (very simplified)
const SLOT_TABLE_PACT = {
  1:{1:1}, 2:{1:2}, 3:{2:2}, 4:{2:2}, 5:{3:2},
  6:{3:2}, 7:{4:2}, 8:{4:2}, 9:{5:2}, 10:{5:2}
};

const SPELLS = {
  // name, level, kind, effect
  "Wizard":[
    {name:"Magic Missile", level:1, type:"damage", dmgDice:4, dmgBonus:2, text:"Guaranteed hit."},
    {name:"Fire Bolt", level:0, type:"damage", dmgDice:6, dmgBonus:0, text:"Cantrip ranged."},
    {name:"Shield", level:1, type:"buff", acBonus:3, turns:1, text:"+AC for one enemy attack."},
    {name:"Sleep", level:1, type:"control", text:"Chance to skip enemy turn."}
  ],
  "Cleric":[
    {name:"Sacred Flame", level:0, type:"damage", dmgDice:6, dmgBonus:0, text:"Cantrip radiant."},
    {name:"Guiding Bolt", level:1, type:"damage", dmgDice:8, dmgBonus:2, text:"Big hit."},
    {name:"Cure Wounds", level:1, type:"heal", healDice:6, healBonus:3, text:"Heals you."},
    {name:"Bless", level:1, type:"buff", atkBonus:2, turns:2, text:"+ATK for a short time."}
  ],
  "Sorcerer":[
    {name:"Ray of Frost", level:0, type:"damage", dmgDice:6, dmgBonus:0, text:"Cantrip."},
    {name:"Chaos Bolt", level:1, type:"damage", dmgDice:8, dmgBonus:2, text:"Wild damage."},
    {name:"Mage Armor", level:1, type:"buff", defBonus:2, turns:999, text:"+DEF until you sleep."},
    {name:"Charm", level:1, type:"control", text:"Chance to skip enemy turn."}
  ],
  "Warlock":[
    {name:"Eldritch Blast", level:0, type:"damage", dmgDice:6, dmgBonus:1, text:"Signature cantrip."},
    {name:"Hex", level:1, type:"debuff", dmgBonus:2, turns:3, text:"Extra damage for a while."},
    {name:"Darkness", level:1, type:"control", text:"Chance to reduce enemy hit chance."},
    {name:"Drain Life", level:1, type:"lifesteal", dmgDice:6, dmgBonus:2, text:"Deal damage, heal some."}
  ],
  "Bard":[
    {name:"Vicious Mockery", level:0, type:"damage", dmgDice:4, dmgBonus:0, text:"Cantrip."},
    {name:"Healing Word", level:1, type:"heal", healDice:4, healBonus:3, text:"Quick heal."},
    {name:"Dissonant Whispers", level:1, type:"damage", dmgDice:6, dmgBonus:2, text:"Psychic damage."},
    {name:"Inspire", level:1, type:"buff", atkBonus:2, turns:2, text:"+ATK briefly."}
  ],
  "Druid":[
    {name:"Thorn Whip", level:0, type:"damage", dmgDice:6, dmgBonus:0, text:"Cantrip."},
    {name:"Entangle", level:1, type:"control", text:"Chance to skip enemy turn."},
    {name:"Goodberry", level:1, type:"heal", healDice:4, healBonus:5, text:"Heals."},
    {name:"Barkskin", level:1, type:"buff", defBonus:2, turns:999, text:"+DEF until you sleep."}
  ],
  "Paladin":[
    {name:"Divine Smite", level:1, type:"damage", dmgDice:8, dmgBonus:2, text:"Heavy melee smite."},
    {name:"Lay on Hands", level:1, type:"heal", healDice:6, healBonus:4, text:"Heals."}
  ],
  "Ranger":[
    {name:"Hunter‚Äôs Mark", level:1, type:"debuff", dmgBonus:2, turns:3, text:"Extra damage."},
    {name:"Cure", level:1, type:"heal", healDice:4, healBonus:3, text:"Heals."}
  ]
};

// Items catalog (weight + tags + shop category)
const ITEMS = [
  {type:"weapon", name:"Dagger", atk:1, weight:1, tags:["simple","finesse"], shop:"weapon", cost:10},
  {type:"weapon", name:"Shortsword", atk:2, weight:2, tags:["martial","finesse"], shop:"weapon", cost:25},
  {type:"weapon", name:"Longsword", atk:3, weight:3, tags:["martial"], shop:"weapon", cost:40},
  {type:"weapon", name:"Bow", atk:2, weight:2, tags:["ranged","martial"], shop:"weapon", cost:35},
  {type:"weapon", name:"Quarterstaff", atk:1, weight:2, tags:["simple","monk"], shop:"weapon", cost:12},
  {type:"armor", name:"Cloth Robe", def:1, weight:2, tags:["light"], shop:"armor", cost:12},
  {type:"armor", name:"Leather Armor", def:2, weight:4, tags:["light"], shop:"armor", cost:25},
  {type:"armor", name:"Chain Shirt", def:3, weight:7, tags:["medium"], shop:"armor", cost:55},
  {type:"armor", name:"Plate Armor", def:5, weight:12, tags:["heavy"], shop:"armor", cost:140},
  {type:"accessory", name:"Ring of Luck", atk:1, weight:0.2, tags:["any"], shop:"misc", cost:75},
  {type:"accessory", name:"Amulet of Guarding", def:1, weight:0.3, tags:["any"], shop:"misc", cost:70},
  {type:"consumable", name:"Ration", kind:"food", qty:1, weight:0.5, tags:["any"], shop:"food", cost:5}
];

const MOUNTS = [
  {type:"horse", name:"Horse", speedMult:1.25, carryBonus:20, cost:120},
  {type:"wagon", name:"Horse + Wagon", speedMult:1.40, carryBonus:55, cost:260}
];

/* =========================
   Derived calculations
========================= */
function abilityMod(score){ return Math.floor((score - 10) / 2); }
function getAtk(){
  const c = state.char;
  // base scales with level modestly + STR/DEX mod depending on weapon tags
  const w = state.weapon;
  const strm = abilityMod(c.str);
  const dexm = abilityMod(c.dex);
  let statMod = strm;
  if(w?.tags?.includes("finesse") || w?.tags?.includes("ranged") || (c.class==="Rogue"||c.class==="Monk")) statMod = Math.max(strm, dexm);
  const lvlBonus = Math.floor((c.level-1)/2);
  const gear = (w?.atk||0) + (state.accessory?.atk||0);
  return state.atkBase + gear + statMod + lvlBonus;
}
function getDef(){
  const c = state.char;
  const dexm = abilityMod(c.dex);
  const base = state.defBase + (state.armor?.def||0) + (state.accessory?.def||0);
  // monks get some dex scaling when unarmored
  if(c.class==="Monk" && !state.armor) return base + Math.max(0, dexm);
  // light armor allows dex contribution
  if(state.armor?.tags?.includes("light")) return base + Math.max(0, dexm);
  // medium armor caps dex at +2
  if(state.armor?.tags?.includes("medium")) return base + Math.min(2, Math.max(0, dexm));
  return base;
}
function getAC(){
  return 10 + getDef();
}
function carryMax(){
  const c = state.char;
  const base = 30 + (c.str * 2); // simple carry formula
  const mountBonus = state.mount?.carryBonus || 0;
  return base + mountBonus;
}
function carryNow(){
  let w = 0;
  // equipped
  if(state.weapon?.weight) w += state.weapon.weight;
  if(state.armor?.weight) w += state.armor.weight;
  if(state.accessory?.weight) w += state.accessory.weight;
  // bag
  for(const it of state.bag){
    if(it.type==="consumable") w += (it.weight||0) * (it.qty||1);
    else w += (it.weight||0);
  }
  return Math.round(w*10)/10;
}
function xpToNext(level){
  // smooth but meaningful
  return 100 + (level-1)*55 + Math.floor((level-1)*(level-1)*10);
}
function isCasterClass(cls){
  return !!CLASS_RULES[cls]?.caster;
}
function slotTableForClass(cls){
  const t = CLASS_RULES[cls]?.spellcasting?.type;
  if(t==="full") return SLOT_TABLE_FULL;
  if(t==="half") return SLOT_TABLE_HALF;
  if(t==="pact") return SLOT_TABLE_PACT;
  return null;
}
function refreshSpellSlotsToMax(){
  const cls = state.char.class;
  const table = slotTableForClass(cls);
  const lvl = state.char.level;
  const max = {1:0,2:0,3:0,4:0,5:0};
  if(table && table[lvl]){
    for(const k of Object.keys(table[lvl])) max[k] = table[lvl][k];
  }
  // keep current slots at max (this is max pool)
  state.char.spellSlots = {...max};
}
function classRulesText(cls){
  const r = CLASS_RULES[cls];
  const weapons = r.weapons.length ? r.weapons.join(", ") : "none";
  const armor = r.armor.length ? r.armor.join(", ") : "none";
  const caster = r.caster ? `Caster (${r.spellcasting.type}) ‚Ä¢ Casting stat: ${r.spellcasting.stat.toUpperCase()}` : "Non-caster";
  return `Class rules ‚Äî ${caster}. Weapon proficiencies: ${weapons}. Armor proficiencies: ${armor}.`;
}
function canEquip(item){
  const cls = state.char.class;
  const rules = CLASS_RULES[cls];
  if(!rules) return true;

  if(item.type==="weapon"){
    // any weapon prof match tag
    const tags = item.tags||[];
    return rules.weapons.some(req => tags.includes(req));
  }
  if(item.type==="armor"){
    const tags = item.tags||[];
    return rules.armor.some(req => tags.includes(req));
  }
  if(item.type==="accessory"){
    return true;
  }
  return true;
}

/* =========================
   WORLD: Huge map w/ kingdoms + biomes + war
========================= */
// Coordinate space is HUGE (20x+ bigger than old). Think ~ 30k x 18k.
const WORLD_W = 32000;
const WORLD_H = 18000;

// Kingdoms / regions (transparent overlays)
const KINGDOMS = [
  { id:"Valoria", name:"Kingdom of Valoria", color:"var(--k1)", labelX:8200, labelY:5600, war:true },
  { id:"Kragmire", name:"Kragmire Dominion",  color:"var(--k2)", labelX:15500, labelY:7200, war:true },
  { id:"Eldwyn",  name:"Eldwyn Freeholds",   color:"var(--k3)", labelX:11200, labelY:11500, war:false },
  { id:"SableCoast", name:"Sable Coast League", color:"var(--k4)", labelX:21000, labelY:9800, war:false }
];

// Two at war:
const WAR_PAIR = ["Valoria","Kragmire"];

// Biomes (visual shading areas)
const BIOMES = [
  {id:"grasslands", name:"Grasslands", tint:"rgba(52,211,153,.10)"},
  {id:"woodland", name:"Woodland", tint:"rgba(34,197,94,.12)"},
  {id:"desert", name:"Desert", tint:"rgba(251,191,36,.10)"},
  {id:"tundra", name:"Tundra", tint:"rgba(148,163,184,.12)"},
  {id:"arctic", name:"Arctic", tint:"rgba(147,197,253,.14)"},
  {id:"snow", name:"Snowfields", tint:"rgba(226,232,240,.10)"},
];

// Landmass: use a noisy coastline function to define land vs sea
function coastNoise(x){
  // deterministic wavy coastline
  const a = Math.sin(x*0.00045)*880;
  const b = Math.sin(x*0.0013 + 1.7)*360;
  const c = Math.sin(x*0.0022 + 0.4)*180;
  return 7800 + a + b + c;
}
function isLand(x,y){
  // land above coastline + some inland bays
  const cy = coastNoise(x);
  // big bay cut
  const bay = (x>22000 && x<28000) ? 1100 : 0;
  // northern fjord indentation
  const fjord = (x>14500 && x<17500) ? 900 : 0;
  return y < (cy - bay + (Math.sin(x*0.00022+2.4)*220) - fjord);
}


// Kingdom ownership: organic regions (noise + distance to kingdom centers)
const KINGDOM_CENTERS = {
  Valoria:   {x: 7600,  y: 5200,  w: 0.96},
  Kragmire:  {x: 15600, y: 6900,  w: 0.98},
  Eldwyn:    {x: 11800, y: 12150, w: 1.05},
  SableCoast:{x: 22800, y: 9800,  w: 1.02},
};
function kingdomAt(x,y){
  if(!isLand(x,y)) return null;
  // large-scale variation so borders aren't straight lines
  const n = fbm(x+9000, y-4200, 6500); // [-1..1]
  let bestK = "Eldwyn";
  let best = Infinity;
  let i=0;
  for(const k of Object.keys(KINGDOM_CENTERS)){
    const c = KINGDOM_CENTERS[k];
    const dx = x - c.x, dy = y - c.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    const wobble = 1 + (n*0.10) + (fbm(x + i*1111, y - i*777, 4200)*0.07);
    const score = (d * c.w) * wobble;
    if(score < best){ best = score; bestK = k; }
    i++;
  }
  return bestK;
}

function biomeAt(x,y){
  // snow/arctic in far north, desert in far east-south, tundra mid-north, woodland near central, grass default
  if(y < 2600) return "arctic";
  if(y < 3800) return "snow";
  if(x > 24000 && y > 9800 && y < 13500) return "desert";
  if(y < 5200) return "tundra";
  if(x < 18500 && y > 9200) return "woodland";
  return "grasslands";
}

// Generate lots of nodes (cities/camps/caves/forests/ports) + capital + ice mountain
function genNodes(){
  const nodes = [];

  // helper to place on land
  function placeOnLand(name, type, x, y, extra={}){
    nodes.push({id: slug(name), name, type, x, y, ...extra});
  }
  function placeNearLand(name,type, x,y, extra={}){
    // nudge up until land
    let yy=y;
    for(let i=0;i<60;i++){
      if(isLand(x,yy)) break;
      yy -= 80;
    }
    placeOnLand(name,type,x,yy,extra);
  }

  // Core capitals / major cities
  placeOnLand("Aurelia (Capital)", "capital", 7600, 5200, {population: 480000, bigCity:true, establishments:["church","tavern","inn","weapon","armor","food","misc","library","guild","bank","property","jobs","stable"]});
  placeOnLand("Kragholm (Capital)", "capital", 15600, 6900, {population: 410000, bigCity:true, establishments:["church","tavern","inn","weapon","armor","food","misc","library","guild","bank","property","jobs","stable"]});
  placeOnLand("Eldspire", "city", 11800, 12150, {population: 155000, bigCity:true, establishments:["church","tavern","inn","weapon","armor","food","misc","library","guild","bank","property","jobs","stable"]});
  placeNearLand("Sablegate", "city", 22800, 9800, {population: 210000, bigCity:true, establishments:["church","tavern","inn","weapon","armor","food","misc","library","guild","bank","property","jobs","stable"]});

  // Ports along coast
  placeNearLand("Grandport", "port", 21200, 7800, {population: 86000, bigCity:false, establishments:["tavern","inn","weapon","armor","food","misc","guild","bank","jobs","stable"]});
  placeNearLand("Blackwake Harbor", "port", 25500, 7200, {population: 92000, bigCity:false, establishments:["tavern","inn","weapon","armor","food","misc","guild","jobs","stable"]});
  placeNearLand("Mistcoil Docks", "port", 17000, 8000, {population: 53000, bigCity:false, establishments:["tavern","inn","weapon","food","misc","jobs"]});
  placeNearLand("Saltwind Quay", "port", 28500, 8600, {population: 47000, bigCity:false, establishments:["tavern","inn","weapon","food","misc","jobs"]});

  // Giant snow/ice mountain (no entrance)
  placeOnLand("Frostspire (Unfathomable)", "landmark", 14600, 2600, {population:0, bigCity:false, impassable:true, note:"A massive ice mountain. Rumors say there's a way inside‚Ä¶ but there isn't."});

  // Scatter towns/camps/caves/forests
  const types = ["town","town","town","camp","camp","cave","forest"];
  for(let i=0;i<90;i++){
    let x = 1200 + Math.floor(rngWorld()*(WORLD_W-2400));
    let y = 800 + Math.floor(rngWorld()*(WORLD_H-1600));
    // force on land
    let tries=0;
    while(!isLand(x,y) && tries++<200){
      x = 1200 + Math.floor(rngWorld()*(WORLD_W-2400));
      y = 800 + Math.floor(rngWorld()*(WORLD_H-1600));
    }
    if(!isLand(x,y)) continue;

    const k = kingdomAt(x,y) || "Eldwyn";
    const b = biomeAt(x,y);
    const t = types[Math.floor(rngWorld()*types.length)];

    const baseName = ({
      town:["Stonehaven","Emberrest","Pinewatch","Redfen","Wyrmford","Hollowmere","Duskvale","Rivermarch","Goldrun","Thornfield","Greybarrow","Sunmead","Oakridge","Cinderfall","Briarstead"],
      camp:["Wayfarer Camp","Ranger Post","Pilgrim Camp","Border Camp","Hunter‚Äôs Camp","Scout Camp","Timber Camp"],
      cave:["Mournroot Cave","Saltwind Grotto","Cavern of Ash","Gloomhollow","Fangdepth","Ruinmouth"],
      forest:["Gloamwood","Briarwild","Whispergrove","Grimthicket","Silverpine","Ashenwood"]
    })[t];
    const name = baseName[Math.floor(rngWorld()*baseName.length)] + " " + (i+1);

    const pop = t==="town" ? (8000 + Math.floor(rngWorld()*42000)) : (t==="camp" ? (200 + Math.floor(rngWorld()*900)) : 0);
    const est = (t==="town") ? ["church","tavern","inn","weapon","armor","food","misc","jobs","stable"] :
                (t==="camp") ? ["tavern","food","jobs"] :
                (t==="cave"||t==="forest") ? [] : [];

    nodes.push({
      id: slug(name),
      name,
      type:t,
      x,y,
      kingdom:k,
      biome:b,
      population: pop,
      bigCity: t==="town" && pop>38000,
      dungeonKind: (t==="forest")?"forest":(t==="cave")?"cave":null,
      establishments: est
    });
  }


  // Decorate some towns as castles/ruins for map variety (keeps node IDs stable)
  function strHash01(s){
    let h = 2166136261;
    for(let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return ((h>>>0) % 100000) / 100000; // [0..1)
  }
  for(const n of nodes){
    if(n.type!=="town") continue;
    const h = strHash01(n.id);
    if(h < 0.10){
      n.type = "castle";
      n.population = 0;
      n.establishments = ["jobs","stable"];
    } else if(h < 0.16){
      n.type = "ruins";
      n.population = 0;
      n.establishments = [];
    }
  }

  // Ensure kingdom / biome on all nodes
  for(const n of nodes){
    if(!n.kingdom) n.kingdom = kingdomAt(n.x,n.y) || "Eldwyn";
    if(!n.biome) n.biome = biomeAt(n.x,n.y);
  }

  // Make sure capitals have correct kingdom & biome
  for(const n of nodes){
    if(n.type==="capital"){
      n.kingdom = (n.name.includes("Aurelia") ? "Valoria" : "Kragmire");
      n.biome = biomeAt(n.x,n.y);
    }
  }

  return nodes;
}

function slug(s){
  return s.toLowerCase().replace(/[^a-z0-9]+/g,"_").replace(/^_|_$/g,"");
}

let world = { nodes: genNodes(), edges: [] };
let nodeById = {};
function indexWorld(){
  nodeById = Object.fromEntries(world.nodes.map(n=>[n.id,n]));
}
indexWorld();

// Build edges: connect nodes (roads/sea), enforce connectivity, and compute travel costs
function buildEdges(){
  const edges = [];
  const nodes = world.nodes;

  function dist(a,b){
    const dx=a.x-b.x, dy=a.y-b.y;
    return Math.sqrt(dx*dx+dy*dy);
  }
  function key(a,b){ return a<b ? `${a}::${b}` : `${b}::${a}`; }

  function segmentMostlyLand(a,b){
    const steps = 18;
    let landCount=0;
    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const x=a.x+(b.x-a.x)*t;
      const y=a.y+(b.y-a.y)*t;
      if(isLand(x,y)) landCount++;
    }
    return landCount/(steps+1) > 0.75;
  }
  function segmentMostlySea(a,b){
    const steps = 18;
    let seaCount=0;
    for(let i=0;i<=steps;i++){
      const t=i/steps;
      const x=a.x+(b.x-a.x)*t;
      const y=a.y+(b.y-a.y)*t;
      if(!isLand(x,y)) seaCount++;
    }
    return seaCount/(steps+1) > 0.80;
  }

  const used = new Set();

  // Roads: connect to nearest neighbors on land
  for(const n of nodes){
    if(n.type==="landmark" || n.impassable) continue;
    if(!isLand(n.x,n.y)) continue;

    const candidates = nodes
      .filter(m => m.id!==n.id && m.type!=="landmark" && !m.impassable && isLand(m.x,m.y))
      .map(m => ({m, d:dist(n,m)}))
      .sort((a,b)=>a.d-b.d)
      .slice(0, 7);

    for(const c of candidates){
      if(c.d > 5600) continue;
      const m = c.m;
      const k = key(n.id,m.id);
      if(used.has(k)) continue;
      if(!segmentMostlyLand(n,m)) continue;

      used.add(k);
      const warEdge = (WAR_PAIR.includes(n.kingdom) && WAR_PAIR.includes(m.kingdom) && n.kingdom!==m.kingdom);
      edges.push({a:n.id,b:m.id, kind:"road", war: warEdge});
    }
  }

  // Sea routes between ports
  const ports = nodes.filter(n=>n.type==="port");
  for(const p of ports){
    const nearestPorts = ports
      .filter(q=>q.id!==p.id)
      .map(q=>({q, d:dist(p,q)}))
      .sort((a,b)=>a.d-b.d)
      .slice(0, 3);
    for(const {q,d} of nearestPorts){
      if(d > 12000) continue;
      const k = key(p.id,q.id);
      if(used.has(k)) continue;
      if(!segmentMostlySea(p,q)) continue;

      used.add(k);
      const fare = clamp(Math.round(d/1200)*4 + 6, 6, 34);
      edges.push({a:p.id,b:q.id, kind:"sea", fare, cost: fare});
    }
  }

  // --- Connectivity enforcement ---
  function adjacency(){
    const adj = new Map(nodes.map(n=>[n.id,[]]));
    for(const e of edges){
      if(!adj.has(e.a) || !adj.has(e.b)) continue;
      adj.get(e.a).push(e.b);
      adj.get(e.b).push(e.a);
    }
    return adj;
  }
  function components(){
    const adj = adjacency();
    const seen = new Set();
    const comps = [];
    for(const n of nodes){
      if(seen.has(n.id) || n.type==="landmark" || n.impassable) continue;
      const stack=[n.id];
      const comp=[];
      seen.add(n.id);
      while(stack.length){
        const cur=stack.pop();
        comp.push(cur);
        for(const nb of (adj.get(cur)||[])){
          if(!seen.has(nb)){
            seen.add(nb);
            stack.push(nb);
          }
        }
      }
      comps.push(comp);
    }
    return comps;
  }
  function connectPair(aId, bId){
    const a=nodeById[aId], b=nodeById[bId];
    if(!a||!b) return false;
    if(!isLand(a.x,a.y) || !isLand(b.x,b.y)) return false;
    if(!segmentMostlyLand(a,b)) return false;
    const k = key(a.id,b.id);
    if(used.has(k)) return false;
    used.add(k);
    const warEdge = (WAR_PAIR.includes(a.kingdom) && WAR_PAIR.includes(b.kingdom) && a.kingdom!==b.kingdom);
    edges.push({a:a.id,b:b.id, kind:"road", war: warEdge});
    return true;
  }

  // Ensure every non-impassable node has at least 1 edge
  const deg = new Map(nodes.map(n=>[n.id,0]));
  for(const e of edges){
    deg.set(e.a, (deg.get(e.a)||0)+1);
    deg.set(e.b, (deg.get(e.b)||0)+1);
  }
  for(const n of nodes){
    if(n.type==="landmark" || n.impassable) continue;
    if((deg.get(n.id)||0) > 0) continue;

    // connect to nearest viable land node
    const candidates = nodes
      .filter(m=>m.id!==n.id && m.type!=="landmark" && !m.impassable && isLand(m.x,m.y) && isLand(n.x,n.y))
      .map(m=>({id:m.id, d:dist(n,m)}))
      .sort((a,b)=>a.d-b.d)
      .slice(0, 12);

    for(const c of candidates){
      if(connectPair(n.id, c.id)){
        deg.set(n.id, 1);
        deg.set(c.id, (deg.get(c.id)||0)+1);
        break;
      }
    }
  }

  // Ensure single connected graph (best-effort)
  let comps = components();
  let safety=0;
  while(comps.length > 1 && safety++ < 20){
    const A = comps[0];
    let best = null;

    for(let ci=1; ci<comps.length; ci++){
      const B = comps[ci];
      // find closest pair between A and B
      for(const aId of A){
        const a = nodeById[aId];
        if(!a || a.type==="landmark" || a.impassable) continue;
        for(const bId of B){
          const b = nodeById[bId];
          if(!b || b.type==="landmark" || b.impassable) continue;
          const d = dist(a,b);
          if(d > 9000) continue;
          if(!best || d < best.d) best = {aId,bId,d};
        }
      }
      if(best && best.d < 4200) break;
    }

    if(best && connectPair(best.aId, best.bId)){
      comps = components();
    } else {
      // can't connect further with strict land checks
      break;
    }
  }

  // --- Compute travel cost for roads ---
  function biomeMult(b){
    if(b==="desert") return 1.25;
    if(b==="arctic") return 1.35;
    if(b==="snow") return 1.22;
    if(b==="tundra") return 1.15;
    if(b==="woodland") return 1.10;
    return 1.00;
  }
  function roadCost(a,b, war){
    const d = dist(a,b);
    const pts = [0.25,0.5,0.75].map(t=>{
      const x=a.x+(b.x-a.x)*t;
      const y=a.y+(b.y-a.y)*t;
      return biomeAt(x,y);
    });
    const mult = (biomeMult(pts[0]) + biomeMult(pts[1]) + biomeMult(pts[2]))/3;
    let cost = Math.round((d/950) * mult) + 2;
    if(a.kingdom!==b.kingdom) cost += 2; // toll / border fees
    if(war) cost += 4; // danger premium
    return clamp(cost, 1, 55);
  }

  for(const e of edges){
    if(e.kind==="road"){
      const a=nodeById[e.a], b=nodeById[e.b];
      e.cost = roadCost(a,b, !!e.war);
    } else if(e.kind==="sea"){
      e.cost = e.fare||e.cost||0;
    }
  }

  world.edges = edges;
  mapTexDirty = true;
}
buildEdges();

function edgeBetween(a,b){
  return world.edges.find(e => (e.a===a && e.b===b) || (e.a===b && e.b===a));
}
function neighbors(id){
  return world.edges.filter(e=>e.a===id||e.b===id).map(e=>e.a===id?e.b:e.a);
}

/* =========================
   Quests (unchanged concept, scaled to cities)
========================= */
const QUESTS = [
  { id:"q_crate_1", title:"Deliver Sealed Crate", from:"aurelia_capital", to:"grandport", item:{type:"quest", name:"Sealed Crate", weight:2}, reward:{gold:35, xp:40, key:1}, text:"Deliver a sealed crate to Grandport. No questions asked." },
  { id:"q_letter_1", title:"Captain‚Äôs Letter", from:"grandport", to:"aurelia_capital", item:{type:"quest", name:"Captain‚Äôs Letter", weight:0.2}, reward:{gold:30, xp:35, key:0}, text:"Carry a sealed letter back to Aurelia‚Äôs steward." },
  { id:"q_tools_1", title:"Tools for Border Camp", from:"kragholm_capital", to:"mistcoil_docks", item:{type:"quest", name:"Tool Bundle", weight:6}, reward:{gold:28, xp:50, key:1}, text:"Deliver tools to Mistcoil Docks." }
];
function questBoardForNode(nodeId){
  return QUESTS.filter(q=>q.from===nodeId);
}
function questStatus(qid){ return state.quests[qid] || {accepted:false, completed:false}; }
function setQuestStatus(qid, patch){
  const cur = questStatus(qid);
  state.quests[qid] = {...cur, ...patch};
}
function activeQuest(){
  if(!state.activeQuestId) return null;
  return QUESTS.find(q=>q.id===state.activeQuestId) || null;
}
function hasQuestItem(name){
  return state.bag.some(x=>x.type==="quest" && x.name===name);
}
function removeQuestItem(name){
  const idx = state.bag.findIndex(x=>x.type==="quest" && x.name===name);
  if(idx>=0) state.bag.splice(idx,1);
}
function addQuestItem(item){
  if(!hasQuestItem(item.name)) state.bag.push({...item});
}
function awardXP(amount){
  if(amount<=0) return;
  state.char.xp += amount;
  pushLog(`<span style="color:var(--good)">‚ú® +${amount} XP</span>`);
  // level up loop
  while(state.char.xp >= xpToNext(state.char.level)){
    state.char.xp -= xpToNext(state.char.level);
    state.char.level += 1;
    // level benefits
    state.hpMax += 2 + Math.max(0, abilityMod(state.char.con));
    state.hp = clamp(state.hp + 6, 1, state.hpMax);
    // update spell slots & maybe add a spell
    refreshSpellSlotsToMax();
    autoLearnSpellOnLevel();
    pushLog(`<span style="color:var(--good)">üåü Level up! You are now level <b>${state.char.level}</b>.</span>`);
  }
}
function tryDeliverQuest(){
  const q = activeQuest();
  if(!q) return false;
  const st = questStatus(q.id);
  if(!st.accepted || st.completed) return false;
  if(state.currentNode===q.to && hasQuestItem(q.item.name)){
    removeQuestItem(q.item.name);
    state.gold += q.reward.gold||0;
    state.keys += q.reward.key||0;
    awardXP(q.reward.xp||0);
    setQuestStatus(q.id, {completed:true});
    pushLog(`<span style="color:var(--good)">üì¶ Quest complete: ${q.title}! +${q.reward.gold||0}g${q.reward.key?` +${q.reward.key} key`:""}.</span>`);
    state.activeQuestId = null;
    return true;
  }
  return false;
}

/* =========================
   Inventory utilities (carry weight enforced)
========================= */
function fmtItem(item){
  if(!item) return "None";
  const parts=[];
  if(item.atk) parts.push(`+${item.atk} ATK`);
  if(item.def) parts.push(`+${item.def} DEF`);
  return parts.length ? `${item.name} (${parts.join(", ")})` : item.name;
}
function addToBag(item){
  // carry limit
  const projected = carryNow() + (item.type==="consumable" ? (item.weight||0)*(item.qty||1) : (item.weight||0));
  if(projected > carryMax()){
    pushLog(`<span style="color:var(--warn)">üéí Too heavy to carry ${item.name}. (Carry ${projected}/${carryMax()})</span>`);
    return false;
  }
  if(item.type==="consumable"){
    const found = state.bag.find(x=>x.type==="consumable" && x.kind===item.kind && x.name===item.name);
    if(found){ found.qty += item.qty||1; return true; }
  }
  state.bag.push(item);
  return true;
}
function countItem(kind){
  return state.bag.filter(x=>x.type==="consumable" && x.kind===kind).reduce((s,x)=>s+(x.qty||1),0);
}
function consumeItem(kind, qty=1){
  for(const item of state.bag){
    if(item.type==="consumable" && item.kind===kind){
      const take = Math.min(qty, item.qty||1);
      item.qty = (item.qty||1) - take;
      qty -= take;
      if(item.qty<=0) item._remove = true;
      if(qty<=0) break;
    }
  }
  state.bag = state.bag.filter(x=>!x._remove);
  return qty===0;
}
function equipFromBag(index){
  const item = state.bag[index];
  if(!item || item.type==="consumable" || item.type==="quest") return;

  if(!canEquip(item)){
    pushLog(`<span style="color:var(--warn)">‚õî ${state.char.class} cannot equip ${item.name}.</span>`);
    render(); return;
  }

  state.bag.splice(index,1);

  if(item.type==="weapon"){ if(state.weapon) state.bag.push(state.weapon); state.weapon=item; pushLog(`üß© Equipped Weapon: <b>${fmtItem(item)}</b>`); }
  if(item.type==="armor"){ if(state.armor) state.bag.push(state.armor); state.armor=item; pushLog(`üß© Equipped Armor: <b>${fmtItem(item)}</b>`); }
  if(item.type==="accessory"){ if(state.accessory) state.bag.push(state.accessory); state.accessory=item; pushLog(`üß© Equipped Accessory: <b>${fmtItem(item)}</b>`); }

  render();
}
function unequip(slot){
  if(slot==="weapon" && state.weapon){ state.bag.push(state.weapon); pushLog(`üì¶ Unequipped Weapon: <b>${fmtItem(state.weapon)}</b>`); state.weapon=null; }
  if(slot==="armor" && state.armor){ state.bag.push(state.armor); pushLog(`üì¶ Unequipped Armor: <b>${fmtItem(state.armor)}</b>`); state.armor=null; }
  if(slot==="accessory" && state.accessory){ state.bag.push(state.accessory); pushLog(`üì¶ Unequipped Accessory: <b>${fmtItem(state.accessory)}</b>`); state.accessory=null; }
  render();
}

/* =========================
   TIME + CALENDAR + DAILY ECONOMY
========================= */
const SEASONS = ["Spring","Summer","Autumn","Winter"];

function advanceSeasonDay(){
  state.dayOfSeason += 1;
  if(state.dayOfSeason > 30){
    state.dayOfSeason = 1;
    state.seasonIndex = (state.seasonIndex + 1) % 4;
    if(state.seasonIndex === 0){
      state.year += 1;
      state.char.age += 1; // aging yearly
      pushLog(`<span style="color:var(--warn)">üìÖ A new year begins. You are now <b>${state.char.age}</b>.</span>`);
    }
  }
}

function startNewDay(){
  // daily energy drain
  const drain = (state.energyDrainPerDayMin + Math.floor(Math.random()*(state.energyDrainPerDayMax - state.energyDrainPerDayMin + 1)));
  state.energyDrainToday = drain;
  state.energy = clamp(state.energy - drain, 0, state.energyMax);

  // hunger drain
  state.hunger = clamp(state.hunger - 2, 0, state.hungerMax);
  if(state.hunger===0){
    state.hp = clamp(state.hp - 2, 0, state.hpMax);
    pushLog(`<span style="color:var(--warn)">üçó You wake starving and lose 2 HP.</span>`);
  }

  // bank interest + fee policy
  // 0.35% daily interest (simple), only if bank > 0
  if(state.bank > 0){
    const interest = Math.max(1, Math.floor(state.bank * 0.0035));
    state.bank += interest;
    pushLog(`<span style="color:var(--good)">üè¶ Bank interest: +${interest}g</span>`);
  }

  // passive income from businesses/properties
  let income = 0;
  for(const p of state.properties){
    if(p.incomePerDay) income += p.incomePerDay;
  }
  if(income>0){
    state.gold += income;
    pushLog(`<span style="color:var(--good)">üè† Income collected: +${income}g</span>`);
  }

  // restore pact slots for warlock on day start, and standard slots partially
  refreshSpellSlotsToMax();

  pushLog(`üåÖ Day ${state.day} begins. Energy drains today: -${drain}.`);
}

function passTime(minutes, reason){
  if(minutes<=0) return;

  const startDay = state.day;
  state.minutes += minutes;

  while(state.minutes >= 1440){
    state.minutes -= 1440;
    state.day += 1;
    advanceSeasonDay();
    startNewDay();
  }

  // hunger effect per 4 hours
  const hungerLoss = Math.floor(minutes / 240);
  if(hungerLoss>0){
    state.hunger = clamp(state.hunger - hungerLoss, 0, state.hungerMax);
    if(state.hunger===0){
      const hpLoss = Math.max(1, hungerLoss);
      state.hp = clamp(state.hp - hpLoss, 0, state.hpMax);
      pushLog(`<span style="color:var(--warn)">üçó Starving while time passes: -${hpLoss} HP.</span>`);
    }
  }

  if(reason) pushLog(`‚è≥ Time passes (${Math.round(minutes)} min): ${reason}.`);
}

/* =========================
   TRAVEL
   - no energy cost
   - time based on distance, modified by mount
   - road encounters: traders/bandits, war skirmishes
========================= */
function distance(a,b){
  const A=nodeById[a], B=nodeById[b];
  const dx=A.x-B.x, dy=A.y-B.y;
  return Math.sqrt(dx*dx+dy*dy);
}
function travelTimeMinutes(from,to, kind){
  const d = distance(from,to);
  // base scaling
  let minutes = clamp(Math.round(d * 0.14), 25, 320); // big map
  if(kind==="sea") minutes = clamp(Math.round(d * 0.11), 30, 380);

  // mount speeds
  const mult = state.mount?.speedMult || 1.0;
  minutes = Math.round(minutes / mult);
  return minutes;
}
function canTravelTo(toId){
  return state.mode==="world" && !!edgeBetween(state.currentNode,toId);
}
function isBigCity(node){
  return !!node.bigCity || node.type==="capital";
}


function travelTo(toId){
  if(state.mode!=="world") return;
  const e=edgeBetween(state.currentNode,toId);
  if(!e){ pushLog("üö´ No route."); render(); return; }

  const cost = (e.kind==="sea") ? (e.fare||e.cost||0) : (e.cost||0);
  if(cost>0){
    if(state.gold < cost){
      pushLog(`üö´ Travel cost: <b>${cost}g</b>. You only have <b>${state.gold}g</b>.`);
      render(); return;
    }
    state.gold -= cost;
    pushLog(`${e.kind==="sea"?"‚õ¥Ô∏è":"üõ£Ô∏è"} Paid <b>${cost}g</b> to travel (${e.kind}).`);
  }

  const minutes = travelTimeMinutes(state.currentNode,toId, e.kind);
  passTime(minutes, "Travel");

  // encounter system
  if(e.kind==="sea"){
    // sea mishaps
    if(roll(100)<=10){
      pushLog(`<span style="color:var(--warn)">üåä Rough waters! You slip into the sea.</span>`);
      state.hp = clamp(state.hp - (roll(4)+1), 0, state.hpMax);
      if(state.hp<=0){
        state.hp=1;
        pushLog(`<b style="color:var(--bad)">‚ò†Ô∏è You nearly drown and wash ashore at your last safe city.</b>`);
        enterNode(state.lastSafeNode);
        render(); return;
      }
    }
    if(roll(100)<=22){
      startCombat(makeEnemy("sea"), {origin:"sea", edge:e});
      state.pendingArrival = toId;
      pushLog(`‚öì Combat triggered during sea travel to <b>${nodeById[toId].name}</b>.`);
      render(); return;
    }
  } else {
    // war skirmish increases encounter chance
    const war = e.war || (WAR_PAIR.includes(nodeById[state.currentNode].kingdom) && WAR_PAIR.includes(nodeById[toId].kingdom) && nodeById[state.currentNode].kingdom!==nodeById[toId].kingdom);
    const baseChance = war ? 38 : 18;

    // trader/bandit/battle
    const r = roll(100);
    if(r <= baseChance){
      if(war && r <= 18){
        startCombat(makeEnemy("battle"), {origin:"war", edge:e});
        state.pendingArrival = toId;
        pushLog(`‚öîÔ∏è Skirmish erupts on the border road!`);
        render(); return;
      }
      if(r <= (war?28:10)){
        // trader event
        openTraderModal(e, toId);
        return;
      }
      // bandits
      startCombat(makeEnemy("bandits"), {origin:"road", edge:e});
      state.pendingArrival = toId;
      pushLog(`‚ö†Ô∏è Bandits ambush you on the road!`);
      render(); return;
    }
  }

  pushLog(`üß≠ Arrived at <b>${nodeById[toId].name}</b>.`);
  enterNode(toId);
  render();
}

 /* =========================
   Node entry, loot per visit
========================= */
function enterNode(nodeId){
  state.currentNode = nodeId;
  state.visitCounter += 1;
  state.nodeVisitStamp[nodeId] = state.visitCounter;

  const n = nodeById[nodeId];
  if(n.type==="city" || n.type==="town" || n.type==="castle" || n.type==="port" || n.type==="capital"){
    state.lastSafeNode=nodeId;
  }

  tryDeliverQuest();
  render();
}
function areaLootAvailable(){
  const stamp = state.nodeVisitStamp[state.currentNode] || 0;
  const used  = state.nodeLootStamp[state.currentNode] || 0;
  return used !== stamp;
}
function randomLootByBiome(biome){
  // slightly different by biome
  const r = roll(100);
  if(biome==="desert"){
    if(r<=40) return {kind:"gold", amount: roll(14)+6};
    if(r<=70) return pickShopItem(["weapon","misc"]);
    return {kind:"consumable", item:{type:"consumable", name:"Ration", kind:"food", qty:1, weight:0.5}};
  }
  if(biome==="arctic"||biome==="snow"){
    if(r<=45) return {kind:"gold", amount: roll(10)+4};
    if(r<=65) return pickShopItem(["armor","misc"]);
    return {kind:"key", amount:1};
  }
  if(biome==="woodland"){
    if(r<=40) return pickShopItem(["weapon","armor"]);
    if(r<=75) return {kind:"consumable", item:{type:"consumable", name:"Ration", kind:"food", qty:1, weight:0.5}};
    return {kind:"gold", amount: roll(12)+3};
  }
  // default
  if(r<=45) return {kind:"gold", amount: roll(12)+4};
  if(r<=70) return pickShopItem(["weapon","armor","misc"]);
  return {kind:"consumable", item:{type:"consumable", name:"Ration", kind:"food", qty:1, weight:0.5}};
}
function pickShopItem(shops){
  const list = ITEMS.filter(it=>shops.includes(it.shop) && it.type!=="consumable");
  const it = list[Math.floor(rngWorld()*list.length)];
  return {kind:"gear", item: {...it}};
}
function useAreaLoot(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't loot during combat."); render(); return; }
  if(!areaLootAvailable()){
    pushLog("üß∫ Area loot already used for this visit.");
    render(); return;
  }
  passTime(25, "Area loot");
  state.nodeLootStamp[state.currentNode] = state.nodeVisitStamp[state.currentNode];

  const n=nodeById[state.currentNode];
  const loot = randomLootByBiome(n.biome);

  if(loot.kind==="gold"){
    state.gold+=loot.amount;
    pushLog(`üß∫ You find <b>${loot.amount}</b> gold.`);
  } else if(loot.kind==="key"){
    state.keys += loot.amount;
    pushLog(`üß∫ You find <b>${loot.amount}</b> key.`);
  } else if(loot.kind==="consumable"){
    if(addToBag(loot.item)) pushLog(`üß∫ Found <b>${loot.item.name}</b>.`);
  } else if(loot.kind==="gear"){
    if(addToBag(loot.item)) pushLog(`üß∫ Found gear: <b>${fmtItem(loot.item)}</b>.`);
  }

  // small encounter chance
  const risk = (WAR_PAIR.includes(n.kingdom) ? 12 : 8);
  if(roll(100)<=risk){
    startCombat(makeEnemy("ambush"), {origin:"world"});
  }

  render();
}

/* =========================
   Dungeons (kept from earlier, scaled)
========================= */
function generateDungeon(kind, id){
  const rng = makeRNG(kind+"::"+id);
  const w = 28, h = 17;

  let grid = Array.from({length:h}, ()=>Array.from({length:w}, ()=> (rng()< (kind==="forest"?0.47:0.50) ? "wall" : "floor")));
  for(let y=0;y<h;y++){ grid[y][0]="wall"; grid[y][w-1]="wall"; }
  for(let x=0;x<w;x++){ grid[0][x]="wall"; grid[h-1][x]="wall"; }

  function countWalls(x,y){
    let c=0;
    for(let yy=y-1; yy<=y+1; yy++){
      for(let xx=x-1; xx<=x+1; xx++){
        if(xx===x && yy===y) continue;
        if(yy<0||xx<0||yy>=h||xx>=w){ c++; continue; }
        if(grid[yy][xx]==="wall") c++;
      }
    }
    return c;
  }

  const iters = kind==="forest"?5:6;
  for(let i=0;i<iters;i++){
    const next = grid.map(row=>row.slice());
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const walls = countWalls(x,y);
        next[y][x] = (walls>=5) ? "wall" : "floor";
      }
    }
    grid=next;
  }

  function randomFloor(){
    for(let t=0;t<5000;t++){
      const x = 1 + Math.floor(rng()*(w-2));
      const y = 1 + Math.floor(rng()*(h-2));
      if(grid[y][x]==="floor") return {x,y};
    }
    return {x:2,y:2};
  }

  const entrance = randomFloor();
  const exit = randomFloor();
  grid[entrance.y][entrance.x]="entrance";
  grid[exit.y][exit.x]="exit";

  const seen = Array.from({length:h}, ()=>Array.from({length:w}, ()=>false));
  const chests = {};
  const keysOnGround = {};
  const doors = {};
  const enemies = [];

  function makeDungeonEnemy(type,x,y){
    const base = {
      "Goblin": {hp:12, ac:10, atk:3, icon:"üë∫"},
      "Bandit": {hp:16, ac:11, atk:3, icon:"üó°Ô∏è"},
      "Cultist":{hp:14, ac:12, atk:3, icon:"üïØÔ∏è"},
      "Slime":  {hp:15, ac:10, atk:2, icon:"ü´ß"},
      "Wolf":   {hp:10, ac:10, atk:2, icon:"üê∫"},
      "Boar":   {hp:14, ac:11, atk:3, icon:"üêó"},
      "Warg":   {hp:18, ac:12, atk:4, icon:"üê∫"}
    }[type] || {hp:12, ac:10, atk:2, icon:"‚öîÔ∏è"};
    return {x,y,type, hp:base.hp, ac:base.ac, atk:base.atk, icon:base.icon};
  }

  function dungeonChestContents(rng){
    const contents = [];
    contents.push({type:"gold", amount: 10 + Math.floor(rng()*24)});
    if(rng()<0.70) contents.push({type:"gear", item: pickShopItem(["weapon","armor","misc"]).item});
    if(rng()<0.55) contents.push({type:"consumable", item:{type:"consumable", name:"Ration", kind:"food", qty:1, weight:0.5}});
    if(rng()<0.30) contents.push({type:"key", amount:1});
    return contents;
  }

  // door
  let doorPos=null;
  for(let tries=0;tries<2400;tries++){
    const p=randomFloor();
    if(Math.abs(p.x-entrance.x)+Math.abs(p.y-entrance.y)<6) continue;
    if(Math.abs(p.x-exit.x)+Math.abs(p.y-exit.y)<6) continue;
    doorPos=p; break;
  }
  if(doorPos){
    grid[doorPos.y][doorPos.x]="doorLocked";
    doors[`${doorPos.x},${doorPos.y}`]={locked:true, opened:false};
  }

  // key
  let keyPos=null;
  for(let tries=0;tries<2400;tries++){
    const p=randomFloor();
    if(doorPos && p.x===doorPos.x && p.y===doorPos.y) continue;
    if(Math.abs(p.x-entrance.x)+Math.abs(p.y-entrance.y)<4) continue;
    keyPos=p; break;
  }
  if(keyPos){
    grid[keyPos.y][keyPos.x]="key";
    keysOnGround[`${keyPos.x},${keyPos.y}`]={taken:false};
  }

  // chests
  const chestCount = kind==="forest"?4:5;
  for(let i=0;i<chestCount;i++){
    let p=null;
    for(let tries=0;tries<2800;tries++){
      const c=randomFloor();
      if(grid[c.y][c.x]!=="floor") continue;
      if(Math.abs(c.x-entrance.x)+Math.abs(c.y-entrance.y)<5) continue;
      const k=`${c.x},${c.y}`;
      if(chests[k]) continue;
      p=c; break;
    }
    if(!p) continue;
    const locked = rng()<0.45;
    grid[p.y][p.x]= locked ? "chestLocked" : "chest";
    chests[`${p.x},${p.y}`]={locked, opened:false, contents:dungeonChestContents(rng)};
  }

  // enemies placed
  const enemyCount = kind==="forest"?7:6;
  const enemyTypes = kind==="forest" ? ["Wolf","Bandit","Boar","Warg"] : ["Goblin","Bandit","Cultist","Slime"];
  for(let i=0;i<enemyCount;i++){
    let p=null;
    for(let tries=0;tries<3200;tries++){
      const c=randomFloor();
      if(grid[c.y][c.x]!=="floor") continue;
      if(Math.abs(c.x-entrance.x)+Math.abs(c.y-entrance.y)<4) continue;
      const k=`${c.x},${c.y}`;
      if(chests[k]) continue;
      if(keysOnGround[k]) continue;
      if(doors[k]) continue;
      if(enemies.some(e=>e.x===c.x && e.y===c.y)) continue;
      p=c; break;
    }
    if(!p) continue;
    const t = enemyTypes[Math.floor(rng()*enemyTypes.length)];
    enemies.push(makeDungeonEnemy(t,p.x,p.y));
  }

  return {kind,id,w,h,tiles:grid,seen,px:entrance.x,py:entrance.y,enemies,chests,keysOnGround,doors};
}
function revealAround(d, px,py,r){
  for(let y=py-r;y<=py+r;y++){
    for(let x=px-r;x<=px+r;x++){
      if(x>=0&&y>=0&&x<d.w&&y<d.h) d.seen[y][x]=true;
    }
  }
}
function currentDungeon(){
  if(!state.dungeonId) return null;
  return state.dungeons[state.dungeonId] || null;
}
function tileAt(d,x,y){ return d.tiles?.[y]?.[x] || "wall"; }
function enterDungeon(nodeId){
  const n=nodeById[nodeId];
  if(!n || !(n.type==="cave"||n.type==="forest")) return;

  state.mode="dungeon";
  state.dungeonId = nodeId;

  if(!state.dungeons[nodeId]){
    state.dungeons[nodeId] = generateDungeon(n.dungeonKind || (n.type==="forest"?"forest":"cave"), nodeId);
  }
  const d=currentDungeon();
  revealAround(d,d.px,d.py,2);
  pushLog(`üïØÔ∏è Entered ${n.name}. Fog-of-war active.`);
  render();
}
function leaveDungeon(){
  const n=nodeById[state.currentNode];
  pushLog(`üå§Ô∏è You return to the surface near <b>${n.name}</b>.`);
  state.mode="world";
  state.dungeonId=null;
  render();
}
function isWalkable(d,x,y){
  const t=tileAt(d,x,y);
  if(t==="wall") return false;
  if(t==="doorLocked"){
    const door=d.doors[`${x},${y}`];
    return door && door.opened;
  }
  return true;
}
function dungeonMove(dx,dy){
  if(state.mode!=="dungeon" || state.mode==="combat") return;
  const d=currentDungeon(); if(!d) return;

  const nx=d.px+dx, ny=d.py+dy;
  if(nx<0||ny<0||nx>=d.w||ny>=d.h) return;

  const t=tileAt(d,nx,ny);

  if(t==="wall"){
    pushLog("ü™® Blocked.");
    render(); return;
  }
  if(t==="doorLocked"){
    const door=d.doors[`${nx},${ny}`];
    if(door && !door.opened){
      pushLog("üö™ Locked door. Use Interact to unlock (requires key).");
      render(); return;
    }
  }

  passTime(8, "Dungeon movement");
  d.px=nx; d.py=ny;
  revealAround(d,nx,ny,2);

  const ei = d.enemies.findIndex(e=>e.x===nx && e.y===ny);
  if(ei>=0){
    const e=d.enemies[ei];
    startCombat(makeEnemyFromDungeon(e), {origin:"dungeon", dungeonId: state.dungeonId, enemyPos:{x:nx,y:ny}, icon:e.icon});
  }
  render();
}
function pickupKeyAt(x,y){
  const d=currentDungeon(); if(!d) return;
  const k=d.keysOnGround[`${x},${y}`];
  if(!k || k.taken) return;
  k.taken=true;
  state.keys += 1;
  d.tiles[y][x]="floor";
  passTime(3, "Pick up key");
  pushLog(`üîë You pick up a key. Keys: <b>${state.keys}</b>`);
  render();
}
function unlockDoorAt(x,y){
  const d=currentDungeon(); if(!d) return;
  const door=d.doors[`${x},${y}`];
  if(!door || door.opened) return;
  if(state.keys<=0){
    pushLog("üîë You need a key to unlock this door.");
    render(); return;
  }
  state.keys -= 1;
  door.opened=true;
  door.locked=false;
  passTime(5, "Unlock door");
  pushLog(`üö™ Unlocked the door. Keys left: <b>${state.keys}</b>`);
  render();
}
function openChestAt(x,y){
  const d=currentDungeon(); if(!d) return;
  const c=d.chests[`${x},${y}`];
  const t=tileAt(d,x,y);
  if(!c || c.opened) return;

  const locked = (t==="chestLocked") || c.locked;
  if(locked){
    if(state.keys<=0){
      pushLog("üîí Chest is locked. Need a key.");
      render(); return;
    }
    state.keys -= 1;
    pushLog("üîì You unlock the chest using a key.");
  }

  c.opened=true;
  d.tiles[y][x]="floor";
  passTime(6, "Open chest");

  let gained=[];
  for(const item of c.contents){
    if(item.type==="gold"){ state.gold += item.amount; gained.push(`${item.amount}g`); }
    if(item.type==="gear"){ if(addToBag(item.item)) gained.push(fmtItem(item.item)); }
    if(item.type==="consumable"){ if(addToBag(item.item)) gained.push(item.item.name); }
    if(item.type==="key"){ state.keys += item.amount; gained.push(`${item.amount} key`); }
  }
  pushLog(`üì¶ Chest opened! Gained: <b>${gained.join(", ")}</b>`);
  awardXP(12);
  render();
}
function dungeonSearch(){
  const d=currentDungeon(); if(!d) return;
  passTime(12, "Search dungeon area");
  revealAround(d,d.px,d.py,3);
  pushLog("üïØÔ∏è You search carefully and reveal more of the area.");
  if(roll(100)<=18){
    const g=roll(12)+3; state.gold+=g;
    pushLog(`‚ú® Hidden find: <b>${g}g</b>`);
  }
  render();
}

/* =========================
   Tile-based Interactions
========================= */
function addInteractButton(label, fn){
  const b=document.createElement("button");
  b.className="secondary";
  b.textContent=label;
  b.onclick=fn;
  $("interactButtons").appendChild(b);
}
function buildInteractOptions(){
  const btns = $("interactButtons");
  btns.innerHTML = "";

  if(state.mode==="combat"){
    $("interactHint").textContent = "Combat: on Combat Screen.";
    return;
  }

  const n=nodeById[state.currentNode];

  if(state.mode==="world"){
    let msg = `You are in ${n.name} ‚Ä¢ ${n.kingdom} ‚Ä¢ ${n.biome}. `;
    if(n.population) msg += `Population: ${n.population.toLocaleString()}. `;
    if(n.type==="cave"||n.type==="forest") msg += "You can enter this area.";
    else msg += "Visit establishments, take quests, or rest.";
    $("interactHint").textContent = msg;

    if(n.type==="cave"||n.type==="forest"){
      addInteractButton(`Enter ${n.type==="cave"?"Cave":"Forest"}`, ()=>enterDungeon(n.id));
    }
    if(n.type==="landmark"){
      addInteractButton("Search for an entrance", ()=>frostspireTimeSink());
    }
    return;
  }

  // dungeon
  const d=currentDungeon(); if(!d) return;
  const x=d.px, y=d.py;
  const t=tileAt(d,x,y);

  const lines = [];
  lines.push(`Dungeon: (${x},${y}) ‚Ä¢ Tile: ${t}`);

  if(t==="chest" || t==="chestLocked"){
    const c=d.chests[`${x},${y}`];
    if(c?.opened){
      lines.push("Chest: opened.");
    } else {
      lines.push(t==="chestLocked" ? "Chest: locked." : "Chest: unlocked.");
      addInteractButton("Open Chest", ()=>openChestAt(x,y));
    }
  }
  if(t==="key"){
    const k=d.keysOnGround[`${x},${y}`];
    if(k && !k.taken){
      lines.push("Key on the ground.");
      addInteractButton("Pick up Key", ()=>pickupKeyAt(x,y));
    }
  }
  if(t==="doorLocked"){
    const door=d.doors[`${x},${y}`];
    if(door?.opened){
      lines.push("Door: unlocked.");
    } else {
      lines.push("Door: locked.");
      addInteractButton("Unlock Door (1 key)", ()=>unlockDoorAt(x,y));
    }
  }
  if(t==="exit"){
    lines.push("Exit to surface.");
    addInteractButton("Leave Dungeon", ()=>leaveDungeon());
  }

  lines.push("You can search this area to reveal more.");
  addInteractButton("Search (Reveal)", ()=>dungeonSearch());

  $("interactHint").textContent = lines.join(" ‚Ä¢ ");
}

/* =========================
   Combat (Dedicated Screen)
========================= */
function makeEnemy(tag){
  if(tag==="bandits") return {name:"Bandit Crew", hp:20, hpMax:20, ac:12, atk:4, tag:"bandits", icon:"üó°Ô∏è"};
  if(tag==="battle") return {name:"Border Skirmish", hp:22, hpMax:22, ac:12, atk:5, tag:"battle", icon:"‚öîÔ∏è"};
  if(tag==="sea"){
    const pick = (roll(2)===1) ? "Sea Serpent" : "Reef Stalker";
    return {name:pick, hp:18, hpMax:18, ac:11, atk:4, tag:"sea", icon:"üåä"};
  }
  if(tag==="ambush") return {name:"Road Ambush", hp:16, hpMax:16, ac:11, atk:3, tag:"ambush", icon:"ü™ì"};
  // default
  const pick = ["Goblin","Bandit","Wolf"][roll(3)-1];
  return makeEnemyByName(pick, tag);
}
function makeEnemyByName(name, tag){
  const base = {
    "Goblin": {hp:12, ac:10, atk:3, icon:"üë∫"},
    "Bandit": {hp:16, ac:11, atk:3, icon:"üó°Ô∏è"},
    "Wolf":   {hp:10, ac:10, atk:2, icon:"üê∫"},
    "Cultist":{hp:14, ac:12, atk:3, icon:"üïØÔ∏è"},
    "Slime":  {hp:15, ac:10, atk:2, icon:"ü´ß"},
  }[name] || {hp:12, ac:10, atk:2, icon:"‚öîÔ∏è"};
  return {name, hp:base.hp, hpMax:base.hp, ac:base.ac, atk:base.atk, tag, icon:base.icon};
}
function makeEnemyFromDungeon(e){
  return {name:e.type, hp:e.hp, hpMax:e.hp, ac:e.ac, atk:e.atk, tag:"dungeon", icon:e.icon||"‚öîÔ∏è"};
}

let tempBuffs = { atkBonus:0, defBonus:0, enemySkipChance:0, enemyHitPenalty:0, extraDmg:0, shielded:false, turnsLeft:0 };

function resetTempBuffs(){
  tempBuffs = { atkBonus:0, defBonus:0, enemySkipChance:0, enemyHitPenalty:0, extraDmg:0, shielded:false, turnsLeft:0 };
}

function startCombat(enemy, meta){
  state.mode="combat";
  state.enemy=enemy;
  state.enemyMeta=meta||{};
  state.combatLog = [];
  resetTempBuffs();

  pushLog(`‚ö†Ô∏è Encounter: <b>${enemy.name}</b>!`);
  pushCombat(`‚ö†Ô∏è <b>${enemy.name}</b> appears.`);
  openCombatScreen();
  renderCombatUI();
  render();
}
function endCombat(victory){
  const meta=state.enemyMeta||{};
  if(victory){
    const gold=roll(16)+6;
    state.gold+=gold;
    const xp = 40 + roll(20);
    awardXP(xp);
    pushLog(`‚úÖ Victory! You gain <b>${gold}g</b>.`);
    pushCombat(`‚úÖ Victory! +${gold}g, +${xp} XP.`);

    if(roll(100)<=30){
      const gear = pickShopItem(["weapon","armor","misc"]).item;
      if(addToBag(gear)) pushLog(`üì¶ Loot: <b>${fmtItem(gear)}</b>`);
    }
    if(roll(100)<=25){
      addToBag({type:"consumable", name:"Ration", kind:"food", qty:1, weight:0.5});
      pushLog(`üçó Loot: <b>Ration</b>`);
    }

    if(state.pendingArrival){
      const toId=state.pendingArrival;
      state.pendingArrival=null;
      pushLog(`üß≠ You continue and arrive at <b>${nodeById[toId].name}</b>.`);
      enterNode(toId);
    }

    if(meta.origin==="dungeon" && meta.dungeonId && meta.enemyPos){
      const d=state.dungeons[meta.dungeonId];
      if(d){
        d.enemies = d.enemies.filter(en => !(en.x===meta.enemyPos.x && en.y===meta.enemyPos.y));
        pushLog("üó∫Ô∏è That enemy is gone for good.");
      }
    }
  } else {
    pushCombat(`üèÉ You escape.`);
    pushLog(`üèÉ You escape!`);
    state.pendingArrival=null;
  }

  state.enemy=null;
  state.enemyMeta=null;

  if(state.dungeonId) state.mode="dungeon";
  else state.mode="world";

  closeCombatScreen();
  render();
}

function playerAttack(){
  if(state.mode!=="combat" || !state.enemy) return;

  const d20=roll(20);
  const atk = getAtk() + tempBuffs.atkBonus;
  pushCombat(`üé≤ You roll d20: <b>${d20}</b> vs AC ${state.enemy.ac}`);
  if(d20 >= state.enemy.ac){
    const dmg=roll(6)+atk + tempBuffs.extraDmg;
    state.enemy.hp -= dmg;
    pushCombat(`‚öîÔ∏è Hit! You deal <b>${dmg}</b>.`);
  } else pushCombat(`‚ùå Miss.`);

  if(state.enemy.hp<=0){
    pushCombat(`üíÄ ${state.enemy.name} defeated.`);
    endCombat(true);
    return;
  }

  enemyTurn();
}
function enemyTurn(){
  // control effects
  if(tempBuffs.turnsLeft>0){
    // decrement after both sides act
  }
  if(tempBuffs.enemySkipChance>0 && roll(100)<=tempBuffs.enemySkipChance){
    pushCombat(`üòµ ${state.enemy.name} hesitates and loses the turn.`);
    tickBuffs();
    renderCombatUI();
    return;
  }

  const d20=roll(20);
  const playerAC=getAC() + tempBuffs.defBonus;
  let effectiveRoll = d20;

  if(tempBuffs.enemyHitPenalty>0){
    // penalty reduces effective roll
    effectiveRoll = Math.max(1, d20 - tempBuffs.enemyHitPenalty);
  }

  pushCombat(`üé≤ ${state.enemy.name} rolls d20: <b>${d20}</b> (effective ${effectiveRoll}) vs AC ${playerAC}`);
  if(effectiveRoll >= playerAC){
    let dmg=roll(6)+state.enemy.atk;
    if(tempBuffs.shielded){
      dmg = Math.max(0, dmg - 6);
      pushCombat(`üõ°Ô∏è Shield absorbs some damage.`);
      tempBuffs.shielded=false;
    }
    state.hp -= dmg;
    pushCombat(`<span style="color:var(--bad)">ü©∏ You take ${dmg} damage.</span>`);
  } else pushCombat(`üõ°Ô∏è Enemy misses.`);

  if(state.hp<=0){
    state.hp=1;
    pushCombat(`<b style="color:var(--bad)">‚ò†Ô∏è You collapse‚Ä¶ and wake in safety.</b>`);
    pushLog(`<b style="color:var(--bad)">‚ò†Ô∏è You collapse‚Ä¶ and wake at your last safe city.</b>`);
    state.mode="world";
    state.dungeonId=null;
    state.enemy=null;
    state.enemyMeta=null;
    state.pendingArrival=null;
    closeCombatScreen();
    enterNode(state.lastSafeNode);
    render();
    return;
  }

  tickBuffs();
  renderCombatUI();
  render();
}
function flee(){
  if(state.mode!=="combat") return;
  const d20=roll(20);
  pushCombat(`üèÉ Flee attempt d20: <b>${d20}</b>`);
  if(d20>=11) endCombat(false);
  else { pushCombat("‚ùå Failed to flee."); enemyTurn(); }
}
function tickBuffs(){
  if(tempBuffs.turnsLeft>0){
    tempBuffs.turnsLeft -= 1;
    if(tempBuffs.turnsLeft<=0){
      tempBuffs = { atkBonus:0, defBonus:0, enemySkipChance:0, enemyHitPenalty:0, extraDmg:0, shielded:false, turnsLeft:0 };
      pushCombat(`‚ú® Effects fade.`);
    }
  }
}

/* =========================
   Spellcasting
========================= */
function classSpellList(){
  return SPELLS[state.char.class] || [];
}
function learnStartingSpells(){
  state.char.spellsKnown = [];
  if(!isCasterClass(state.char.class)) return;

  const list = classSpellList();
  // pick 2 spells: 1 cantrip + 1 level-1 if available
  const cantrips = list.filter(s=>s.level===0);
  const lvl1 = list.filter(s=>s.level===1);

  if(cantrips.length) state.char.spellsKnown.push(cantrips[0].name);
  if(lvl1.length) state.char.spellsKnown.push(lvl1[0].name);

  refreshSpellSlotsToMax();
}
function autoLearnSpellOnLevel(){
  if(!isCasterClass(state.char.class)) return;
  const list = classSpellList();
  // learn a new cantrip at lvl 3, otherwise new level-1-ish spell if not known
  const unknown = list.filter(s=>!state.char.spellsKnown.includes(s.name));
  if(unknown.length===0) return;

  if(state.char.level===3){
    const c = unknown.find(s=>s.level===0) || unknown[0];
    state.char.spellsKnown.push(c.name);
    pushLog(`<span style="color:var(--good)">üìò Learned spell: <b>${c.name}</b></span>`);
    return;
  }

  const pick = unknown.find(s=>s.level===1) || unknown[0];
  state.char.spellsKnown.push(pick.name);
  pushLog(`<span style="color:var(--good)">üìò Learned spell: <b>${pick.name}</b></span>`);
}
function canCastSpell(spell){
  if(!spell) return false;
  if(spell.level===0) return true;
  return (state.char.spellSlots[spell.level]||0) > 0;
}
function spendSlot(level){
  if(level===0) return true;
  if((state.char.spellSlots[level]||0)<=0) return false;
  state.char.spellSlots[level] -= 1;
  return true;
}
function castSpellByName(name){
  if(state.mode!=="combat") return;
  const list = classSpellList();
  const sp = list.find(s=>s.name===name);
  if(!sp) return;

  if(!canCastSpell(sp)){
    pushCombat(`‚õî No spell slots for ${sp.name}.`);
    renderCombatUI(); return;
  }
  spendSlot(sp.level);

  // resolve effects
  if(sp.type==="damage"){
    // if "Magic Missile" guarantee hit, otherwise roll
    if(sp.name==="Magic Missile"){
      const dmg = roll(sp.dmgDice)+sp.dmgBonus + abilityMod(state.char.int);
      state.enemy.hp -= dmg;
      pushCombat(`‚ú® <b>${sp.name}</b> hits automatically for <b>${dmg}</b> damage.`);
    } else {
      const d20 = roll(20);
      const spellStat = CLASS_RULES[state.char.class]?.spellcasting?.stat || "int";
      const mod = abilityMod(state.char[spellStat]||10);
      const hit = d20 + mod;
      pushCombat(`üé≤ Cast <b>${sp.name}</b>: d20 <b>${d20}</b> + ${mod} = <b>${hit}</b> vs AC ${state.enemy.ac}`);
      if(hit >= state.enemy.ac){
        const dmg = roll(sp.dmgDice)+sp.dmgBonus + Math.max(0, mod);
        state.enemy.hp -= dmg;
        pushCombat(`‚ú® Hit! <b>${dmg}</b> damage.`);
      } else pushCombat(`‚ú® Miss.`);
    }
  }
  if(sp.type==="heal"){
    const stat = CLASS_RULES[state.char.class]?.spellcasting?.stat || "wis";
    const mod = Math.max(0, abilityMod(state.char[stat]||10));
    const heal = roll(sp.healDice)+sp.healBonus+mod;
    state.hp = clamp(state.hp + heal, 1, state.hpMax);
    pushCombat(`üí† <b>${sp.name}</b> heals you for <b>${heal}</b>.`);
  }
  if(sp.type==="buff"){
    // apply for some turns
    tempBuffs.turnsLeft = Math.max(tempBuffs.turnsLeft, sp.turns||2);
    if(sp.acBonus){ tempBuffs.shielded=true; }
    if(sp.atkBonus){ tempBuffs.atkBonus = Math.max(tempBuffs.atkBonus, sp.atkBonus); }
    if(sp.defBonus){ tempBuffs.defBonus = Math.max(tempBuffs.defBonus, sp.defBonus); }
    pushCombat(`‚ú® <b>${sp.name}</b> empowers you.`);
  }
  if(sp.type==="control"){
    tempBuffs.turnsLeft = Math.max(tempBuffs.turnsLeft, 2);
    tempBuffs.enemySkipChance = Math.max(tempBuffs.enemySkipChance, 35);
    pushCombat(`üåÄ <b>${sp.name}</b> disrupts the enemy.`);
  }
  if(sp.type==="debuff"){
    tempBuffs.turnsLeft = Math.max(tempBuffs.turnsLeft, sp.turns||3);
    tempBuffs.extraDmg = Math.max(tempBuffs.extraDmg, sp.dmgBonus||2);
    pushCombat(`üï∑Ô∏è <b>${sp.name}</b> marks the enemy. (+damage)`);
  }
  if(sp.type==="lifesteal"){
    const stat = CLASS_RULES[state.char.class]?.spellcasting?.stat || "cha";
    const mod = Math.max(0, abilityMod(state.char[stat]||10));
    const dmg = roll(sp.dmgDice)+sp.dmgBonus+mod;
    state.enemy.hp -= dmg;
    const heal = Math.max(1, Math.floor(dmg*0.45));
    state.hp = clamp(state.hp + heal, 1, state.hpMax);
    pushCombat(`ü©∏ <b>${sp.name}</b> deals <b>${dmg}</b> and heals <b>${heal}</b>.`);
  }
  if(sp.type==="control" && sp.name==="Darkness"){
    tempBuffs.turnsLeft = Math.max(tempBuffs.turnsLeft, 2);
    tempBuffs.enemyHitPenalty = Math.max(tempBuffs.enemyHitPenalty, 4);
    pushCombat(`üåë Darkness shrouds the fight (enemy accuracy reduced).`);
  }
  if(sp.name==="Shield"){
    tempBuffs.shielded=true;
    pushCombat(`üõ°Ô∏è Shield is ready for the next hit.`);
  }
  if(sp.name==="Sleep" || sp.name==="Charm" || sp.name==="Entangle"){
    tempBuffs.turnsLeft = Math.max(tempBuffs.turnsLeft, 2);
    tempBuffs.enemySkipChance = Math.max(tempBuffs.enemySkipChance, 40);
    pushCombat(`üò¥ Control takes hold (chance enemy loses turn).`);
  }
  if(sp.name==="Mage Armor" || sp.name==="Barkskin"){
    tempBuffs.defBonus = Math.max(tempBuffs.defBonus, 2);
    tempBuffs.turnsLeft = 999;
    pushCombat(`üõ°Ô∏è Protective magic lingers until you sleep.`);
  }

  if(state.enemy.hp<=0){
    pushCombat(`üíÄ ${state.enemy.name} defeated by magic.`);
    endCombat(true);
    return;
  }

  enemyTurn();
}
function useCombatItem(kind){
  if(kind==="food"){
    if(countItem("food")<=0){
      pushCombat("üçó No rations.");
      renderCombatUI(); return;
    }
    consumeItem("food",1);
    const heal = 3 + roll(4);
    state.hp = clamp(state.hp + heal, 1, state.hpMax);
    pushCombat(`üçó You eat a ration and recover <b>${heal}</b> HP.`);
    enemyTurn();
  }
}

/* =========================
   Combat screen UI handlers
========================= */
function openCombatScreen(){
  $("combatOverlay").style.display="block";
  // default tab
  setCombatTab("clog");
}
function closeCombatScreen(){
  $("combatOverlay").style.display="none";
}
function setCombatTab(key){
  document.querySelectorAll(".tabBtn").forEach(b=>{
    b.classList.toggle("active", b.getAttribute("data-tab")===key);
  });
  $("tab-clog").classList.toggle("hidden", key!=="clog");
  $("tab-spells").classList.toggle("hidden", key!=="spells");
  $("tab-items").classList.toggle("hidden", key!=="items");
}
document.querySelectorAll(".tabBtn").forEach(b=>{
  b.addEventListener("click", ()=>setCombatTab(b.getAttribute("data-tab")));
});
$("combatAttackBtn").addEventListener("click", playerAttack);
$("combatFleeBtn").addEventListener("click", flee);
$("combatSpellBtn").addEventListener("click", ()=>setCombatTab("spells"));
$("combatItemBtn").addEventListener("click", ()=>setCombatTab("items"));

function renderCombatUI(){
  if(state.mode!=="combat" || !state.enemy) return;

  $("enemyName").textContent = state.enemy.name;
  $("enemyPortrait").textContent = state.enemy.icon || "‚öîÔ∏è";
  $("enemyMeta").textContent = `${state.enemy.tag.toUpperCase()} ‚Ä¢ AC ${state.enemy.ac} ‚Ä¢ ATK ${state.enemy.atk}`;
  $("enemyHpText").textContent = `${Math.max(0,state.enemy.hp)} / ${state.enemy.hpMax}`;
  $("enemyHpBar").style.width = `${clamp((state.enemy.hp/state.enemy.hpMax)*100, 0, 100)}%`;

  $("playerNameLine").textContent = `${state.char.name || "You"} ‚Ä¢ ${state.char.race} ${state.char.class} (Lv ${state.char.level})`;
  $("playerACLine").textContent = `AC ${getAC()} ‚Ä¢ ATK ${getAtk()} ‚Ä¢ DEF ${getDef()}`;
  $("playerHpText").textContent = `${state.hp} / ${state.hpMax}`;
  $("playerHpBar").style.width = `${clamp((state.hp/state.hpMax)*100, 0, 100)}%`;

  $("combatLog").innerHTML = state.combatLog.map(x=>`<div>${x}</div>`).join("");
  $("combatLog").scrollTop = $("combatLog").scrollHeight;

  // spells list
  const spellList = $("combatSpellList");
  spellList.innerHTML = "";
  const known = state.char.spellsKnown || [];
  const all = classSpellList().filter(s=>known.includes(s.name));
  if(all.length===0){
    const span = document.createElement("div");
    span.className="smallMuted";
    span.textContent="No spells known.";
    spellList.appendChild(span);
  } else {
    for(const sp of all){
      const b = document.createElement("button");
      b.className = "secondary small";
      const slotInfo = sp.level===0 ? "Cantrip" : `Lv ${sp.level} (${state.char.spellSlots[sp.level]||0} slots)`;
      b.textContent = `${sp.name} ‚Ä¢ ${slotInfo}`;
      b.disabled = !canCastSpell(sp);
      b.onclick = ()=>castSpellByName(sp.name);
      spellList.appendChild(b);
    }
  }

  // items list
  const items = $("combatItemList");
  items.innerHTML="";
  const foodCount = countItem("food");
  const ib = document.createElement("button");
  ib.className="secondary small";
  ib.textContent = `Eat Ration (${foodCount})`;
  ib.disabled = foodCount<=0;
  ib.onclick = ()=>useCombatItem("food");
  items.appendChild(ib);
}

/* =========================
   World Search / Explore
========================= */
function searchExplore(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't search during combat."); render(); return; }
  if(state.mode==="dungeon"){ dungeonSearch(); return; }

  passTime(20, "World search");
  const n=nodeById[state.currentNode];
  const r=roll(100);

  if(n.type==="landmark"){
    frostspireTimeSink(true);
    return;
  }

  if(r<=18){
    const g=roll(16)+4; state.gold+=g; pushLog(`üîé Found <b>${g}g</b>.`);
    awardXP(10);
  } else if(r<=32){
    const loot = pickShopItem(["weapon","armor","misc"]).item;
    if(addToBag({...loot})) pushLog(`üîé Found <b>${fmtItem(loot)}</b>.`);
    awardXP(12);
  } else pushLog("üîé Nothing useful.");

  // encounter chance higher in war kingdoms
  const risk = (WAR_PAIR.includes(n.kingdom) ? 14 : 10);
  if(roll(100)<=risk) startCombat(makeEnemy("ambush"), {origin:"world"});
  render();
}

/* =========================
   Sleep/Eat/Buy
========================= */
function canSleepHere(){
  const n=nodeById[state.currentNode];
  return state.mode==="world" && (n.type==="city"||n.type==="town"||n.type==="port"||n.type==="capital"||n.type==="camp");
}
function sleep(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't sleep in combat."); render(); return; }
  if(!canSleepHere()){ pushLog("üõå You can only sleep in a settlement or camp."); render(); return; }

  const now = state.minutes;
  const target = 8*60;
  let delta = (target - now);
  if(delta<=0) delta += 1440;
  passTime(delta, "Sleep");

  // restore HP, hunger, and refresh long buffs
  const heal = 10 + roll(8);
  state.hp = clamp(state.hp + heal, 0, state.hpMax);
  state.hunger = clamp(state.hunger + 4, 0, state.hungerMax);

  // clear long buffs
  resetTempBuffs();

  pushLog(`<span style="color:var(--good)">üõå Slept safely. Healed ${heal} HP.</span>`);
  render();
}
function eat(){
  if(state.mode==="combat"){ pushLog("‚ö†Ô∏è Can't eat in combat."); render(); return; }
  if(countItem("food")<=0){ pushLog("üçó No rations."); render(); return; }
  consumeItem("food",1);
  state.hunger = clamp(state.hunger + 5, 0, state.hungerMax);
  state.hp = clamp(state.hp + 2, 0, state.hpMax);
  pushLog(`<span style="color:var(--good)">üçó Ate a ration. +Hunger, +HP.</span>`);
  render();
}
function canBuyHere(){
  const n=nodeById[state.currentNode];
  return state.mode==="world" && (n.type==="city"||n.type==="town"||n.type==="port"||n.type==="capital"||n.type==="camp");
}
function buyRation(){
  if(!canBuyHere()){ pushLog("üõí Buy rations in settlements/camps."); render(); return; }
  if(state.gold<5){ pushLog("üõí Not enough gold for a ration."); render(); return; }
  const ok = addToBag({type:"consumable", name:"Ration", kind:"food", qty:1, weight:0.5});
  if(!ok){ render(); return; }
  state.gold -= 5;
  pushLog("üõí Bought <b>1 Ration</b> for 5g.");
  render();
}

/* =========================
   Quest Board modal
========================= */
function openQuestBoard(){
  const n=nodeById[state.currentNode];
  if(state.mode!=="world" || !(n.type==="city"||n.type==="town"||n.type==="port"||n.type==="capital"||n.type==="camp")){
    openModal("Quest Board", "You can only access a quest board in a settlement or camp.");
    return;
  }

  const list = questBoardForNode(n.id);
  let html = `<div style="margin-top:10px;color:var(--muted)">Available quests in <b>${n.name}</b>:</div><div style="margin-top:10px;display:grid;gap:10px">`;

  if(list.length===0){
    html += `<div class="panel">No quests posted here.</div>`;
  } else {
    for(const q of list){
      const st=questStatus(q.id);
      const canAccept = !st.accepted && !st.completed && !state.activeQuestId;
      const isActive = state.activeQuestId===q.id && st.accepted && !st.completed;
      html += `
        <div class="panel">
          <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap">
            <div><b>${q.title}</b><div class="muted">${q.text}</div></div>
            <div class="muted">To: <b>${nodeById[q.to]?.name||q.to}</b> ‚Ä¢ Reward: <b>${q.reward.gold}g</b> ‚Ä¢ <b>${q.reward.xp} XP</b>${q.reward.key?` + <b>${q.reward.key}</b> key`:""}</div>
          </div>
          <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center">
            ${st.completed ? `<button class="secondary small" disabled>Completed</button>` : ""}
            ${isActive ? `<button class="secondary small" disabled>Active</button>` : ""}
            ${canAccept ? `<button class="small" onclick="acceptQuest('${q.id}')">Accept</button>` : ""}
            ${(!canAccept && !st.completed && !isActive && st.accepted) ? `<button class="secondary small" disabled>Accepted</button>` : ""}
            ${(!canAccept && !st.completed && !isActive && !st.accepted && state.activeQuestId) ? `<span class="muted">Finish/clear your active quest first.</span>` : ""}
          </div>
        </div>
      `;
    }
  }
  html += `</div>`;
  openModal("Quest Board", html);
}
function acceptQuest(qid){
  closeModal();
  const q = QUESTS.find(x=>x.id===qid);
  if(!q) return;
  const st=questStatus(qid);
  if(st.completed || st.accepted) return;
  if(state.activeQuestId){ pushLog("üìú You already have an active quest."); render(); return; }

  // carry check
  const projected = carryNow() + (q.item.weight||0);
  if(projected > carryMax()){
    pushLog(`<span style="color:var(--warn)">üéí Too heavy to accept this quest item (carry limit).</span>`);
    render(); return;
  }

  setQuestStatus(qid,{accepted:true,completed:false});
  state.activeQuestId = qid;
  addQuestItem(q.item);
  pushLog(`üìú Quest accepted: <b>${q.title}</b>. Deliver to <b>${nodeById[q.to]?.name||q.to}</b>.`);
  render();
}

/* =========================
   Visit City establishments (shops, bank, jobs, property, stable, etc.)
========================= */
function openVisit(){
  const n=nodeById[state.currentNode];
  if(state.mode!=="world" || !(n.type==="city"||n.type==="town"||n.type==="port"||n.type==="capital"||n.type==="camp")){
    openModal("Visit", "You can only visit establishments in a settlement or camp.");
    return;
  }

  const popLine = n.population ? `Population: <b>${n.population.toLocaleString()}</b>` : `Population: <b>‚Äî</b>`;
  const kLine = `<div class="muted" style="margin-top:6px">Kingdom: <b>${n.kingdom}</b> ‚Ä¢ Biome: <b>${n.biome}</b> ‚Ä¢ ${popLine}</div>`;

  const est = n.establishments || [];
  const chips = {
    church:{label:"‚õ™ Church", fn:()=>openChurch(n)},
    tavern:{label:"üç∫ Tavern", fn:()=>openTavern(n)},
    inn:{label:"üõå Inn", fn:()=>openInn(n)},
    weapon:{label:"‚öîÔ∏è Weapon Shop", fn:()=>openShop(n,"weapon")},
    armor:{label:"üõ°Ô∏è Armor Shop", fn:()=>openShop(n,"armor")},
    food:{label:"üçó Food Stall", fn:()=>openShop(n,"food")},
    misc:{label:"üß∞ Misc Shop", fn:()=>openShop(n,"misc")},
    library:{label:"üìö Library", fn:()=>openLibrary(n)},
    guild:{label:"üßæ Guild", fn:()=>openGuild(n)},
    bank:{label:"üè¶ Bank", fn:()=>openBank(n)},
    stable:{label:"üê¥ Stable", fn:()=>openStable(n)},
    property:{label:"üè† Property Office", fn:()=>openPropertyOffice(n)},
    jobs:{label:"üõ†Ô∏è Day Jobs", fn:()=>openJobs(n)}
  };

  let html = `
    <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
      <div>
        <div style="font-weight:800;font-size:18px">${n.name}</div>
        ${kLine}
      </div>
      <div class="muted">Cash: <b>${state.gold}g</b> ‚Ä¢ Bank: <b>${state.bank}g</b> ‚Ä¢ Carry: <b>${carryNow()}/${carryMax()}</b></div>
    </div>
    <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
  `;

  for(const key of est){
    if(key==="bank" && !isBigCity(n)) continue; // banks only big cities/capitals
    if(chips[key]) html += `<button class="secondary small" onclick="visitAction('${key}')">${chips[key].label}</button>`;
  }
  if(n.type==="camp"){
    html += `<button class="secondary small" onclick="visitAction('jobs')">üõ†Ô∏è Day Jobs</button>`;
    html += `<button class="secondary small" onclick="visitAction('food')">üçó Supplies</button>`;
  }
  html += `</div>`;

  // special: Frostspire note (if present)
  if(n.type==="landmark"){
    html += `<div class="panel" style="margin-top:12px">This place isn't a city. There's nothing to visit.</div>`;
  }

  openModal("Visit", html);
}
window.visitAction = function(key){
  closeModal();
  const n=nodeById[state.currentNode];
  const map = {
    church:()=>openChurch(n),
    tavern:()=>openTavern(n),
    inn:()=>openInn(n),
    weapon:()=>openShop(n,"weapon"),
    armor:()=>openShop(n,"armor"),
    food:()=>openShop(n,"food"),
    misc:()=>openShop(n,"misc"),
    library:()=>openLibrary(n),
    guild:()=>openGuild(n),
    bank:()=>openBank(n),
    stable:()=>openStable(n),
    property:()=>openPropertyOffice(n),
    jobs:()=>openJobs(n)
  };
  (map[key]||(()=>{}))();
};

function openShop(node, shopType){
  const title = ({
    weapon:"Weapon Shop",
    armor:"Armor Shop",
    food:"Food Stall",
    misc:"Misc Shop"
  })[shopType] || "Shop";

  const stock = ITEMS.filter(it=>it.shop===shopType);
  let html = `<div class="muted">You browse the ${title.toLowerCase()} in <b>${node.name}</b>. Carry: <b>${carryNow()}/${carryMax()}</b> ‚Ä¢ Gold: <b>${state.gold}g</b></div>`;
  html += `<div style="margin-top:10px;display:grid;gap:10px">`;

  for(const it of stock){
    const canBuy = state.gold >= it.cost;
    const allowed = (it.type==="consumable" || canEquip(it));
    html += `
      <div class="panel" style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
        <div>
          <b>${it.name}</b>
          <div class="muted">${it.type.toUpperCase()} ‚Ä¢ ${it.atk?`+${it.atk} ATK ‚Ä¢ `:""}${it.def?`+${it.def} DEF ‚Ä¢ `:""}Weight ${it.weight} ‚Ä¢ Tags ${it.tags.join(", ")}</div>
          ${(!allowed && it.type!=="consumable") ? `<div class="muted" style="color:var(--warn)">Your class cannot equip this.</div>` : ""}
        </div>
        <div style="display:flex;gap:10px;align-items:center">
          <div class="muted"><b>${it.cost}g</b></div>
          <button class="small ${canBuy && allowed ? "" : "secondary"}" ${canBuy && allowed ? "" : "disabled"} onclick="buyItem('${it.name}', '${shopType}')">Buy</button>
        </div>
      </div>
    `;
  }
  html += `</div>`;
  openModal(title, html);
}
window.buyItem = function(itemName, shopType){
  const it = ITEMS.find(x=>x.name===itemName && x.shop===shopType);
  if(!it) return;
  if(state.gold < it.cost){ return; }
  if(it.type!=="consumable" && !canEquip(it)){
    pushLog(`<span style="color:var(--warn)">‚õî Your class cannot use ${it.name}.</span>`);
    closeModal(); render(); return;
  }
  const item = {...it};
  const ok = addToBag(item.type==="consumable" ? { ...item, qty:1 } : item);
  if(!ok){ closeModal(); render(); return; }
  state.gold -= it.cost;
  pushLog(`üõí Bought <b>${it.name}</b> for ${it.cost}g.`);
  closeModal();
  render();
};

function openBank(node){
  if(!isBigCity(node)){
    openModal("Bank", "Banks are only accessible in big cities and capitals.");
    return;
  }
  const withdrawFeePct = 0.05; // 5% fee
  const html = `
    <div class="muted">Welcome to the Bank of <b>${node.name}</b>. Deposits earn daily interest. Withdrawals cost a 5% fee.</div>
    <div class="panel" style="margin-top:10px">
      <div>Cash: <b>${state.gold}g</b> ‚Ä¢ Bank Balance: <b>${state.bank}g</b></div>
      <div class="row" style="margin-top:10px">
        <button class="secondary small" onclick="bankDeposit(25)">Deposit 25g</button>
        <button class="secondary small" onclick="bankDeposit(100)">Deposit 100g</button>
        <button class="secondary small" onclick="bankDepositAll()">Deposit All</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="secondary small" onclick="bankWithdraw(25)">Withdraw 25g</button>
        <button class="secondary small" onclick="bankWithdraw(100)">Withdraw 100g</button>
        <button class="secondary small" onclick="bankWithdrawAll()">Withdraw All</button>
      </div>
      <div class="muted" style="margin-top:10px">Withdrawal fee: <b>${Math.round(withdrawFeePct*100)}%</b> (fee is taken from the amount withdrawn).</div>
    </div>
  `;
  openModal("Bank", html);
}
window.bankDeposit = function(amount){
  amount = Math.floor(amount);
  if(amount<=0) return;
  if(state.gold < amount) return;
  state.gold -= amount;
  state.bank += amount;
  pushLog(`üè¶ Deposited ${amount}g.`);
  closeModal(); render();
};
window.bankDepositAll = function(){
  const amount = state.gold;
  if(amount<=0) return;
  state.gold = 0;
  state.bank += amount;
  pushLog(`üè¶ Deposited ${amount}g.`);
  closeModal(); render();
};
window.bankWithdraw = function(amount){
  amount = Math.floor(amount);
  if(amount<=0) return;
  if(state.bank < amount) return;
  const fee = Math.max(1, Math.floor(amount * 0.05));
  const net = Math.max(0, amount - fee);
  state.bank -= amount;
  state.gold += net;
  pushLog(`üè¶ Withdrew ${net}g (fee ${fee}g).`);
  closeModal(); render();
};
window.bankWithdrawAll = function(){
  const amount = state.bank;
  if(amount<=0) return;
  const fee = Math.max(1, Math.floor(amount * 0.05));
  const net = Math.max(0, amount - fee);
  state.bank = 0;
  state.gold += net;
  pushLog(`üè¶ Withdrew ${net}g (fee ${fee}g).`);
  closeModal(); render();
};

function openStable(node){
  const html = `
    <div class="muted">Stable in <b>${node.name}</b>. Mounts increase travel speed and carry capacity.</div>
    <div class="panel" style="margin-top:10px">
      <div>Current Mount: <b>${state.mount ? state.mount.name : "None"}</b></div>
      <div class="muted">Gold: <b>${state.gold}g</b></div>
    </div>
    <div style="margin-top:10px;display:grid;gap:10px">
      ${MOUNTS.map(m=>`
        <div class="panel" style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
          <div>
            <b>${m.name}</b>
            <div class="muted">Speed √ó${m.speedMult} ‚Ä¢ Carry +${m.carryBonus} ‚Ä¢ Cost ${m.cost}g</div>
          </div>
          <button class="small ${state.gold>=m.cost ? "" : "secondary"}" ${state.gold>=m.cost ? "" : "disabled"} onclick="buyMount('${m.type}')">Buy</button>
        </div>
      `).join("")}
      ${state.mount ? `<button class="secondary small" onclick="sellMount()">Sell Mount (60% refund)</button>` : ""}
    </div>
  `;
  openModal("Stable", html);
}
window.buyMount = function(type){
  const m = MOUNTS.find(x=>x.type===type);
  if(!m) return;
  if(state.gold < m.cost) return;
  state.gold -= m.cost;
  state.mount = {...m};
  pushLog(`üê¥ Purchased <b>${m.name}</b>. Travel is faster now.`);
  closeModal(); render();
};
window.sellMount = function(){
  if(!state.mount) return;
  const refund = Math.floor(state.mount.cost * 0.60);
  state.gold += refund;
  pushLog(`üê¥ Sold mount for ${refund}g.`);
  state.mount = null;
  closeModal(); render();
};

function openPropertyOffice(node){
  // allow buying land/house/castle in big cities & capitals
  const can = (node.type==="capital" || node.bigCity);
  if(!can){
    openModal("Property Office", "Property offices are only available in big cities and capitals.");
    return;
  }

  // pricing by city importance
  const base = node.type==="capital" ? 260 : 160;
  const options = [
    {type:"land", name:"Small Plot of Land", cost: base, incomePerDay: 2},
    {type:"house", name:"Townhouse", cost: base*3, incomePerDay: 6},
    {type:"castle", name:"Small Keep", cost: base*11, incomePerDay: 22},
    {type:"business", name:"Tavern Business", cost: base*6, incomePerDay: 14},
    {type:"business", name:"Inn Business", cost: base*7, incomePerDay: 16},
    {type:"business", name:"Shop Business", cost: base*5, incomePerDay: 12},
    {type:"business", name:"Guild Hall Business", cost: base*9, incomePerDay: 20},
  ];

  let html = `<div class="muted">Property office in <b>${node.name}</b> ‚Ä¢ Gold: <b>${state.gold}g</b></div>`;
  html += `<div style="margin-top:10px;display:grid;gap:10px">`;
  for(const o of options){
    html += `
      <div class="panel" style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
        <div>
          <b>${o.name}</b>
          <div class="muted">${o.type.toUpperCase()} ‚Ä¢ Income ${o.incomePerDay}g/day ‚Ä¢ Location ${node.kingdom}</div>
        </div>
        <button class="small ${state.gold>=o.cost ? "" : "secondary"}" ${state.gold>=o.cost ? "" : "disabled"} onclick="buyProperty('${o.name}', ${o.cost}, ${o.incomePerDay}, '${o.type}')">Buy (${o.cost}g)</button>
      </div>
    `;
  }
  html += `</div>`;

  const owned = state.properties.filter(p=>p.nodeId===node.id);
  html += `<div class="panel" style="margin-top:12px">
    <b>Owned Here</b>
    <div class="muted">${owned.length ? owned.map(p=>`${p.name} (+${p.incomePerDay}g/day)`).join(", ") : "None"}</div>
  </div>`;

  openModal("Property Office", html);
}
window.buyProperty = function(name, cost, income, type){
  if(state.gold < cost) return;
  state.gold -= cost;
  state.properties.push({type, name, kingdom: nodeById[state.currentNode].kingdom, nodeId: state.currentNode, incomePerDay: income, boughtDay: state.day});
  pushLog(`üè† Purchased <b>${name}</b> in ${nodeById[state.currentNode].name}.`);
  closeModal(); render();
};

function openJobs(node){
  const pay = node.type==="capital" ? 28 : node.bigCity ? 22 : node.type==="town" ? 18 : 12;
  const xp = node.type==="capital" ? 25 : node.bigCity ? 20 : 15;
  const html = `
    <div class="muted">Non-adventuring jobs in <b>${node.name}</b>. Working passes time and pays gold.</div>
    <div class="panel" style="margin-top:10px">
      <b>Day Shift Work</b>
      <div class="muted">Gain ${pay}g + ${xp} XP ‚Ä¢ Passes 8 hours.</div>
      <div class="row" style="margin-top:10px">
        <button class="small" onclick="workJob(${pay}, ${xp})">Work a Shift</button>
      </div>
    </div>
  `;
  openModal("Day Jobs", html);
}
window.workJob = function(pay, xp){
  closeModal();
  passTime(8*60, "Work shift");
  state.gold += pay;
  awardXP(xp);
  state.char.jobsCompleted += 1;
  pushLog(`<span style="color:var(--good)">üõ†Ô∏è Worked a shift: +${pay}g</span>`);
  // small hunger hit
  state.hunger = clamp(state.hunger - 1, 0, state.hungerMax);
  render();
};

function openInn(node){
  const cost = node.type==="capital" ? 10 : 7;
  const html = `
    <div class="muted">Inn rooms restore more HP for a fee.</div>
    <div class="panel" style="margin-top:10px">
      <div>Cost: <b>${cost}g</b> ‚Ä¢ Gold: <b>${state.gold}g</b></div>
      <div class="muted">Rest to morning 08:00 and heal + extra.</div>
      <div class="row" style="margin-top:10px">
        <button class="small ${state.gold>=cost ? "" : "secondary"}" ${state.gold>=cost ? "" : "disabled"} onclick="rentRoom(${cost})">Rent Room</button>
      </div>
    </div>
  `;
  openModal("Inn", html);
}
window.rentRoom = function(cost){
  if(state.gold<cost) return;
  state.gold -= cost;
  closeModal();
  sleep();
  // bonus heal
  state.hp = clamp(state.hp + 6, 1, state.hpMax);
  pushLog(`<span style="color:var(--good)">üõå Inn comfort: extra healing.</span>`);
  render();
};

function openTavern(node){
  const html = `
    <div class="muted">The tavern is full of rumors, traders, and potential partners.</div>
    <div class="panel" style="margin-top:10px">
      <b>Gather Rumors</b>
      <div class="muted">Pass 1 hour, chance to gain a hint or small XP.</div>
      <div class="row" style="margin-top:10px">
        <button class="small" onclick="tavernRumors()">Listen</button>
        <button class="secondary small" onclick="tavernSocialize()">Socialize</button>
      </div>
    </div>
    <div class="panel" style="margin-top:10px">
      <b>War News</b>
      <div class="muted">${WAR_PAIR.includes(node.kingdom) ? "The war is on everyone's lips here." : "Trade routes are tense, but distant."}</div>
    </div>
  `;
  openModal("Tavern", html);
}
window.tavernRumors = function(){
  closeModal();
  passTime(60, "Tavern rumors");
  if(roll(100)<=55){
    awardXP(10);
    pushLog(`üó£Ô∏è You learn something useful (+XP).`);
  } else {
    pushLog(`üó£Ô∏è Mostly nonsense.`);
  }
  render();
};
window.tavernSocialize = function(){
  closeModal();
  passTime(75, "Socialize");
  // simple marriage system (no placeholders in logic)
  if(!state.char.spouse && roll(100)<=18){
    const names = ["Mira","Elowen","Kael","Thorne","Selene","Bryn","Darian","Nysa","Rowan","Soren"];
    state.char.spouse = names[Math.floor(rngWorld()*names.length)];
    pushLog(`<span style="color:var(--good)">üíç You meet <b>${state.char.spouse}</b> and begin courting.</span>`);
  } else if(state.char.spouse && roll(100)<=12){
    // kids chance
    state.char.kids += 1;
    pushLog(`<span style="color:var(--good)">üë∂ You and ${state.char.spouse} have a child. Total children: <b>${state.char.kids}</b></span>`);
  } else {
    pushLog(`üôÇ You share stories and move on.`);
  }
  render();
};

function openChurch(node){
  const donate = 8;
  const html = `
    <div class="muted">The church offers blessings and calm.</div>
    <div class="panel" style="margin-top:10px">
      <b>Donate</b>
      <div class="muted">Donate ${donate}g to gain a small heal and XP.</div>
      <div class="row" style="margin-top:10px">
        <button class="small ${state.gold>=donate ? "" : "secondary"}" ${state.gold>=donate ? "" : "disabled"} onclick="donateChurch(${donate})">Donate</button>
      </div>
    </div>
  `;
  openModal("Church", html);
}
window.donateChurch = function(amount){
    if(state.gold < amount) return;
    state.gold -= amount;
    closeModal();
    passTime(40, "Church donation");
    const heal = 6 + roll(6);
    state.hp = clamp(state.hp + heal, 1, state.hpMax);
    awardXP(12);
    pushLog(`<span style="color:var(--good)">‚õ™ Donation accepted. You feel renewed (+${heal} HP).</span>`);
    render();
};

/* =========================
   Library / Guild (lightweight)
========================= */
function openLibrary(node){
  const html = `
    <div class="muted">Quiet halls, old maps, and spell lore. You can study to gain XP or learn more about the world.</div>
    <div class="panel" style="margin-top:10px">
      <b>Study</b>
      <div class="muted">Pass 2 hours ‚Ä¢ Gain 18 XP</div>
      <div class="row" style="margin-top:10px">
        <button class="small" onclick="libraryStudy()">Study</button>
        <button class="secondary small" onclick="libraryMaps()">Read Maps</button>
      </div>
    </div>
  `;
  openModal("Library", html);
}
window.libraryStudy = function(){
  closeModal();
  passTime(120, "Library study");
  awardXP(18);
  pushLog(`üìö You study diligently.`);
  render();
};
window.libraryMaps = function(){
  closeModal();
  passTime(45, "Reading maps");
  pushLog(`üó∫Ô∏è You learn trade routes, borders, and rumor corridors.`);
  // tiny benefit: reduce next travel time very slightly (one-time)
  state._mapInsight = true;
  render();
};

function openGuild(node){
  const html = `
    <div class="muted">The guild offers contracts, training, and connections.</div>
    <div class="panel" style="margin-top:10px">
      <b>Training Session</b>
      <div class="muted">Pass 3 hours ‚Ä¢ Gain 22 XP</div>
      <div class="row" style="margin-top:10px">
        <button class="small" onclick="guildTrain()">Train</button>
      </div>
    </div>
    <div class="panel" style="margin-top:10px">
      <b>Connections</b>
      <div class="muted">Sometimes leads to a rumor about war zones or bandit roads.</div>
      <div class="row" style="margin-top:10px">
        <button class="secondary small" onclick="guildConnections()">Ask Around</button>
      </div>
    </div>
  `;
  openModal("Guild", html);
}
window.guildTrain = function(){
  closeModal();
  passTime(180, "Guild training");
  awardXP(22);
  pushLog(`üßæ You train with guild veterans.`);
  render();
};
window.guildConnections = function(){
  closeModal();
  passTime(55, "Guild connections");
  const n = nodeById[state.currentNode];
  if(WAR_PAIR.includes(n.kingdom)){
    pushLog(`üó£Ô∏è Rumor: skirmishes are flaring near the Valoria‚ÄìKragmire border roads.`);
  } else {
    pushLog(`üó£Ô∏è Rumor: traders avoid certain roads after dusk ‚Äî bandits are organized lately.`);
  }
  render();
};

/* =========================
   Trader encounter modal
========================= */
function openTraderModal(edge, toId){
  // Pause travel flow: show trader, then you either trade and continue or ignore and continue
  const offers = [];
  const pool = ITEMS.filter(it=>it.type!=="consumable");
  for(let i=0;i<4;i++){
    const it = pool[Math.floor(rngWorld()*pool.length)];
    const discount = 0.75 + rngWorld()*0.18;
    const cost = Math.max(3, Math.floor(it.cost * discount));
    offers.push({it, cost});
  }

  const html = `
    <div class="muted">A roadside trader flags you down. Some deals are good ‚Äî some are suspicious.</div>
    <div class="panel" style="margin-top:10px">
      <div class="muted">Gold: <b>${state.gold}g</b> ‚Ä¢ Carry: <b>${carryNow()}/${carryMax()}</b></div>
    </div>
    <div style="margin-top:10px;display:grid;gap:10px">
      ${offers.map(o=>{
        const allowed = canEquip(o.it);
        const canBuy = state.gold >= o.cost && (o.it.type==="accessory" || allowed);
        return `
          <div class="panel" style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
            <div>
              <b>${o.it.name}</b>
              <div class="muted">${o.it.type.toUpperCase()} ‚Ä¢ ${o.it.atk?`+${o.it.atk} ATK ‚Ä¢ `:""}${o.it.def?`+${o.it.def} DEF ‚Ä¢ `:""}Weight ${o.it.weight} ‚Ä¢ ${o.it.tags.join(", ")}</div>
              ${(!allowed && o.it.type!=="accessory") ? `<div class="muted" style="color:var(--warn)">Your class cannot equip this.</div>` : ``}
            </div>
            <div style="display:flex;gap:10px;align-items:center">
              <div class="muted"><b>${o.cost}g</b></div>
              <button class="small ${canBuy ? "" : "secondary"}" ${canBuy ? "" : "disabled"} onclick="buyTrader('${o.it.name}', ${o.cost}, '${toId}')">Buy</button>
            </div>
          </div>
        `;
      }).join("")}
    </div>

    <div class="panel" style="margin-top:12px">
      <b>Risky Shortcut Offer</b>
      <div class="muted">‚ÄúI know a faster route‚Ä¶‚Äù (Chance: it‚Äôs a bandit trap.)</div>
      <div class="row" style="margin-top:10px">
        <button class="secondary small" onclick="traderShortcut('${toId}')">Take Shortcut</button>
        <button class="secondary small" onclick="traderIgnore('${toId}')">Ignore & Continue</button>
      </div>
    </div>
  `;
  openModal("Roadside Trader", html);
}
window.buyTrader = function(itemName, cost, toId){
  const it = ITEMS.find(x=>x.name===itemName);
  if(!it) return;
  if(state.gold < cost) return;
  if(it.type!=="consumable" && !canEquip(it)){
    pushLog(`<span style="color:var(--warn)">‚õî Your class cannot use ${it.name}.</span>`);
    closeModal(); render(); return;
  }
  const ok = addToBag({...it});
  if(!ok){ closeModal(); render(); return; }
  state.gold -= cost;
  pushLog(`üß≥ Trader deal: bought <b>${it.name}</b> for ${cost}g.`);
  closeModal();
  // continue travel after trading
  pushLog(`üß≠ You continue toward <b>${nodeById[toId].name}</b>.`);
  enterNode(toId);
  render();
};
window.traderIgnore = function(toId){
  closeModal();
  pushLog(`üß≠ You ignore the trader and continue to <b>${nodeById[toId].name}</b>.`);
  enterNode(toId);
  render();
};
window.traderShortcut = function(toId){
  closeModal();
  passTime(18, "Shortcut attempt");
  if(roll(100) <= 55){
/* =========================
   Frostspire time sink (NO ENTRANCE)
========================= */
function frostspireTimeSink(fromSearch=false){
  if(state.mode!=="world") return;
  const n = nodeById[state.currentNode];
  if(!n || !n.name.includes("Frostspire")) return;

  const spent = 70 + roll(120);
  passTime(spent, "Searching Frostspire");
  const hints = [
    "You find etched runes that almost look like a doorway outline‚Ä¶ almost.",
    "A draft of cold air teases you from a crack ‚Äî but it dead-ends into solid ice.",
    "You discover an old camp with notes: ‚ÄúI swear it‚Äôs here.‚Äù The trail stops.",
    "You follow a spiral ridge for hours. It loops back to where you started.",
    "You knock on the ice and hear something hollow‚Ä¶ then realize it‚Äôs your own echo."
  ];
  pushLog(`<span style="color:var(--warn)">üßä Frostspire wastes your time. ${hints[Math.floor(rngWorld()*hints.length)]}</span>`);
  if(fromSearch) pushLog(`üîé No entrance. Still none.`);
  render();
}

/* =========================
   GUIDE
========================= */
function openGuide(){
  const html = `
    <div class="panel">
      <b>Controls</b>
      <div class="muted" style="margin-top:6px">
        World Map: click a connected location to travel ‚Ä¢ mouse wheel to zoom ‚Ä¢ drag to pan<br>
        Dungeons: move with <kbd>WASD</kbd> or <kbd>‚Üë‚Üì‚Üê‚Üí</kbd> ‚Ä¢ Interact panel shows actions<br>
        Combat: Use Attack / Spell / Item / Flee on Combat Screen
      </div>
    </div>

    <div class="panel" style="margin-top:10px">
      <b>Core Systems</b>
      <div class="muted" style="margin-top:6px">
        Level & XP: gain XP from quests, jobs, combat, studying. Level increases HP and spell access.<br>
        Carry Weight: max is based on STR. Horses and wagons increase max carry + speed.<br>
        Banks: only in big cities/capitals. Earn daily interest. Withdrawals have a fee.<br>
        Properties/Businesses: buy in big cities/capitals; earn daily income.<br>
        Calendar/Aging: seasons advance every 30 days; age increases yearly.
      </div>
    </div>

    <div class="panel" style="margin-top:10px">
      <b>Classes</b>
      <div class="muted" style="margin-top:6px">
        Fighters/Barbarians excel in melee. Rogues favor finesse/ranged. Monks prefer no armor.<br>
        Full casters (Wizard/Cleric/Bard/Druid/Sorcerer) use spell slots; Warlock uses pact slots.<br>
        Paladin/Ranger are half-casters.
      </div>
    </div>

    <div class="panel" style="margin-top:10px">
      <b>World & War</b>
      <div class="muted" style="margin-top:6px">
        Two kingdoms are at war: <b>Valoria</b> and <b>Kragmire</b>. Border roads can trigger skirmishes.<br>
        Traders and bandits appear on roads. Snow and arctic zones exist in the far north.<br>
        Frostspire (ice mountain) has rumors of an entrance ‚Äî but there is no way inside.
      </div>
    </div>
  `;
  openModal("In-Game Guide", html);
}

/* =========================
   MODAL helpers
========================= */
function openModal(title, bodyHtml){
  $("overlay").style.display="flex";
  $("modalTitle").textContent = title;
  $("modalBody").innerHTML = bodyHtml;
}
function closeModal(){
  $("overlay").style.display="none";
  $("modalTitle").textContent = "";
  $("modalBody").textContent = "";
}
$("closeModal").addEventListener("click", closeModal);
$("overlay").addEventListener("click", (e)=>{
  if(e.target === $("overlay")) closeModal();
});
document.addEventListener("keydown", (e)=>{
  if(e.key==="Escape"){
    if($("overlay").style.display==="flex") closeModal();
    if($("creatorOverlay").style.display==="flex" && state.creatorLocked) $("creatorOverlay").style.display="none";
  }
});

/* =========================
   Character Creator (locked after confirm)
========================= */
let ccRolled = null;

function openCreator(){
  $("creatorOverlay").style.display="flex";
  $("creatorLockTag").textContent = state.creatorLocked ? "Locked" : "Unconfirmed";
  $("ccCloseHint").disabled = !state.creatorLocked;

  // populate selects once
  const raceSel = $("ccRace");
  const classSel = $("ccClass");
  const birthSel = $("ccBirth");

  if(!raceSel.dataset.ready){
    raceSel.innerHTML = RACES.map(r=>`<option value="${r.name}">${r.name}</option>`).join("");
    raceSel.dataset.ready="1";
  }
  if(!classSel.dataset.ready){
    const classes = Object.keys(CLASS_RULES);
    classSel.innerHTML = classes.map(c=>`<option value="${c}">${c}</option>`).join("");
    classSel.dataset.ready="1";
  }
  if(!birthSel.dataset.ready){
    birthSel.innerHTML = KINGDOMS.map(k=>`<option value="${k.id}">${k.name}</option>`).join("");
    birthSel.dataset.ready="1";
  }

  // load state into fields
  $("ccName").value = state.char.name || "";
  $("ccSex").value = state.char.sex || "Male";
  $("ccRace").value = state.char.race || "Human";
  $("ccClass").value = state.char.class || "Fighter";
  $("ccBirth").value = state.char.birthKingdom || "Valoria";

  // render current stats display
  renderCreatorStats();
  $("ccClassRules").textContent = classRulesText($("ccClass").value);

  // enforce lock if already confirmed
  applyCreatorLockUI();
}

function applyCreatorLockUI(){
  const locked = !!state.creatorLocked;
  ["ccName","ccSex","ccRace","ccClass","ccBirth"].forEach(id=>{
    $(id).disabled = locked;
  });
  $("ccRollBtn").disabled = locked;
  $("ccConfirmBtn").disabled = locked || !ccRolled;
  $("ccCloseHint").disabled = !locked;

  $("creatorLockTag").textContent = locked ? "Locked" : "Unconfirmed";
}

function roll4d6DropLowest(){
  const dice = [roll(6),roll(6),roll(6),roll(6)].sort((a,b)=>a-b);
  return dice[1]+dice[2]+dice[3];
}

function renderCreatorStats(){
  const grid = $("ccStats");
  grid.innerHTML = "";
  const stats = ccRolled || {
    str: state.char.str, dex: state.char.dex, con: state.char.con,
    int: state.char.int, wis: state.char.wis, cha: state.char.cha
  };
  const entries = Object.entries(stats);
  for(const [k,v] of entries){
    const div = document.createElement("div");
    div.className = "statBox";
    div.innerHTML = `<div class="smallMuted">${k.toUpperCase()}</div><b>${v}</b>`;
    grid.appendChild(div);
  }
}

$("ccClass").addEventListener("change", ()=>{
  $("ccClassRules").textContent = classRulesText($("ccClass").value);
});

$("ccRollBtn").addEventListener("click", ()=>{
  if(state.creatorLocked) return;
  ccRolled = {
    str: roll4d6DropLowest(),
    dex: roll4d6DropLowest(),
    con: roll4d6DropLowest(),
    int: roll4d6DropLowest(),
    wis: roll4d6DropLowest(),
    cha: roll4d6DropLowest()
  };
  renderCreatorStats();
  $("ccConfirmBtn").disabled = false;
});

function pickStartingGear(cls){
  // simple sensible defaults that always meet restrictions
  const starter = {weapon:null, armor:null, accessory:null, bag:[]};

  // weapon
  if(cls==="Wizard"||cls==="Sorcerer"||cls==="Warlock"||cls==="Cleric"||cls==="Druid"||cls==="Bard"){
    starter.weapon = ITEMS.find(i=>i.name==="Dagger");
  } else if(cls==="Monk"){
    starter.weapon = ITEMS.find(i=>i.name==="Quarterstaff");
  } else if(cls==="Rogue"){
    starter.weapon = ITEMS.find(i=>i.name==="Shortsword");
  } else if(cls==="Ranger"){
    starter.weapon = ITEMS.find(i=>i.name==="Bow");
  } else {
    starter.weapon = ITEMS.find(i=>i.name==="Longsword");
  }

  // armor
  if(CLASS_RULES[cls].armor.includes("light")){
    starter.armor = ITEMS.find(i=>i.name==="Leather Armor");
  } else if(CLASS_RULES[cls].armor.includes("medium")){
    starter.armor = ITEMS.find(i=>i.name==="Chain Shirt");
  } else {
    starter.armor = null;
  }

  // monk: no armor
  if(cls==="Monk") starter.armor = null;

  starter.bag.push({type:"consumable", name:"Ration", kind:"food", qty:2, weight:0.5});
  return starter;
}

function setStartingNodeFromBirth(kingdomId){
  // choose capital in that kingdom, fallback first node
  const cap = world.nodes.find(n=>n.type==="capital" && n.kingdom===kingdomId) ||
              world.nodes.find(n=>n.type==="capital" && (n.name.includes("Aurelia") && kingdomId==="Valoria")) ||
              world.nodes.find(n=>n.type==="capital" && (n.name.includes("Kragholm") && kingdomId==="Kragmire")) ||
              world.nodes.find(n=>n.type==="city" && n.kingdom===kingdomId) ||
              world.nodes[0];
  return cap?.id || world.nodes[0].id;
}

$("ccConfirmBtn").addEventListener("click", ()=>{
  if(state.creatorLocked) return;
  if(!ccRolled){
    openModal("Character Creator", "Roll your stats first.");
    return;
  }

  // write fields
  state.char.name = ($("ccName").value || "").trim() || "Adventurer";
  state.char.sex = $("ccSex").value;
  state.char.race = $("ccRace").value;
  state.char.class = $("ccClass").value;
  state.char.birthKingdom = $("ccBirth").value;

  // apply race bonuses
  const race = RACES.find(r=>r.name===state.char.race);
  const bonus = race?.bonus || {};
  state.char.str = ccRolled.str + (bonus.str||0);
  state.char.dex = ccRolled.dex + (bonus.dex||0);
  state.char.con = ccRolled.con + (bonus.con||0);
  state.char.int = ccRolled.int + (bonus.int||0);
  state.char.wis = ccRolled.wis + (bonus.wis||0);
  state.char.cha = ccRolled.cha + (bonus.cha||0);

  // base class stats
  const rules = CLASS_RULES[state.char.class];
  state.atkBase = rules.base.atk;
  state.defBase = rules.base.def;
  state.hpMax = rules.base.hpMax + Math.max(0, abilityMod(state.char.con));
  state.hp = state.hpMax;

  // starting gear
  const gear = pickStartingGear(state.char.class);
  state.weapon = gear.weapon ? {...gear.weapon} : null;
  state.armor = gear.armor ? {...gear.armor} : null;
  state.accessory = null;
  state.bag = gear.bag.slice();

  // spells
  learnStartingSpells();

  // starting node
  indexWorld();
  const startNode = setStartingNodeFromBirth(state.char.birthKingdom);
  state.currentNode = startNode;
  state.lastSafeNode = startNode;

  state.characterCreated = true;
  state.creatorLocked = true;

  // lock UI forever until reset
  applyCreatorLockUI();
  $("creatorOverlay").style.display="none";

  pushLog(`<span style="color:var(--good)">‚úÖ Character confirmed. Stats and creator are now locked.</span>`);
  pushLog(`üåç Birth region: <b>${state.char.birthKingdom}</b>. Starting at <b>${nodeById[startNode]?.name||"‚Äî"}</b>.`);
  save();
  render();
});

$("ccCloseHint").addEventListener("click", ()=>{
  if(state.creatorLocked) $("creatorOverlay").style.display="none";
});

/* =========================
   Buttons
========================= */
$("areaLootBtn").addEventListener("click", useAreaLoot);
$("searchBtn").addEventListener("click", searchExplore);
$("sleepBtn").addEventListener("click", sleep);
$("eatBtn").addEventListener("click", eat);
$("visitBtn").addEventListener("click", openVisit);
$("questBoardBtn").addEventListener("click", openQuestBoard);
$("guideBtn").addEventListener("click", openGuide);
$("buyFoodBtn").addEventListener("click", buyRation);

$("resetBtn").addEventListener("click", ()=>{
  localStorage.removeItem(SAVE_KEY);
  state = defaultState();
  ccRolled = null;
  world = { nodes: genNodes(), edges: [] };
  indexWorld();
  buildEdges();
  pushLog("üßº Save wiped.");
  save();
  render();
  openCreator();
});

/* =========================
   UI Rendering
========================= */
function render(){
  // if no character: force creator
  if(!state.characterCreated){
    // pick a safe default node for preview
    if(!state.currentNode){
      indexWorld();
      state.currentNode = world.nodes.find(n=>n.type==="capital")?.id || world.nodes[0].id;
      state.lastSafeNode = state.currentNode;
    }
    openCreator();
  } else {
    $("creatorOverlay").style.display="none";
  }

  indexWorld();

  // badges
  const n = nodeById[state.currentNode];
  $("modeBadge").textContent = `Mode: ${state.mode==="world" ? "Exploring" : state.mode==="dungeon" ? "Dungeon" : "Combat"}`;
  $("locBadge").textContent = `Location: ${n ? n.name : "‚Äî"}`;
  $("clockBadge").textContent = `Day ${state.day} ‚Ä¢ ${fmtTime(state.minutes)}`;
  $("regionBadge").textContent = `Birth Region: ${state.char.birthKingdom || "‚Äî"}`;
  $("youAreHereText").textContent = n ? `${n.name} ‚Ä¢ ${n.kingdom} ‚Ä¢ ${n.biome}` : "‚Äî";

  // right side stats
  $("level").textContent = state.char.level;
  const need = xpToNext(state.char.level);
  $("xpText").textContent = `${state.char.xp} / ${need} XP`;
  $("xpBar").style.width = `${clamp((state.char.xp/need)*100, 0, 100)}%`;

  $("hp").textContent = state.hp;
  $("hpMax").textContent = state.hpMax;
  $("atk").textContent = getAtk();
  $("def").textContent = getDef();

  $("energy").textContent = state.energy;
  $("energyMax").textContent = state.energyMax;
  $("hunger").textContent = state.hunger;

  $("gold").textContent = state.gold;
  $("bank").textContent = state.bank;

  $("carry").textContent = `${carryNow()}/${carryMax()}`;
  $("mount").textContent = state.mount ? state.mount.name : "None";

  $("charLine").textContent = `${state.char.name || "‚Äî"} ‚Ä¢ ${state.char.race} ‚Ä¢ ${state.char.class} ‚Ä¢ Lv ${state.char.level}`;
  $("charLine2").textContent = `STR ${state.char.str} ‚Ä¢ DEX ${state.char.dex} ‚Ä¢ CON ${state.char.con} ‚Ä¢ INT ${state.char.int} ‚Ä¢ WIS ${state.char.wis} ‚Ä¢ CHA ${state.char.cha}`;
  $("age").textContent = state.char.age;
  $("dateText").textContent = `Year ${state.year} ‚Ä¢ ${SEASONS[state.seasonIndex]} ‚Ä¢ Day ${state.dayOfSeason}`;

  // spells panel
  if(isCasterClass(state.char.class)){
    const known = state.char.spellsKnown || [];
    const slotStr = Object.entries(state.char.spellSlots||{})
      .filter(([k,v])=>v>0)
      .map(([k,v])=>`Lv${k}:${v}`)
      .join(" ‚Ä¢ ") || "No slots";
    $("spellInfo").innerHTML = `Known: <b>${known.join(", ") || "None"}</b><div class="smallMuted" style="margin-top:6px">Slots: <b>${slotStr}</b></div>`;
  } else {
    $("spellInfo").textContent = "No spells.";
  }
  renderSpellSlots();

  // equipment slots
  $("weaponSlot").innerHTML = `
    <strong>Weapon</strong>
    <div class="itemName">${state.weapon ? fmtItem(state.weapon) : "None"}</div>
    <div class="row" style="justify-content:center">
      <button class="small secondary" ${state.weapon ? "" : "disabled"} onclick="unequip('weapon')">Unequip</button>
    </div>
  `;
  $("armorSlot").innerHTML = `
    <strong>Armor</strong>
    <div class="itemName">${state.armor ? fmtItem(state.armor) : "None"}</div>
    <div class="row" style="justify-content:center">
      <button class="small secondary" ${state.armor ? "" : "disabled"} onclick="unequip('armor')">Unequip</button>
    </div>
  `;
  $("accessorySlot").innerHTML = `
    <strong>Accessory</strong>
    <div class="itemName">${state.accessory ? fmtItem(state.accessory) : "None"}</div>
    <div class="row" style="justify-content:center">
      <button class="small secondary" ${state.accessory ? "" : "disabled"} onclick="unequip('accessory')">Unequip</button>
    </div>
  `;

  $("rationCount").textContent = countItem("food");

  // bag
  renderBag();

  // log
  $("log").innerHTML = state.log.map(x=>`<div>${x}</div>`).join("");
  $("log").scrollTop = $("log").scrollHeight;

  // interact panel
  buildInteractOptions();

  // map draw
  resizeCanvases();
  $('miniWrap').style.display = showMinimap ? '' : 'none';
  drawMap();
  drawMinimap();

  save();
}

function renderSpellSlots(){
  const row = $("spellSlotsRow");
  row.innerHTML = "";
  if(!isCasterClass(state.char.class)) return;

  const slots = state.char.spellSlots || {};
  for(const lvl of [1,2,3,4,5]){
    const pill = document.createElement("span");
    pill.className = "badge";
    pill.textContent = `Slots Lv${lvl}: ${slots[lvl]||0}`;
    row.appendChild(pill);
  }
}

function renderBag(){
  const wrap = $("bag");
  wrap.innerHTML = "";

  if(!state.bag.length){
    wrap.innerHTML = `<div class="panel"><div class="muted">Backpack is empty.</div></div>`;
    return;
  }

  state.bag.forEach((it, idx)=>{
    const card = document.createElement("div");
    card.className = "itemCard";
    const isEquip = (it.type==="weapon"||it.type==="armor"||it.type==="accessory");
    const qty = it.type==="consumable" ? ` √ó ${it.qty||1}` : "";
    const meta = [
      it.type?.toUpperCase(),
      (it.atk?`+${it.atk} ATK`:""),
      (it.def?`+${it.def} DEF`:""),
      (it.weight!=null?`W ${it.weight}`:""),
      (it.tags?`Tags: ${it.tags.join(", ")}`:"")
    ].filter(Boolean).join(" ‚Ä¢ ");

    card.innerHTML = `
      <div>
        <b>${it.name}${qty}</b>
        <div class="meta">${meta || ""}</div>
      </div>
      <div class="row">
        ${isEquip ? `<button class="small" onclick="equipFromBag(${idx})">Equip</button>` : ``}
        ${it.type==="consumable" && it.kind==="food" ? `<button class="small secondary" onclick="eatFromBag(${idx})">Eat</button>` : ``}
        ${it.type==="consumable" && it.kind!=="food" ? `<button class="small secondary" onclick="useConsumableFromBag(${idx})">Use</button>` : ``}
        <button class="small secondary" onclick="dropFromBag(${idx})">Drop</button>
      </div>
    `;

    wrap.appendChild(card);
  });
}

/* =========================
   Bag actions (Eat / Use / Drop)
========================= */
window.eatFromBag = function(idx){
  const it = state.bag[idx];
  if(!it || it.type!=="consumable" || it.kind!=="food") return;

  // time + hunger + small energy bump
  passTime(10, "Eating");
  state.hunger = clamp(state.hunger - 18, 0, 100);
  state.energy = clamp(state.energy + 6, 0, state.energyMax);

  // consume qty
  it.qty = (it.qty || 1) - 1;
  if(it.qty <= 0) state.bag.splice(idx, 1);

  pushLog(`<span style="color:var(--good)">üçû You eat a ration. (-Hunger, +Energy)</span>`);
  render();
};

window.useConsumableFromBag = function(idx){
  const it = state.bag[idx];
  if(!it || it.type!=="consumable" || it.kind==="food") return;

  // generic consumable support (potion/scroll/etc.)
  // If you have custom kinds elsewhere, add cases here.
  if(it.kind==="potion"){
    closeModal?.();
    passTime(5, "Potion");
    const heal = 8 + roll(8);
    state.hp = clamp(state.hp + heal, 1, state.hpMax);
    pushLog(`<span style="color:var(--good)">üß™ You drink a potion (+${heal} HP).</span>`);
  } else if(it.kind==="bomb"){
    pushLog(`<span style="color:var(--warn)">üí£ You shouldn‚Äôt waste that outside combat.</span>`);
    render();
    return;
  } else {
    pushLog(`‚ú® You use <b>${it.name}</b>.`);
  }

  it.qty = (it.qty || 1) - 1;
  if(it.qty <= 0) state.bag.splice(idx, 1);
  render();
};

window.dropFromBag = function(idx){
  const it = state.bag[idx];
  if(!it) return;

  // dropping a stack drops 1 by default
  if(it.type==="consumable" && (it.qty || 1) > 1){
    it.qty -= 1;
    pushLog(`üóëÔ∏è Dropped 1 √ó <b>${it.name}</b>.`);
  } else {
    state.bag.splice(idx, 1);
    pushLog(`üóëÔ∏è Dropped <b>${it.name}</b>.`);
  }
  render();
};

/* =========================
   Interact panel enabling/disabling
   (keeps your buttons sensible by location/mode)
========================= */
function buildInteractOptions(){
  const n = nodeById[state.currentNode];

  // default enable by mode
  const inWorld = state.mode==="world";
  const inDungeon = state.mode==="dungeon";
  const inCombat = state.mode==="combat";

  // Basic buttons exist in your HTML
  const btn = (id)=>$(id);

  // combat: basically disable world actions
  if(inCombat){
    ["areaLootBtn","searchBtn","sleepBtn","eatBtn","visitBtn","questBoardBtn","buyFoodBtn","guideBtn"]
      .forEach(id=>{ if(btn(id)) btn(id).disabled = (id!=="guideBtn"); });
    return;
  }

  // dungeon: disable city services, keep basics
  if(inDungeon){
    if(btn("visitBtn")) btn("visitBtn").disabled = true;
    if(btn("questBoardBtn")) btn("questBoardBtn").disabled = true;
    if(btn("buyFoodBtn")) btn("buyFoodBtn").disabled = true;

    if(btn("areaLootBtn")) btn("areaLootBtn").disabled = false;
    if(btn("searchBtn")) btn("searchBtn").disabled = false;
    if(btn("sleepBtn")) btn("sleepBtn").disabled = false;
    if(btn("eatBtn")) btn("eatBtn").disabled = false;
    if(btn("guideBtn")) btn("guideBtn").disabled = false;
    return;
  }

  // world: location-dependent
  if(inWorld){
    const isSettlement = n && (n.type==="city" || n.type==="capital" || n.type==="town");
    const isBigCity = n && (n.type==="city" || n.type==="capital");

    if(btn("visitBtn")) btn("visitBtn").disabled = !isSettlement;
    if(btn("questBoardBtn")) btn("questBoardBtn").disabled = !isBigCity;
    if(btn("buyFoodBtn")) btn("buyFoodBtn").disabled = !isSettlement;

    if(btn("areaLootBtn")) btn("areaLootBtn").disabled = false;
    if(btn("searchBtn")) btn("searchBtn").disabled = false;
    if(btn("sleepBtn")) btn("sleepBtn").disabled = false;
    if(btn("eatBtn")) btn("eatBtn").disabled = false;
    if(btn("guideBtn")) btn("guideBtn").disabled = false;
  }
}
    pushLog(`<span style="color:var(--warn)">üï≥Ô∏è It was a trap ‚Äî bandits spring out!</span>`);
    state.pendingArrival = toId;
    startCombat(makeEnemy("bandits"), {origin:"road_shortcut"});
    render();
  } else {
    pushLog(`<span style="color:var(--good)">üß≠ The shortcut works! You arrive early at <b>${nodeById[toId].name}</b>.</span>`);
    enterNode(toId);
    render();
  }
};

/* =========================
   Frostspire (time sink)
========================= */
function frostspireTimeSink(fromSearch=false){
  const extra = fromSearch ? 25 : 60;
  passTime(extra, "Wandering Frostspire");
  pushLog(`<span style="color:var(--warn)">üßä Frostspire is a dead end. You find no entrance, only biting wind and wasted time.</span>`);
  // small chance of damage
  if(roll(100)<=18){
    const dmg = roll(4)+1;
    state.hp = clamp(state.hp - dmg, 0, state.hpMax);
    pushLog(`<span style="color:var(--bad)">‚ùÑÔ∏è The cold bites: -${dmg} HP.</span>`);
    if(state.hp<=0){ state.hp=1; pushLog(`<b style="color:var(--bad)">‚ò†Ô∏è You black out and wake at your last safe city.</b>`); enterNode(state.lastSafeNode); }
  }
  render();
}

/* =========================
   Guide
========================= */
function openGuide(){
  const n = nodeById[state.currentNode] || {};
  const cls = state.char.class;
  const caster = isCasterClass(cls) ? "Yes" : "No";
  const guideHtml = `
    <div class="panel">
      <b>Basics</b>
      <div class="muted" style="margin-top:6px">
        ‚Ä¢ World travel is <b>time-based</b> (distance + mount speed).<br>
        ‚Ä¢ Use <b>Area Loot</b> once per visit, and <b>Search/Explore</b> for extra finds.<br>
        ‚Ä¢ Hunger reaches 0 ‚áí HP drains while time passes.<br>
        ‚Ä¢ Carry weight matters: keep under your max (STR + mount).<br>
        ‚Ä¢ Big cities & capitals have <b>Banks</b> (daily interest) and <b>Property Offices</b> (income).<br>
      </div>
    </div>

    <div class="panel" style="margin-top:10px">
      <b>Controls</b>
      <div class="muted" style="margin-top:6px">
        ‚Ä¢ World: Click connected nodes to travel ‚Ä¢ Mouse wheel zoom ‚Ä¢ Drag to pan<br>
        ‚Ä¢ Dungeon: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> or arrows to move ‚Ä¢ Use Interact buttons for doors/chests/keys<br>
        ‚Ä¢ Combat: Use Attack / Spells / Items ‚Ä¢ Flee requires d20 ‚â• 11
      </div>
    </div>

    <div class="panel" style="margin-top:10px">
      <b>Combat</b>
      <div class="muted" style="margin-top:6px">
        ‚Ä¢ Attacks roll <b>d20</b> vs enemy AC. If hit, damage is <b>d6 + ATK</b> (plus buffs).<br>
        ‚Ä¢ Your AC = <b>10 + DEF</b>. Armor and DEX can increase DEF depending on armor type.<br>
        ‚Ä¢ War zone roads (Valoria ‚Üî Kragmire border) have more encounters.
      </div>
    </div>

    <div class="panel" style="margin-top:10px">
      <b>Your Current Info</b>
      <div class="muted" style="margin-top:6px">
        ‚Ä¢ Location: <b>${n.name||"‚Äî"}</b> ‚Ä¢ Kingdom: <b>${n.kingdom||"‚Äî"}</b> ‚Ä¢ Biome: <b>${n.biome||"‚Äî"}</b><br>
        ‚Ä¢ Class: <b>${cls}</b> ‚Ä¢ Caster: <b>${caster}</b> ‚Ä¢ Keys: <b>${state.keys}</b><br>
        ‚Ä¢ Carry: <b>${carryNow()}/${carryMax()}</b> ‚Ä¢ Mount: <b>${state.mount ? state.mount.name : "None"}</b>
      </div>
    </div>
  `;
  openModal("Guide", guideHtml);
}

/* =========================
   Generic Modal helpers
========================= */
function openModal(title, body){
  $("modalTitle").textContent = title || "Notice";
  // allow HTML
  $("modalBody").innerHTML = body || "";
  $("overlay").style.display = "flex";
}
function closeModal(){
  $("overlay").style.display = "none";
}
$("closeModal").addEventListener("click", closeModal);
$("overlay").addEventListener("click", (e)=>{ if(e.target.id==="overlay") closeModal(); });

/* =========================
   Character Creator
========================= */
function openCreator(){
  $("creatorOverlay").style.display="flex";
}
function closeCreator(){
  $("creatorOverlay").style.display="none";
}
function setCreatorLocked(locked){
  state.creatorLocked = locked;
  $("creatorLockTag").textContent = locked ? "Confirmed (Locked)" : "Unconfirmed";
  $("creatorLockTag").style.opacity = locked ? "1" : ".9";

  // lock fields
  ["ccName","ccSex","ccRace","ccClass","ccBirth","ccRollBtn","ccConfirmBtn"].forEach(id=>{
    const el = $(id);
    if(!el) return;
    if(id==="ccConfirmBtn") return;
    el.disabled = locked;
  });

  $("ccCloseHint").disabled = !locked;
}
$("ccCloseHint").addEventListener("click", ()=>{ if(state.creatorLocked) closeCreator(); });

function populateCreatorOptions(){
  // races
  $("ccRace").innerHTML = RACES.map(r=>`<option value="${r.name}">${r.name}</option>`).join("");
  // classes
  const classNames = Object.keys(CLASS_RULES);
  $("ccClass").innerHTML = classNames.map(c=>`<option value="${c}">${c}</option>`).join("");
  // birth
  $("ccBirth").innerHTML = KINGDOMS.map(k=>`<option value="${k.id}">${k.id}</option>`).join("");
}
populateCreatorOptions();

let ccRolled = null;

function roll4d6DropLowest(){
  const dice = [roll(6),roll(6),roll(6),roll(6)].sort((a,b)=>a-b);
  return dice[1]+dice[2]+dice[3];
}
function renderCcStats(){
  const box = $("ccStats");
  box.innerHTML = "";
  const stats = ["str","dex","con","int","wis","cha"];
  for(const key of stats){
    const val = ccRolled?.[key] ?? "‚Äî";
    const el = document.createElement("div");
    el.className = "statBox";
    el.innerHTML = `${key.toUpperCase()}<div style="margin-top:6px"><b>${val}</b></div>`;
    box.appendChild(el);
  }
}
function updateCcRulesText(){
  const cls = $("ccClass").value;
  $("ccClassRules").textContent = classRulesText(cls);
}
$("ccClass").addEventListener("change", updateCcRulesText);

$("ccRollBtn").addEventListener("click", ()=>{
  if(state.creatorLocked) return;
  ccRolled = {
    str: roll4d6DropLowest(),
    dex: roll4d6DropLowest(),
    con: roll4d6DropLowest(),
    int: roll4d6DropLowest(),
    wis: roll4d6DropLowest(),
    cha: roll4d6DropLowest()
  };
  renderCcStats();
});

function applyRaceBonus(raceName, rawStats){
  const r = RACES.find(x=>x.name===raceName);
  const b = r?.bonus || {};
  return {
    str: rawStats.str + (b.str||0),
    dex: rawStats.dex + (b.dex||0),
    con: rawStats.con + (b.con||0),
    int: rawStats.int + (b.int||0),
    wis: rawStats.wis + (b.wis||0),
    cha: rawStats.cha + (b.cha||0),
  };
}

function startingNodeForKingdom(kid){
  // IDs depend on slug() outputs from genNodes()
  if(kid==="Valoria") return slug("Aurelia (Capital)");
  if(kid==="Kragmire") return slug("Kragholm (Capital)");
  if(kid==="Eldwyn") return slug("Eldspire");
  if(kid==="SableCoast") return slug("Sablegate");
  return slug("Aurelia (Capital)");
}

$("ccConfirmBtn").addEventListener("click", ()=>{
  if(state.creatorLocked) return;

  const name = ($("ccName").value||"").trim();
  if(!name){
    openModal("Character Creator", "Please enter a name before confirming.");
    return;
  }
  if(!ccRolled){
    openModal("Character Creator", "You must roll stats before confirming.");
    return;
  }

  // commit
  state.char.name = name;
  state.char.sex = $("ccSex").value;
  state.char.race = $("ccRace").value;
  state.char.class = $("ccClass").value;
  state.char.birthKingdom = $("ccBirth").value;

  const finalStats = applyRaceBonus(state.char.race, ccRolled);
  Object.assign(state.char, finalStats);

  // base stats from class
  const base = CLASS_RULES[state.char.class]?.base || {atk:2,def:1,hpMax:20};
  state.atkBase = base.atk;
  state.defBase = base.def;
  state.hpMax = base.hpMax;
  state.hp = base.hpMax;

  // energy/hunger baseline
  state.energyMax = 10;
  state.energy = 10;
  state.hungerMax = 10;
  state.hunger = 10;

  // learn spells + slots
  learnStartingSpells();

  state.characterCreated = true;
  setCreatorLocked(true);

  // start location
  const startId = startingNodeForKingdom(state.char.birthKingdom);
  state.currentNode = startId;
  state.lastSafeNode = startId;

  pushLog(`<span style="color:var(--good)">‚úÖ Character confirmed: <b>${state.char.name}</b> (${state.char.race} ${state.char.class})</span>`);
  pushLog(`üß≠ Starting in <b>${nodeById[startId]?.name || "your homeland"}</b>.`);

  save();
  render();
});

/* =========================
   UI Wiring
========================= */
$("areaLootBtn").addEventListener("click", useAreaLoot);
$("searchBtn").addEventListener("click", searchExplore);
$("sleepBtn").addEventListener("click", sleep);
$("eatBtn").addEventListener("click", eat);
$("visitBtn").addEventListener("click", openVisit);
$("questBoardBtn").addEventListener("click", openQuestBoard);
$("guideBtn").addEventListener("click", openGuide);
$("buyFoodBtn").addEventListener("click", buyRation);
$("resetBtn").addEventListener("click", ()=>{
  openModal("Reset Save", `
    <div class="panel">
      This will erase your current save and restart the game.
      <div class="row" style="margin-top:10px">
        <button onclick="confirmReset()">Yes, reset</button>
        <button class="secondary" onclick="closeModal()">Cancel</button>
      </div>
    </div>
  `);
});
window.confirmReset = function(){
  localStorage.removeItem(SAVE_KEY);
  state = defaultState();
  ccRolled = null;
  closeModal();
  initAfterLoad(true);
  render();
};

/* =========================
   Rendering: character, inventory, spells, log
========================= */
function renderEquipmentSlots(){
  $("weaponSlot").innerHTML = `
    <strong>Weapon</strong>
    <div class="itemName">${state.weapon ? fmtItem(state.weapon) : "None"}</div>
    <div class="row" style="justify-content:center">
      ${state.weapon ? `<button class="small secondary" onclick="unequip('weapon')">Unequip</button>` : `<span class="smallMuted">‚Äî</span>`}
    </div>
  `;
  $("armorSlot").innerHTML = `
    <strong>Armor</strong>
    <div class="itemName">${state.armor ? fmtItem(state.armor) : "None"}</div>
    <div class="row" style="justify-content:center">
      ${state.armor ? `<button class="small secondary" onclick="unequip('armor')">Unequip</button>` : `<span class="smallMuted">‚Äî</span>`}
    </div>
  `;
  $("accessorySlot").innerHTML = `
    <strong>Accessory</strong>
    <div class="itemName">${state.accessory ? fmtItem(state.accessory) : "None"}</div>
    <div class="row" style="justify-content:center">
      ${state.accessory ? `<button class="small secondary" onclick="unequip('accessory')">Unequip</button>` : `<span class="smallMuted">‚Äî</span>`}
    </div>
  `;
  $("rationCount").textContent = String(countItem("food"));
}

function renderBag(){
  const bag = $("bag");
  bag.innerHTML = "";
  if(!state.bag.length){
    bag.innerHTML = `<div class="panel"><div class="muted">Backpack is empty.</div></div>`;
    return;
  }
  state.bag.forEach((item, idx)=>{
    const card = document.createElement("div");
    card.className = "itemCard";
    const meta = [];
    if(item.type==="weapon" && item.atk) meta.push(`+${item.atk} ATK`);
    if(item.type==="armor" && item.def) meta.push(`+${item.def} DEF`);
    if(item.type==="consumable") meta.push(`Qty ${item.qty||1}`);
    if(item.type==="quest") meta.push(`Quest item`);
    meta.push(`Wt ${item.type==="consumable" ? ((item.weight||0)*(item.qty||1)).toFixed(1) : (item.weight||0)}`);

    let actions = "";
    if(item.type==="weapon"||item.type==="armor"||item.type==="accessory"){
      actions = `<button class="small" onclick="equipFromBag(${idx})">Equip</button>`;
    } else {
      actions = `<button class="small secondary" disabled>‚Äî</button>`;
    }

    card.innerHTML = `
      <div>
        <div style="font-weight:800">${item.name}</div>
        <div class="meta">${meta.join(" ‚Ä¢ ")}</div>
      </div>
      <div class="row">${actions}</div>
    `;
    bag.appendChild(card);
  });
}

function renderSpellsPanel(){
  const known = state.char.spellsKnown || [];
  const caster = isCasterClass(state.char.class);
  if(!caster){
    $("spellInfo").textContent = "No spells (non-caster class).";
    $("spellSlotsRow").innerHTML = "";
    return;
  }
  const slots = state.char.spellSlots || {1:0,2:0,3:0,4:0,5:0};
  const slotLine = Object.keys(slots).map(l=>`Lv${l}:${slots[l]}`).join(" ‚Ä¢ ");
  $("spellInfo").textContent = `Known: ${known.length ? known.join(", ") : "None"} ‚Ä¢ Slots: ${slotLine || "‚Äî"}`;

  const row = $("spellSlotsRow");
  row.innerHTML = "";
  for(const lvl of [1,2,3,4,5]){
    const b = document.createElement("span");
    b.className = "badge";
    b.textContent = `Lv ${lvl} Slots: ${slots[lvl]||0}`;
    row.appendChild(b);
  }
}

function renderLog(){
  $("log").innerHTML = state.log.map(x=>`<div>${x}</div>`).join("");
  $("log").scrollTop = $("log").scrollHeight;
}

/* =========================
   Canvas: World + Dungeon rendering, pan/zoom, minimap, tooltip
========================= */
let view = { x: 0, y: 0, zoom: 0.05, minZoom: 0.012, maxZoom: 0.22, dragging:false, lastX:0, lastY:0 };


let terrainTex = null;
let kingdomTex = null;
let borderTex = null;
var mapTexDirty = true;


let showRouteCosts = false;  // toggleable labels on routes
let showRegions = true;      // kingdom tint + border overlay
let showMinimap = true;      // minimap visibility
let paperTex = null;         // painterly paper grain tile


function buildMapTextures(){
  if(!mapTexDirty && terrainTex && kingdomTex && borderTex) return;

  const TW = 1400; // texture resolution (higher = smoother)
  const TH = Math.round(TW * (WORLD_H / WORLD_W));

  function makeCanvas(){
    const c = document.createElement("canvas");
    c.width = TW; c.height = TH;
    return c;
  }
  if(!terrainTex) terrainTex = makeCanvas();
  if(!kingdomTex) kingdomTex = makeCanvas();
  if(!borderTex)  borderTex  = makeCanvas();

  // --- Terrain ---
  const tctx = terrainTex.getContext("2d", {alpha:false});
  const img = tctx.createImageData(TW, TH);
  const data = img.data;

  for(let py=0; py<TH; py++){
    const wy = (py/(TH-1)) * WORLD_H;
    for(let px=0; px<TW; px++){
      const wx = (px/(TW-1)) * WORLD_W;

      const land = isLand(wx,wy);
      const elev = fbm(wx,wy, 7200); // [-1..1]
      let r=0,g=0,b=0;

      if(!land){
        const deep = SEA_COLORS.deep, sh = SEA_COLORS.shallow;
        const t = clamp((wy / WORLD_H), 0, 1);
        r = Math.round(deep[0]*(1-t) + sh[0]*t);
        g = Math.round(deep[1]*(1-t) + sh[1]*t);
        b = Math.round(deep[2]*(1-t) + sh[2]*t);
        const wav = fbm(wx+2200, wy-1300, 5200);
        r = clamp(r + Math.round(wav*10),0,255);
        g = clamp(g + Math.round(wav*8),0,255);
        b = clamp(b + Math.round(wav*16),0,255);
      } else {
        // biome base
        const biome = biomeAt(wx,wy);
        const rgb = BIOME_COLORS[biome] || BIOME_COLORS.grasslands;
        r=rgb[0]; g=rgb[1]; b=rgb[2];

        // coast/beach hint
        const coast = (!isLand(wx+140,wy) || !isLand(wx-140,wy) || !isLand(wx,wy+140) || !isLand(wx,wy-140));
        if(coast){
          r = Math.round(r*0.70 + 210*0.30);
          g = Math.round(g*0.75 + 198*0.25);
          b = Math.round(b*0.78 + 150*0.22);
        }

        // elevation shading + mountains
        const shade = elev*22 + fbm(wx+9000,wy+2000, 2600)*10;
        r = clamp(r + Math.round(shade), 0, 255);
        g = clamp(g + Math.round(shade), 0, 255);
        b = clamp(b + Math.round(shade), 0, 255);

        // mountain/snowcaps
        if(elev > 0.58 && !coast){
          // rocky
          r = Math.round(r*0.55 + 140*0.45);
          g = Math.round(g*0.55 + 140*0.45);
          b = Math.round(b*0.55 + 150*0.45);
        }
        if(elev > 0.82 || (biome==="snow"||biome==="arctic")){
          // snow
          r = Math.round(r*0.35 + 230*0.65);
          g = Math.round(g*0.35 + 240*0.65);
          b = Math.round(b*0.35 + 250*0.65);
        }
      }

      const idx = (py*TW + px)*4;
      data[idx]=r; data[idx+1]=g; data[idx+2]=b; data[idx+3]=255;
    }
  }
  tctx.putImageData(img,0,0);

  // Painterly finish: subtle paper grain + vignette (fast, tiled)
  if(!paperTex){
    paperTex = document.createElement("canvas");
    paperTex.width = 256; paperTex.height = 256;
    const pctx = paperTex.getContext("2d");
    const pimg = pctx.createImageData(256,256);
    const pd = pimg.data;
    for(let i=0;i<pd.length;i+=4){
      const v = 200 + Math.floor(Math.random()*55); // light grain
      pd[i]=v; pd[i+1]=v; pd[i+2]=v;
      pd[i+3]=Math.floor(18 + Math.random()*38); // alpha
    }
    pctx.putImageData(pimg,0,0);
  }
  tctx.save();
  tctx.globalAlpha = 0.12;
  for(let y=0; y<TH; y+=paperTex.height){
    for(let x=0; x<TW; x+=paperTex.width){
      tctx.drawImage(paperTex, x, y);
    }
  }
  const vg = tctx.createRadialGradient(TW*0.5, TH*0.5, Math.min(TW,TH)*0.20, TW*0.5, TH*0.5, Math.max(TW,TH)*0.80);
  vg.addColorStop(0, "rgba(0,0,0,0)");
  vg.addColorStop(1, "rgba(0,0,0,0.28)");
  tctx.fillStyle = vg;
  tctx.fillRect(0,0,TW,TH);
  tctx.restore();


  // --- Kingdom overlay + borders ---
  const kctx = kingdomTex.getContext("2d", {alpha:true});
  const bctx = borderTex.getContext("2d", {alpha:true});
  const kimg = kctx.createImageData(TW, TH);
  const bimg = bctx.createImageData(TW, TH);
  const kd = kimg.data;
  const bd = bimg.data;
  const owner = new Uint8Array(TW*TH);

  const KLIST = ["Valoria","Kragmire","Eldwyn","SableCoast"];
  const tintRGBA = {
    Valoria:[124,92,255, 42],
    Kragmire:[251,113,133, 40],
    Eldwyn:[52,211,153, 36],
    SableCoast:[59,130,246, 38],
  };

  for(let py=0; py<TH; py++){
    const wy = (py/(TH-1)) * WORLD_H;
    for(let px=0; px<TW; px++){
      const wx = (px/(TW-1)) * WORLD_W;
      const idx = (py*TW + px);

      if(!isLand(wx,wy)){
        owner[idx]=255;
        continue;
      }
      const k = kingdomAt(wx,wy) || "Eldwyn";
      const ki = KLIST.indexOf(k);
      owner[idx] = (ki<0?2:ki);
      const rgba = tintRGBA[k] || [255,255,255,20];

      const i4 = idx*4;
      kd[i4]   = rgba[0];
      kd[i4+1] = rgba[1];
      kd[i4+2] = rgba[2];
      kd[i4+3] = rgba[3];
    }
  }

  // borders: detect changes in owner
  for(let py=1; py<TH-1; py++){
    for(let px=1; px<TW-1; px++){
      const idx = py*TW + px;
      const o = owner[idx];
      if(o===255) continue;

      const oR = owner[idx+1], oD = owner[idx+TW], oL=owner[idx-1], oU=owner[idx-TW];
      const border = (oR!==o && oR!==255) || (oD!==o && oD!==255) || (oL!==o && oL!==255) || (oU!==o && oU!==255);
      if(border){
        const i4 = idx*4;
        bd[i4]   = 10;
        bd[i4+1] = 10;
        bd[i4+2] = 14;
        bd[i4+3] = 95;
      }
    }
  }
  kctx.putImageData(kimg,0,0);
  bctx.putImageData(bimg,0,0);

  mapTexDirty = false;
}


function resizeCanvases(){
  const wrap = $("mapWrap");
  const rect = wrap.getBoundingClientRect();
  mapCanvas.width  = Math.floor(rect.width * devicePixelRatio);
  mapCanvas.height = Math.floor(rect.height * devicePixelRatio);

  const miniWrap = $("miniWrap");
  const mrect = miniWrap.getBoundingClientRect();
  miniCanvas.width  = Math.floor(mrect.width * devicePixelRatio);
  miniCanvas.height = Math.floor(mrect.height * devicePixelRatio);

  // dynamic zoom bounds (pixels per world unit)
  const fit = Math.min(mapCanvas.width / WORLD_W, mapCanvas.height / WORLD_H);
  view.minZoom = Math.max(0.003, fit * 0.18);   // ~5.5x zoomed-out from fit
  view.maxZoom = Math.min(0.65,  fit * 7.0);    // strong zoom-in
  if(!Number.isFinite(view.zoom) || view.zoom<=0) view.zoom = fit * 0.9;
  view.zoom = clamp(view.zoom, view.minZoom, view.maxZoom);
}
window.addEventListener("resize", ()=>{ resizeCanvases(); draw(); });

function worldToScreen(wx, wy){
  // view.x/view.y are the world-space center of the camera
  const sx = (wx - view.x) * view.zoom + (mapCanvas.width/2);
  const sy = (wy - view.y) * view.zoom + (mapCanvas.height/2);
  return {sx, sy};
}
function screenToWorld(sx, sy){
  const wx = ((sx - (mapCanvas.width/2)) / view.zoom) + view.x;
  const wy = ((sy - (mapCanvas.height/2)) / view.zoom) + view.y;
  return {wx, wy};
}


function hash2i(ix, iy){
  // deterministic 2D hash -> [0,1)
  let n = (ix|0) * 374761393 + (iy|0) * 668265263;
  n = (n ^ (n >> 13)) >>> 0;
  n = Math.imul(n, 1274126177) >>> 0;
  n = (n ^ (n >> 16)) >>> 0;
  return (n >>> 0) / 4294967296;
}


function lerp(a,b,t){ return a + (b-a)*t; }
function smoothstep(t){ return t*t*(3-2*t); }

// Value-noise + FBM for smoother terrain/region edges
function noise2(x,y, scale){
  const fx = x/scale, fy = y/scale;
  const ix = Math.floor(fx), iy = Math.floor(fy);
  const tx = fx - ix, ty = fy - iy;
  const a = hash2i(ix,iy);
  const b = hash2i(ix+1,iy);
  const c = hash2i(ix,iy+1);
  const d = hash2i(ix+1,iy+1);
  const u = smoothstep(tx), v = smoothstep(ty);
  return lerp(lerp(a,b,u), lerp(c,d,u), v); // [0..1]
}
function fbm(x,y, baseScale){
  let val = 0;
  let amp = 0.58;
  let scale = baseScale;
  for(let i=0;i<5;i++){
    val += (noise2(x,y, scale)-0.5)*2*amp;
    amp *= 0.55;
    scale *= 0.52;
  }
  return clamp(val, -1.25, 1.25);
}

function shadeColor(r,g,b, amt){
  // amt in [-1..1], adjusts brightness
  const f = (x)=>clamp(Math.round(x + (amt*50)), 0, 255);
  return `rgb(${f(r)},${f(g)},${f(b)})`;
}
const BIOME_COLORS = {
  grasslands:[28,129,76],
  woodland:[18,96,58],
  desert:[196,164,84],
  tundra:[104,130,140],
  arctic:[180,210,235],
  snow:[210,223,235]
};
const SEA_COLORS = {deep:[17,42,110], shallow:[24,72,160]};
const KINGDOM_TINT = {
  Valoria:"rgba(124,92,255,.18)",
  Kragmire:"rgba(251,113,133,.16)",
  Eldwyn:"rgba(52,211,153,.14)",
  SableCoast:"rgba(59,130,246,.14)"
};

function centerOnNode(nodeId){
  const n = nodeById[nodeId];
  if(!n) return;
  view.x = n.x;
  view.y = n.y;
}

function prettyType(t){
  const map = {
    capital:"Capital",
    city:"City",
    town:"Town",
    port:"Port",
    camp:"Camp",
    cave:"Cave",
    forest:"Forest",
    castle:"Castle",
    ruins:"Ruins",
    landmark:"Landmark"
  };
  return map[t] || (t ? (t.charAt(0).toUpperCase()+t.slice(1)) : "Unknown");
}

function nodeFillByKingdom(k){
  return (k==="Valoria") ? "rgba(124,92,255,.92)" :
         (k==="Kragmire")? "rgba(251,113,133,.92)" :
         (k==="Eldwyn") ? "rgba(52,211,153,.92)" :
         "rgba(59,130,246,.92)";
}

function drawNodeGlyph(n, sx, sy, isHere){
  const base = (n.type==="capital") ? 11 :
               (n.type==="city") ? 9 :
               (n.type==="castle") ? 9 :
               (n.type==="ruins") ? 8 :
               (n.type==="port") ? 8 :
               (n.type==="town") ? 7 :
               (n.type==="cave") ? 7 :
               (n.type==="forest") ? 7 :
               (n.type==="camp") ? 6 :
               (n.type==="landmark") ? 12 : 6;

  const r = base * devicePixelRatio;
  const fill = isHere ? "rgba(251,191,36,.98)" : nodeFillByKingdom(n.kingdom);
  const stroke = isHere ? "rgba(251,191,36,.98)" : "rgba(255,255,255,.26)";

  ctx.save();
  ctx.translate(sx,sy);
  ctx.shadowColor = isHere ? "rgba(255,255,180,.9)" : "rgba(0,0,0,0)";
  ctx.shadowBlur = isHere ? 18*devicePixelRatio : 0;

  ctx.fillStyle = fill;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2*devicePixelRatio;

  function pathCircle(){
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
  }
  function pathSquare(){
    ctx.beginPath();
    ctx.rect(-r, -r, r*2, r*2);
  }
  function pathDiamond(){
    ctx.beginPath();
    ctx.moveTo(0,-r);
    ctx.lineTo(r,0);
    ctx.lineTo(0,r);
    ctx.lineTo(-r,0);
    ctx.closePath();
  }
  function pathTri(up=true){
    ctx.beginPath();
    if(up){
      ctx.moveTo(0,-r);
      ctx.lineTo(r, r);
      ctx.lineTo(-r, r);
    } else {
      ctx.moveTo(0,r);
      ctx.lineTo(r, -r);
      ctx.lineTo(-r, -r);
    }
    ctx.closePath();
  }
  function pathHex(){
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const a = (Math.PI/3)*i + Math.PI/6;
      const x = Math.cos(a)*r;
      const y = Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
  }
  function pathCastle(){
    // simple battlement icon
    const w = r*2.1, h = r*1.8;
    const x0 = -w/2, y0 = -h/2;
    ctx.beginPath();
    ctx.moveTo(x0, y0+h*0.3);
    // battlements
    const steps=4;
    for(let i=0;i<steps;i++){
      const x = x0 + (w/steps)*i;
      ctx.lineTo(x, y0+h*0.3);
      ctx.lineTo(x, y0);
      ctx.lineTo(x + (w/steps)*0.5, y0);
      ctx.lineTo(x + (w/steps)*0.5, y0+h*0.3);
    }
    ctx.lineTo(x0+w, y0+h*0.3);
    ctx.lineTo(x0+w, y0+h);
    ctx.lineTo(x0, y0+h);
    ctx.closePath();
  }

  // draw main shape
  if(n.type==="city") pathSquare();
  else if(n.type==="camp") pathTri(true);
  else if(n.type==="cave") pathTri(false);
  else if(n.type==="forest") pathHex();
  else if(n.type==="ruins") pathDiamond();
  else if(n.type==="castle") pathCastle();
  else pathCircle();

  ctx.fill();
  ctx.stroke();

  // extra marks
  ctx.shadowBlur = 0;
  if(n.type==="port"){
    // tiny anchor-like mark
    ctx.beginPath();
    ctx.arc(0,0,r*0.25,0,Math.PI*2);
    ctx.moveTo(0,-r*0.6); ctx.lineTo(0, r*0.55);
    ctx.moveTo(-r*0.35, r*0.25); ctx.lineTo(0, r*0.55); ctx.lineTo(r*0.35, r*0.25);
    ctx.strokeStyle="rgba(0,0,0,.28)";
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.stroke();
  }
  if(n.type==="capital"){
    // small star sparkle
    ctx.beginPath();
    const s = r*0.55;
    for(let i=0;i<5;i++){
      const a = (Math.PI*2/5)*i - Math.PI/2;
      const x = Math.cos(a)*s;
      const y = Math.sin(a)*s;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      const a2 = a + Math.PI/5;
      ctx.lineTo(Math.cos(a2)*s*0.45, Math.sin(a2)*s*0.45);
    }
    ctx.closePath();
    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.fill();
  }

  ctx.restore();
}


function pathRoundRect(ctx,x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.lineTo(x+w-rr, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
  ctx.lineTo(x+w, y+h-rr);
  ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
  ctx.lineTo(x+rr, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
  ctx.lineTo(x, y+rr);
  ctx.quadraticCurveTo(x, y, x+rr, y);
  ctx.closePath();
}


function drawWorld(){
  buildMapTextures();

  ctx.clearRect(0,0,mapCanvas.width,mapCanvas.height);

  // draw textures (terrain + kingdom tint + borders)
  const tl = worldToScreen(0,0);
  const wpx = WORLD_W * view.zoom;
  const hpx = WORLD_H * view.zoom;

  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(terrainTex, tl.sx, tl.sy, wpx, hpx);
  if(showRegions){
    ctx.drawImage(kingdomTex, tl.sx, tl.sy, wpx, hpx);
    ctx.drawImage(borderTex,  tl.sx, tl.sy, wpx, hpx);
  }
  ctx.restore();

  // --- Routes ---
  ctx.lineWidth = Math.max(1, 2*devicePixelRatio);
  for(const e of world.edges){
    const a=nodeById[e.a], b=nodeById[e.b];
    if(!a||!b) continue;
    const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);

    // quick reject offscreen
    if((A.sx< -240 && B.sx< -240) || (A.sx>mapCanvas.width+240 && B.sx>mapCanvas.width+240)) continue;
    if((A.sy< -240 && B.sy< -240) || (A.sy>mapCanvas.height+240 && B.sy>mapCanvas.height+240)) continue;

    ctx.beginPath();
    const mx = (A.sx+B.sx)/2;
    const my = (A.sy+B.sy)/2;
    const bend = e.kind==="sea" ? 0.14 : 0.09;
    const cx = mx + (B.sy-A.sy)*bend;
    const cy = my + (A.sx-B.sx)*bend;
    ctx.moveTo(A.sx,A.sy);
    ctx.quadraticCurveTo(cx,cy,B.sx,B.sy);

    if(e.kind==="sea"){
      ctx.strokeStyle = "rgba(59,130,246,.55)";
      ctx.setLineDash([10*devicePixelRatio, 10*devicePixelRatio]);
    } else {
      ctx.setLineDash([]);
      ctx.strokeStyle = e.war ? "rgba(251,113,133,.55)" : "rgba(255,255,255,.22)";
    }
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // Optional route gold labels
  const showCostNow = showRouteCosts && view.zoom > (view.minZoom*1.12);
  if(showCostNow){
    ctx.save();
    ctx.setLineDash([]);
    ctx.font = `${Math.round(11*devicePixelRatio)}px system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for(const e of world.edges){
      const a=nodeById[e.a], b=nodeById[e.b];
      if(!a||!b) continue;

      const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
      // offscreen reject
      if((A.sx< -260 && B.sx< -260) || (A.sx>mapCanvas.width+260 && B.sx>mapCanvas.width+260)) continue;
      if((A.sy< -260 && B.sy< -260) || (A.sy>mapCanvas.height+260 && B.sy>mapCanvas.height+260)) continue;

      const mx = (A.sx+B.sx)/2;
      const my = (A.sy+B.sy)/2;
      const bend = e.kind==="sea" ? 0.14 : 0.09;
      const cx = mx + (B.sy-A.sy)*bend;
      const cy = my + (A.sx-B.sx)*bend;

      // quadratic midpoint (t=0.5)
      const t = 0.5;
      const qx = (1-t)*(1-t)*A.sx + 2*(1-t)*t*cx + t*t*B.sx;
      const qy = (1-t)*(1-t)*A.sy + 2*(1-t)*t*cy + t*t*B.sy;

      const cost = (e.cost||e.fare||0);
      if(!cost) continue;

      const label = `${cost}g`;
      const padX = 8*devicePixelRatio, padY = 4*devicePixelRatio;
      const tw = ctx.measureText(label).width;
      const w = tw + padX*2;
      const h = (12*devicePixelRatio) + padY*2;

      ctx.globalAlpha = 0.95;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      pathRoundRect(ctx, qx - w/2, qy - h/2, w, h, 8*devicePixelRatio);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,.16)";
      ctx.lineWidth = Math.max(1, 1*devicePixelRatio);
      ctx.stroke();

      ctx.fillStyle = e.kind==="sea" ? "rgba(147,197,253,.92)" : (e.war ? "rgba(251,113,133,.95)" : "rgba(229,231,235,.92)");
      ctx.fillText(label, qx, qy + 0.5*devicePixelRatio);
    }
    ctx.restore();
  }


  // --- Nodes ---
  const showLabels = view.zoom > (Math.min(mapCanvas.width/WORLD_W, mapCanvas.height/WORLD_H) * 1.05);
  for(const n of world.nodes){
    const {sx,sy} = worldToScreen(n.x,n.y);
    if(sx< -80 || sy< -80 || sx>mapCanvas.width+80 || sy>mapCanvas.height+80) continue;

    const isHere = (n.id===state.currentNode) && state.mode!=="dungeon";
    drawNodeGlyph(n, sx, sy, isHere);

    if(showLabels && (n.type==="capital" || n.type==="city" || n.type==="castle")){
      ctx.font = `${Math.round(12*devicePixelRatio)}px system-ui`;
      ctx.fillStyle = "rgba(229,231,235,.84)";
      ctx.fillText(n.name.split(" ")[0], sx+11*devicePixelRatio, sy-9*devicePixelRatio);
    }
  }

  drawMinimapWorld();
}

function drawDungeon(){
  const d = currentDungeon();
  ctx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
  if(!d){
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(0,0,mapCanvas.width,mapCanvas.height);
    return;
  }

  const cell = Math.floor(Math.min(mapCanvas.width/(d.w+2), mapCanvas.height/(d.h+2)));
  const ox = Math.floor((mapCanvas.width - cell*d.w)/2);
  const oy = Math.floor((mapCanvas.height - cell*d.h)/2);

  // tiles
  for(let y=0;y<d.h;y++){
    for(let x=0;x<d.w;x++){
      const seen = d.seen[y][x];
      const t = d.tiles[y][x];
      let fill = "rgba(0,0,0,.40)";
      if(seen){
        if(t==="wall") fill="rgba(255,255,255,.06)";
        else fill="rgba(0,0,0,.20)";
        if(t==="entrance") fill="rgba(52,211,153,.18)";
        if(t==="exit") fill="rgba(59,130,246,.18)";
        if(t==="chest"||t==="chestLocked") fill="rgba(251,191,36,.16)";
        if(t==="doorLocked") fill="rgba(251,113,133,.16)";
        if(t==="key") fill="rgba(124,92,255,.16)";
      }
      ctx.fillStyle = fill;
      ctx.fillRect(ox+x*cell, oy+y*cell, cell-1, cell-1);
    }
  }

  // enemies (if seen)
  for(const e of d.enemies){
    if(!d.seen[e.y][e.x]) continue;
    ctx.fillStyle="rgba(251,113,133,.85)";
    ctx.fillRect(ox+e.x*cell+cell*0.25, oy+e.y*cell+cell*0.25, cell*0.5, cell*0.5);
  }

  // player
  ctx.fillStyle="rgba(251,191,36,.95)";
  ctx.beginPath();
  ctx.arc(ox+d.px*cell+cell/2, oy+d.py*cell+cell/2, Math.max(3, cell*0.28), 0, Math.PI*2);
  ctx.fill();

  // minimap off in dungeon
  drawMinimapDungeon(d);
}

function drawMinimapWorld(){
  if(!showMinimap) return;
  buildMapTextures();

  mctx.clearRect(0,0,miniCanvas.width,miniCanvas.height);

  // base textures
  mctx.save();
  mctx.imageSmoothingEnabled = true;
  mctx.drawImage(terrainTex, 0,0, miniCanvas.width, miniCanvas.height);
  mctx.drawImage(kingdomTex, 0,0, miniCanvas.width, miniCanvas.height);
  mctx.drawImage(borderTex,  0,0, miniCanvas.width, miniCanvas.height);
  mctx.restore();

  // routes (very light)
  mctx.lineWidth = Math.max(1, 1*devicePixelRatio);
  for(const e of world.edges){
    const a=nodeById[e.a], b=nodeById[e.b];
    if(!a||!b) continue;
    const ax = (a.x/WORLD_W)*miniCanvas.width;
    const ay = (a.y/WORLD_H)*miniCanvas.height;
    const bx = (b.x/WORLD_W)*miniCanvas.width;
    const by = (b.y/WORLD_H)*miniCanvas.height;

    mctx.beginPath();
    mctx.moveTo(ax,ay);
    mctx.lineTo(bx,by);
    mctx.strokeStyle = (e.kind==="sea") ? "rgba(59,130,246,.35)" : (e.war ? "rgba(251,113,133,.25)" : "rgba(255,255,255,.15)");
    if(e.kind==="sea") mctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]); else mctx.setLineDash([]);
    mctx.stroke();
  }
  mctx.setLineDash([]);

  // nodes
  for(const n of world.nodes){
    const x = (n.x/WORLD_W)*miniCanvas.width;
    const y = (n.y/WORLD_H)*miniCanvas.height;
    const isHere = (n.id===state.currentNode) && state.mode!=="dungeon";
    mctx.fillStyle = isHere ? "rgba(251,191,36,.98)" : nodeFillByKingdom(n.kingdom);
    mctx.beginPath();
    mctx.arc(x,y, (isHere?3.4:2.4)*devicePixelRatio, 0, Math.PI*2);
    mctx.fill();
  }

  // viewport rectangle
  const vx = ((view.x - (mapCanvas.width/2)/view.zoom)/WORLD_W)*miniCanvas.width;
  const vy = ((view.y - (mapCanvas.height/2)/view.zoom)/WORLD_H)*miniCanvas.height;
  const vw = (mapCanvas.width/view.zoom)/WORLD_W*miniCanvas.width;
  const vh = (mapCanvas.height/view.zoom)/WORLD_H*miniCanvas.height;

  mctx.strokeStyle="rgba(255,255,255,.55)";
  mctx.lineWidth = 2*devicePixelRatio;
  mctx.strokeRect(vx,vy,vw,vh);
}

function drawMinimapDungeon(d){
  mctx.clearRect(0,0,miniCanvas.width,miniCanvas.height);
  mctx.fillStyle="rgba(0,0,0,.25)";
  mctx.fillRect(0,0,miniCanvas.width,miniCanvas.height);

  const sx = miniCanvas.width/d.w;
  const sy = miniCanvas.height/d.h;

  for(let y=0;y<d.h;y++){
    for(let x=0;x<d.w;x++){
      if(!d.seen[y][x]) continue;
      const t = d.tiles[y][x];
      let c="rgba(255,255,255,.10)";
      if(t==="wall") c="rgba(255,255,255,.05)";
      if(t==="exit") c="rgba(59,130,246,.20)";
      if(t==="entrance") c="rgba(52,211,153,.20)";
      mctx.fillStyle=c;
      mctx.fillRect(x*sx,y*sy,sx,sy);
    }
  }
  mctx.fillStyle="rgba(251,191,36,.95)";
  mctx.fillRect(d.px*sx, d.py*sy, sx, sy);
}

function draw(){
  if(state.mode==="dungeon") drawDungeon();
  else drawWorld();
}

function getHoveredNode(wx, wy){
  // find nearest within a screen-pixel threshold (converted to world units)
  const thresholdWorld = (18*devicePixelRatio) / view.zoom; // ~18px
  let best=null, bd=Infinity;
  for(const n of world.nodes){
    const dx=n.x-wx, dy=n.y-wy;
    const d = Math.sqrt(dx*dx+dy*dy);
    if(d < bd){ bd=d; best=n; }
  }
  if(best && bd <= thresholdWorld) return best;
  return null;
}

/* Map interactions */
$("mapWrap").addEventListener("wheel", (e)=>{
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  const factor = delta>0 ? 0.90 : 1.12;

  const rect = $("mapWrap").getBoundingClientRect();
  const sx = (e.clientX - rect.left) * devicePixelRatio;
  const sy = (e.clientY - rect.top)  * devicePixelRatio;

  const before = screenToWorld(sx,sy);
  view.zoom = clamp(view.zoom * factor, view.minZoom, view.maxZoom);
  const after = screenToWorld(sx,sy);

  // keep point under cursor stable
  view.x += (before.wx - after.wx);
  view.y += (before.wy - after.wy);

  draw();
},{passive:false});

$("mapWrap").addEventListener("mousedown", (e)=>{
  view.dragging=true;
  view.lastX = e.clientX;
  view.lastY = e.clientY;
});
window.addEventListener("mouseup", ()=>{ view.dragging=false; });
window.addEventListener("mousemove", (e)=>{
  const rect = $("mapWrap").getBoundingClientRect();
  const inside = e.clientX>=rect.left && e.clientX<=rect.right && e.clientY>=rect.top && e.clientY<=rect.bottom;

  if(view.dragging){
    const dx = (e.clientX - view.lastX);
    const dy = (e.clientY - view.lastY);
    view.lastX = e.clientX;
    view.lastY = e.clientY;
    // convert pixels to world delta
    view.x -= (dx*devicePixelRatio) / view.zoom;
    view.y -= (dy*devicePixelRatio) / view.zoom;
    draw();
    return;
  }

  // tooltip
  const tip = $("tooltip");
  if(!inside || state.mode==="dungeon"){
    tip.style.display="none";
    return;
  }
  const sx = (e.clientX - rect.left) * devicePixelRatio;
  const sy = (e.clientY - rect.top)  * devicePixelRatio;
  const w = screenToWorld(sx,sy);
  const n = getHoveredNode(w.wx, w.wy);
  if(!n){
    tip.style.display="none";
    return;
  }

  const nb = neighbors(n.id).length;
  const here = (n.id===state.currentNode);
  const connected = edgeBetween(state.currentNode, n.id);
  const tt = connected ? travelTimeMinutes(state.currentNode, n.id, connected.kind) : null;

  tip.innerHTML = `
    <div style="font-weight:800">${n.name}${here ? " ‚Ä¢ (You)" : ""}</div>
    <div class="smallMuted">${prettyType(n.type)} ‚Ä¢ ${n.kingdom} ‚Ä¢ ${n.biome}${n.population?` ‚Ä¢ Pop ${n.population.toLocaleString()}`:""}</div>
    <div class="smallMuted">
      Connections: ${nb}
      ${tt!==null?` ‚Ä¢ Travel: ~${tt} min (${connected.kind}) ‚Ä¢ Cost: <b>${connected.cost||connected.fare||0}g</b>${connected.war?` ‚Ä¢ <span style="color:var(--bad)">WAR ZONE</span>`:""}`:""}
    </div>
  `;
  tip.style.display="block";
  tip.style.left = `${(e.clientX - rect.left) + 14}px`;
  tip.style.top  = `${(e.clientY - rect.top)  + 14}px`;
});

$("mapWrap").addEventListener("click", (e)=>{
  if(state.mode!=="world") return;

  const rect = $("mapWrap").getBoundingClientRect();
  const sx = (e.clientX - rect.left) * devicePixelRatio;
  const sy = (e.clientY - rect.top)  * devicePixelRatio;
  const w = screenToWorld(sx,sy);
  const n = getHoveredNode(w.wx, w.wy);
  if(!n) return;

  // only allow travel to connected nodes
  if(n.id===state.currentNode) return;
  if(!edgeBetween(state.currentNode, n.id)){
    pushLog("üö´ Not connected by a route.");
    render();
    return;
  }
  travelTo(n.id);
});


// --- Mini map interactions ---
function fitWorld(){
  const fit = Math.min(mapCanvas.width / WORLD_W, mapCanvas.height / WORLD_H);
  view.zoom = clamp(fit * 0.9, view.minZoom, view.maxZoom);
  view.x = WORLD_W/2;
  view.y = WORLD_H/2;
  draw();
}
function centerOnPlayer(){
  centerOnNode(state.currentNode);
  draw();
}

$("miniToggle").addEventListener("click", (e)=>{
  e.stopPropagation();
  const wrap = $("miniWrap");
  wrap.classList.toggle("expanded");
  // update icon
  $("miniToggle").textContent = wrap.classList.contains("expanded") ? "‚§°" : "‚§¢";
  resizeCanvases();
  $('miniWrap').style.display = showMinimap ? '' : 'none';
  draw();
});

$("miniWrap").addEventListener("click", (e)=>{
  if(state.mode==="dungeon") return;
  const rect = $("miniWrap").getBoundingClientRect();
  const sx = (e.clientX - rect.left) / rect.width;
  const sy = (e.clientY - rect.top)  / rect.height;
  view.x = clamp(sx * WORLD_W, 0, WORLD_W);
  view.y = clamp(sy * WORLD_H, 0, WORLD_H);
  draw();
});

$("centerBtn").addEventListener("click", (e)=>{ e.stopPropagation(); centerOnPlayer(); });
$("fitBtn").addEventListener("click", (e)=>{ e.stopPropagation(); fitWorld(); });

// --- Floating overlay controls ---
$("ovCenterBtn").addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); centerOnPlayer(); });
$("ovFitBtn").addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); fitWorld(); });
$("ovHomeBtn").addEventListener("click", (e)=>{
  e.preventDefault(); e.stopPropagation();
  const homeId = getBirthCapitalId(state.char.birthKingdom || "Valoria");
  state.currentNode = state.currentNode || homeId;
  centerOnNode(homeId);
  draw();
});

function syncOverlayToggles(){
  $("ovCostsBtn").textContent = `Costs: ${showRouteCosts ? "On" : "Off"}`;
  $("ovRegionsBtn").textContent = `Regions: ${showRegions ? "On" : "Off"}`;
  $("ovMiniBtn").textContent = `Minimap: ${showMinimap ? "On" : "Off"}`;
}

$("ovCostsBtn").addEventListener("click", (e)=>{
  e.preventDefault(); e.stopPropagation();
  showRouteCosts = !showRouteCosts;
  syncOverlayToggles();
  draw();
});
$("ovRegionsBtn").addEventListener("click", (e)=>{
  e.preventDefault(); e.stopPropagation();
  showRegions = !showRegions;
  syncOverlayToggles();
  draw();
});
$("ovMiniBtn").addEventListener("click", (e)=>{
  e.preventDefault(); e.stopPropagation();
  showMinimap = !showMinimap;
  $("miniWrap").style.display = showMinimap ? "" : "none";
  syncOverlayToggles();
  resizeCanvases();
  draw();
});
syncOverlayToggles();


/* =========================
   Keyboard controls (Dungeon)
========================= */
window.addEventListener("keydown", (e)=>{
  if(state.mode!=="dungeon") return;
  if(state.mode==="combat") return;

  const key = e.key.toLowerCase();
  if(key==="w" || e.key==="ArrowUp") dungeonMove(0,-1);
  if(key==="s" || e.key==="ArrowDown") dungeonMove(0, 1);
  if(key==="a" || e.key==="ArrowLeft") dungeonMove(-1,0);
  if(key==="d" || e.key==="ArrowRight") dungeonMove( 1,0);
});

/* =========================
   Main render() ‚Äî updates UI, then draw canvas
========================= */
function renderBadges(){
  const n = nodeById[state.currentNode];
  const modeText = state.mode==="world" ? "Exploring" : state.mode==="dungeon" ? "Dungeon" : "Combat";
  $("modeBadge").textContent = `Mode: ${modeText}`;
  $("locBadge").textContent = `Location: ${n ? n.name : "‚Äî"}`;
  $("clockBadge").textContent = `Day ${state.day} ‚Ä¢ ${fmtTime(state.minutes)}`;
  $("regionBadge").textContent = `Birth Region: ${state.char.birthKingdom || "‚Äî"}`;
  $("youAreHereText").textContent = `${n ? n.name : "‚Äî"} (${n?.kingdom||"‚Äî"})`;
}
function renderCharacterPanel(){
  $("level").textContent = String(state.char.level);
  $("hp").textContent = String(state.hp);
  $("hpMax").textContent = String(state.hpMax);
  $("atk").textContent = String(getAtk());
  $("def").textContent = String(getDef());
  $("energy").textContent = String(state.energy);
  $("energyMax").textContent = String(state.energyMax);
  $("hunger").textContent = String(state.hunger);
  $("gold").textContent = String(state.gold);
  $("bank").textContent = String(state.bank);
  $("carry").textContent = `${carryNow()}/${carryMax()}`;
  $("mount").textContent = state.mount ? state.mount.name : "None";

  const next = xpToNext(state.char.level);
  $("xpText").textContent = `${state.char.xp} / ${next} XP`;
  $("xpBar").style.width = `${clamp((state.char.xp/next)*100, 0, 100)}%`;

  $("charLine").textContent = `${state.char.name || "‚Äî"} ‚Ä¢ ${state.char.race} ${state.char.class}`;
  $("charLine2").textContent = `STR ${state.char.str} ‚Ä¢ DEX ${state.char.dex} ‚Ä¢ CON ${state.char.con} ‚Ä¢ INT ${state.char.int} ‚Ä¢ WIS ${state.char.wis} ‚Ä¢ CHA ${state.char.cha}`;
  $("age").textContent = String(state.char.age);
  $("dateText").textContent = `Year ${state.year} ‚Ä¢ ${SEASONS[state.seasonIndex]} ‚Ä¢ Day ${state.dayOfSeason}`;
}

function render(){
  // character creation flow
  if(!state.characterCreated){
    openCreator();
    setCreatorLocked(false);
    // sync default selections
    $("ccName").value = $("ccName").value || "";
    $("ccSex").value = state.char.sex || "Male";
    $("ccRace").value = state.char.race || "Human";
    $("ccClass").value = state.char.class || "Fighter";
    $("ccBirth").value = state.char.birthKingdom || "Valoria";
    updateCcRulesText();
    renderCcStats();
  } else {
    // ensure creator is locked and closable
    setCreatorLocked(true);
    // keep open only if user left it open; otherwise let them close
  }

  // ensure we have a starting node even for legacy saves
  if(!state.currentNode){
    state.currentNode = slug("Aurelia (Capital)");
    state.lastSafeNode = state.currentNode;
  }

  renderBadges();
  renderCharacterPanel();
  renderEquipmentSlots();
  renderBag();
  renderSpellsPanel();
  buildInteractOptions();
  renderLog();

  // draw
  if(state.mode!=="dungeon" && (!view.x && !view.y)){
    centerOnNode(state.currentNode);
  }
  draw();

  // save state
  save();
}

/* =========================
   Initialization
========================= */
function initAfterLoad(forceCenter=false){
  indexWorld();

  // validate current node
  if(!state.currentNode || !nodeById[state.currentNode]){
    state.currentNode = slug("Aurelia (Capital)");
    state.lastSafeNode = state.currentNode;
  }

  // refresh spell slots and spells list sanity
  if(state.characterCreated){
    refreshSpellSlotsToMax();
    if(!Array.isArray(state.char.spellsKnown)) state.char.spellsKnown = [];
  }

  // if new game, start day
  if(state.day===1 && state.log.length===0){
    startNewDay();
    pushLog("üß≠ Welcome to Apex Dice RPG ‚Äî Kingdoms.");
  }

  resizeCanvases();
  $('miniWrap').style.display = showMinimap ? '' : 'none';

  // camera defaults
  centerOnNode(state.currentNode);
  const fit = Math.min(mapCanvas.width / WORLD_W, mapCanvas.height / WORLD_H);
  if(forceCenter){
    view.zoom = clamp(fit * 0.9, view.minZoom, view.maxZoom);
  } else {
    // keep existing zoom but clamp to bounds
    view.zoom = clamp(view.zoom, view.minZoom, view.maxZoom);
  }
}
initAfterLoad(true);
render();
</script>

</body>
</html>
